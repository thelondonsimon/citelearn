mw.loader.implement("ext.visualEditor.core@2vn4d", function($, jQuery, require, module) {
    ve.Range = function VeRange(from, to) {
        this.from = arguments.length >= 1 ? from : 0;
        this.to = arguments.length >= 2 ? to : this.from;
        this.start = this.from < this.to ? this.from : this.to;
        this.end = this.from < this.to ? this.to : this.from;
    }
    ;
    OO.initClass(ve.Range);
    ve.Range.static.newFromJSON = function(json) {
        return this.newFromHash(JSON.parse(json));
    }
    ;
    ve.Range.static.newFromHash = function(hash) {
        return new ve.Range(hash.from,hash.to);
    }
    ;
    ve.Range.static.newCoveringRange = function(ranges, backwards) {
        var minStart, maxEnd, i, range;
        if (ranges.length === 0) {
            throw new Error('newCoveringRange() requires at least one range');
        }
        minStart = ranges[0].start;
        maxEnd = ranges[0].end;
        for (i = 1; i < ranges.length; i++) {
            if (ranges[i].start < minStart) {
                minStart = ranges[i].start;
            }
            if (ranges[i].end > maxEnd) {
                maxEnd = ranges[i].end;
            }
        }
        if (backwards) {
            range = new ve.Range(maxEnd,minStart);
        } else {
            range = new ve.Range(minStart,maxEnd);
        }
        return range;
    }
    ;
    ve.Range.prototype.containsOffset = function(offset) {
        return offset >= this.start && offset < this.end;
    }
    ;
    ve.Range.prototype.containsRange = function(range) {
        return range.start >= this.start && range.end <= this.end;
    }
    ;
    ve.Range.prototype.touchesRange = function(range) {
        return range.end >= this.start && range.start <= this.end;
    }
    ;
    ve.Range.prototype.overlapsRange = function(range) {
        return range.end > this.start && range.start < this.end;
    }
    ;
    ve.Range.prototype.getLength = function() {
        return this.end - this.start;
    }
    ;
    ve.Range.prototype.flip = function() {
        return new ve.Range(this.to,this.from);
    }
    ;
    ve.Range.prototype.translate = function(distance) {
        return new ve.Range(this.from + distance,this.to + distance);
    }
    ;
    ve.Range.prototype.equals = function(other) {
        return other && this.from === other.from && this.to === other.to;
    }
    ;
    ve.Range.prototype.equalsSelection = function(other) {
        return other && this.end === other.end && this.start === other.start;
    }
    ;
    ve.Range.prototype.truncate = function(limit) {
        if (limit >= 0) {
            return new ve.Range(this.start,Math.min(this.start + limit, this.end));
        } else {
            return new ve.Range(Math.max(this.end + limit, this.start),this.end);
        }
    }
    ;
    ve.Range.prototype.expand = function(other) {
        return ve.Range.static.newCoveringRange([this, other], this.isBackwards());
    }
    ;
    ve.Range.prototype.isCollapsed = function() {
        return this.from === this.to;
    }
    ;
    ve.Range.prototype.isBackwards = function() {
        return this.from > this.to;
    }
    ;
    ve.Range.prototype.toJSON = function() {
        return {
            type: 'range',
            from: this.from,
            to: this.to
        };
    }
    ;
    ve.SelectionState = function VeSelectionState(selection) {
        this.anchorNode = selection.anchorNode;
        this.anchorOffset = selection.anchorOffset;
        this.focusNode = selection.focusNode;
        this.focusOffset = selection.focusOffset;
        this.isCollapsed = selection.isCollapsed;
        if (this.isCollapsed === undefined) {
            this.isCollapsed = this.anchorNode === this.focusNode && this.anchorOffset === this.focusOffset;
        }
        this.isBackwards = selection.isBackwards;
        if (this.isBackwards === undefined) {
            this.isBackwards = ve.compareDocumentOrder(this.focusNode, this.focusOffset, this.anchorNode, this.anchorOffset) < 0;
        }
    }
    ;
    OO.initClass(ve.SelectionState);
    ve.SelectionState.static.newNullSelection = function() {
        return new ve.SelectionState({
            focusNode: null,
            focusOffset: 0,
            anchorNode: null,
            anchorOffset: 0
        });
    }
    ;
    ve.SelectionState.prototype.flip = function() {
        if (this.isCollapsed) {
            return this;
        }
        return new ve.SelectionState({
            anchorNode: this.focusNode,
            anchorOffset: this.focusOffset,
            focusNode: this.anchorNode,
            focusOffset: this.anchorOffset,
            isCollapsed: !1,
            isBackwards: !this.isBackwards
        });
    }
    ;
    ve.SelectionState.prototype.equalsSelection = function(other) {
        return this.anchorNode === other.anchorNode && this.anchorOffset === other.anchorOffset && this.focusNode === other.focusNode && this.focusOffset === other.focusOffset;
    }
    ;
    ve.SelectionState.prototype.getNativeRange = function(doc) {
        var range;
        if (this.anchorNode === null) {
            return null;
        }
        range = doc.createRange();
        if (this.isBackwards) {
            range.setStart(this.focusNode, this.focusOffset);
            range.setEnd(this.anchorNode, this.anchorOffset);
        } else {
            range.setStart(this.anchorNode, this.anchorOffset);
            if (!this.isCollapsed) {
                range.setEnd(this.focusNode, this.focusOffset);
            }
        }
        return range;
    }
    ;
    ve.Node = function VeNode() {
        this.type = this.constructor.static.name;
        this.parent = null;
        this.root = null;
        this.doc = null;
    }
    ;
    ve.Node.prototype.getChildNodeTypes = null;
    ve.Node.prototype.getParentNodeTypes = null;
    ve.Node.prototype.isAllowedChildNodeType = function(type) {
        var childTypes = this.getChildNodeTypes();
        return childTypes === null || childTypes.indexOf(type) !== -1;
    }
    ;
    ve.Node.prototype.isAllowedParentNodeType = function(type) {
        var parentTypes = this.getParentNodeTypes();
        return parentTypes === null || parentTypes.indexOf(type) !== -1;
    }
    ;
    ve.Node.prototype.getSuggestedParentNodeTypes = null;
    ve.Node.prototype.canHaveChildren = null;
    ve.Node.prototype.canHaveChildrenNotContent = null;
    ve.Node.prototype.canContainContent = null;
    ve.Node.prototype.isContent = null;
    ve.Node.prototype.isInternal = null;
    ve.Node.prototype.isMetaData = null;
    ve.Node.prototype.isWrapped = null;
    ve.Node.prototype.isUnwrappable = null;
    ve.Node.prototype.isFocusable = null;
    ve.Node.prototype.isAlignable = null;
    ve.Node.prototype.isCellable = null;
    ve.Node.prototype.isCellEditable = null;
    ve.Node.prototype.isDiffedAsList = null;
    ve.Node.prototype.isDiffedAsLeaf = null;
    ve.Node.prototype.hasSignificantWhitespace = null;
    ve.Node.prototype.handlesOwnChildren = null;
    ve.Node.prototype.shouldIgnoreChildren = null;
    ve.Node.prototype.getLength = null;
    ve.Node.prototype.getOffset = null;
    ve.Node.prototype.getRange = function(backwards) {
        var offset = this.getOffset() + (this.isWrapped() ? 1 : 0)
          , range = new ve.Range(offset,offset + this.getLength());
        return backwards ? range.flip() : range;
    }
    ;
    ve.Node.prototype.getOuterRange = function(backwards) {
        var range = new ve.Range(this.getOffset(),this.getOffset() + this.getOuterLength());
        return backwards ? range.flip() : range;
    }
    ;
    ve.Node.prototype.getOuterLength = function() {
        return this.getLength() + (this.isWrapped() ? 2 : 0);
    }
    ;
    ve.Node.prototype.getType = function() {
        return this.type;
    }
    ;
    ve.Node.prototype.getParent = function() {
        return this.parent;
    }
    ;
    ve.Node.prototype.getRoot = function() {
        return this.root;
    }
    ;
    ve.Node.prototype.setRoot = function(root) {
        var oldRoot = this.root;
        if (root === oldRoot) {
            return;
        }
        if (oldRoot) {
            this.root = null;
            this.emit('unroot', oldRoot);
        }
        this.root = root;
        if (root) {
            this.emit('root', root);
        }
    }
    ;
    ve.Node.prototype.getDocument = function() {
        return this.doc;
    }
    ;
    ve.Node.prototype.setDocument = function(doc) {
        var oldDoc = this.doc;
        if (doc === oldDoc) {
            return;
        }
        if (oldDoc) {
            this.doc = null;
            oldDoc.nodeDetached(this);
        }
        this.doc = doc;
        if (doc) {
            doc.nodeAttached(this);
        }
    }
    ;
    ve.Node.prototype.attach = function(parent) {
        this.parent = parent;
        this.setDocument(parent.getDocument());
        this.setRoot(parent.getRoot());
        this.emit('attach', parent);
    }
    ;
    ve.Node.prototype.detach = function() {
        var parent = this.parent;
        this.parent = null;
        this.setRoot(null);
        this.setDocument(null);
        this.emit('detach', parent);
    }
    ;
    ve.Node.prototype.traverseUpstream = function(callback) {
        var node = this;
        while (node) {
            if (callback(node) === false) {
                return node;
            }
            node = node.getParent();
        }
        return null;
    }
    ;
    ve.Node.prototype.findParent = function(type) {
        return this.traverseUpstream(function(node) {
            return !(node instanceof type);
        });
    }
    ;
    ve.Node.prototype.collectUpstream = function() {
        var nodes = [];
        this.traverseUpstream(function(node) {
            nodes.push(node);
        });
        return nodes;
    }
    ;
    ve.Node.prototype.isDownstreamOf = function(upstreamNode) {
        return this.traverseUpstream(function(node) {
            return node !== upstreamNode;
        }) !== null;
    }
    ;
    ve.Node.prototype.getOffsetPath = function() {
        var parent, node = this, path = [];
        while (true) {
            if (node.type === 'document') {
                return path;
            }
            parent = node.getParent();
            if (!parent) {
                return null;
            }
            path.unshift(parent.indexOf(node));
            node = parent;
        }
    }
    ;
    ve.PositionStep = function VePositionStep(node, type, offset) {
        this.node = node;
        this.type = type;
        this.offset = offset;
    }
    ;
    ve.BranchNode = function VeBranchNode(children) {
        this.children = Array.isArray(children) ? children : [];
    }
    ;
    OO.initClass(ve.BranchNode);
    ve.BranchNode.prototype.traverse = function(callback) {
        var i, len, children = this.getChildren();
        for (i = 0,
        len = children.length; i < len; i++) {
            callback.call(this, children[i]);
            if (children[i].hasChildren()) {
                children[i].traverse(callback);
            }
        }
    }
    ;
    ve.BranchNode.prototype.hasChildren = function() {
        return true;
    }
    ;
    ve.BranchNode.prototype.getChildren = function() {
        return this.children;
    }
    ;
    ve.BranchNode.prototype.indexOf = function(node) {
        return this.children.indexOf(node);
    }
    ;
    ve.BranchNode.prototype.setRoot = function(root) {
        var i, len, oldRoot = this.root;
        if (root === oldRoot) {
            return;
        }
        if (oldRoot) {
            this.root = null;
            for (i = 0,
            len = this.children.length; i < len; i++) {
                this.children[i].setRoot(null);
            }
            this.emit('unroot', oldRoot);
        }
        this.root = root;
        if (root) {
            for (i = 0,
            len = this.children.length; i < len; i++) {
                this.children[i].setRoot(root);
            }
            this.emit('root', root);
        }
    }
    ;
    ve.BranchNode.prototype.setDocument = function(doc) {
        var i, len, oldDoc = this.doc;
        if (doc === this.doc) {
            return;
        }
        if (oldDoc) {
            this.doc = null;
            for (i = 0,
            len = this.children.length; i < len; i++) {
                this.children[i].setDocument(null);
            }
            oldDoc.nodeDetached(this);
        }
        this.doc = doc;
        if (doc) {
            for (i = 0,
            len = this.children.length; i < len; i++) {
                this.children[i].setDocument(doc);
            }
            doc.nodeAttached(this);
        }
    }
    ;
    ve.BranchNode.prototype.getNodeFromOffset = function(offset, shallow) {
        var i, length, nodeLength, childNode, currentNode = this, nodeOffset = 0;
        if (typeof offset !== 'number') {
            throw new Error('Offset must be a number');
        }
        if (offset === 0) {
            return currentNode;
        }
        if (offset < 0) {
            throw new Error('Offset out of bounds');
        }
        SIBLINGS: while (currentNode.children.length) {
            for (i = 0,
            length = currentNode.children.length; i < length; i++) {
                childNode = currentNode.children[i];
                if (offset === nodeOffset) {
                    return currentNode;
                }
                if (childNode instanceof ve.ce.InternalListNode) {
                    break SIBLINGS;
                }
                nodeLength = childNode.getOuterLength();
                if (offset >= nodeOffset && offset < nodeOffset + nodeLength) {
                    if (!shallow && childNode.hasChildren() && childNode.getChildren().length) {
                        nodeOffset += 1;
                        currentNode = childNode;
                        continue SIBLINGS;
                    } else {
                        return childNode;
                    }
                }
                nodeOffset += nodeLength;
            }
            if (offset === nodeOffset) {
                return currentNode;
            }
        }
        return null;
    }
    ;
    ve.LeafNode = function VeLeafNode() {}
    ;
    ve.LeafNode.prototype.hasChildren = function() {
        return false;
    }
    ;
    ve.Document = function VeDocument(documentNode) {
        OO.EventEmitter.call(this);
        this.documentNode = documentNode;
        this.documentNode.setDocument(this);
    }
    ;
    OO.mixinClass(ve.Document, OO.EventEmitter);
    ve.Document.prototype.getDocumentNode = function() {
        return this.documentNode;
    }
    ;
    ve.Document.prototype.getBranchNodeFromOffset = function(offset) {
        var node = this.getDocumentNode().getNodeFromOffset(offset);
        if (node && !node.hasChildren()) {
            node = node.getParent();
        }
        return node;
    }
    ;
    ve.Document.prototype.selectNodes = function(range, mode) {
        var node, prevNode, nextNode, left, right, parentFrame, startInside, endInside, startBetween, endBetween, nodeRange, parentRange, isWrapped, isPrevUnwrapped, isNextUnwrapped, isEmptyBranch, doc = this.getDocumentNode(), retval = [], start = range.start, end = range.end, stack = [{
            node: doc,
            index: 0,
            startOffset: 0
        }], currentFrame = stack[0], startFound = !1;
        mode = mode || 'leaves';
        if (mode !== 'leaves' && mode !== 'branches' && mode !== 'covered' && mode !== 'siblings') {
            throw new Error('Invalid mode: ' + mode);
        }
        if (start < 0 || start > doc.getLength()) {
            throw new Error('Invalid start offset: ' + start);
        }
        if (end < 0 || end > doc.getLength()) {
            throw new Error('Invalid end offset: ' + end);
        }
        if (!doc.children || doc.children.length === 0) {
            nodeRange = new ve.Range(0,doc.getLength());
            return [{
                node: doc,
                range: new ve.Range(start,end),
                index: 0,
                nodeRange: nodeRange,
                nodeOuterRange: nodeRange
            }];
        }
        left = doc.children[0].isWrapped() ? 1 : 0;
        do {
            node = currentFrame.node.children[currentFrame.index];
            prevNode = currentFrame.node.children[currentFrame.index - 1];
            nextNode = currentFrame.node.children[currentFrame.index + 1];
            right = left + node.getLength();
            startInside = start >= left && start <= right;
            endInside = end >= left && end <= right;
            isWrapped = node.isWrapped();
            isPrevUnwrapped = prevNode ? !prevNode.isWrapped() : !1;
            isNextUnwrapped = nextNode ? !nextNode.isWrapped() : !1;
            isEmptyBranch = (node.getLength() === 0 || node.shouldIgnoreChildren()) && !node.isContent() && !node.canContainContent();
            startBetween = (isWrapped ? start === left - 1 : start === left) && !isPrevUnwrapped;
            endBetween = (isWrapped ? end === right + 1 : end === right) && !isNextUnwrapped;
            parentRange = new ve.Range(currentFrame.startOffset,currentFrame.startOffset + currentFrame.node.getLength());
            if (isWrapped && end === left - 1 && currentFrame.index === 0) {
                isWrapped = currentFrame.node.isWrapped();
                retval.push({
                    node: currentFrame.node,
                    indexInNode: 0,
                    range: new ve.Range(end,end),
                    nodeRange: parentRange,
                    nodeOuterRange: new ve.Range(parentRange.start - isWrapped,parentRange.end + isWrapped)
                });
                parentFrame = stack[stack.length - 2];
                if (parentFrame) {
                    retval[retval.length - 1].index = parentFrame.index;
                }
                return retval;
            }
            if (start === end && (startBetween || endBetween) && isWrapped) {
                isWrapped = currentFrame.node.isWrapped();
                retval = [{
                    node: currentFrame.node,
                    indexInNode: currentFrame.index + (endBetween ? 1 : 0),
                    range: new ve.Range(start,end),
                    nodeRange: parentRange,
                    nodeOuterRange: new ve.Range(parentRange.start - isWrapped,parentRange.end + isWrapped)
                }];
                parentFrame = stack[stack.length - 2];
                if (parentFrame) {
                    retval[0].index = parentFrame.index;
                }
                return retval;
            } else if (startBetween) {
                if ((mode === 'leaves' || (mode === 'covered' && endInside) || (mode === 'branches' && node.canHaveChildrenNotContent())) && node.children && node.children.length && !node.shouldIgnoreChildren()) {
                    currentFrame = {
                        node: node,
                        index: 0,
                        startOffset: left
                    };
                    stack.push(currentFrame);
                    startFound = !0;
                    if (node.children[0].isWrapped()) {
                        left++;
                    }
                    continue;
                } else if (!endInside) {
                    retval.push({
                        node: node,
                        index: currentFrame.index,
                        nodeRange: new ve.Range(left,right),
                        nodeOuterRange: new ve.Range(left - isWrapped,right + isWrapped),
                        parentOuterRange: new ve.Range(parentRange.start - currentFrame.node.isWrapped(),parentRange.end + currentFrame.node.isWrapped())
                    });
                    startFound = !0;
                } else {
                    return [{
                        node: node,
                        range: new ve.Range(start,end),
                        index: currentFrame.index,
                        nodeRange: new ve.Range(left,right),
                        nodeOuterRange: new ve.Range(left - isWrapped,right + isWrapped),
                        parentOuterRange: new ve.Range(parentRange.start - currentFrame.node.isWrapped(),parentRange.end + currentFrame.node.isWrapped())
                    }];
                }
            } else if (startInside && endInside) {
                if (node.children && node.children.length && (mode !== 'branches' || node.canHaveChildrenNotContent())) {
                    currentFrame = {
                        node: node,
                        index: 0,
                        startOffset: left
                    };
                    stack.push(currentFrame);
                    if (node.children[0].isWrapped()) {
                        left++;
                    }
                    continue;
                } else {
                    retval = [{
                        node: node,
                        range: new ve.Range(start,end),
                        index: currentFrame.index,
                        nodeRange: new ve.Range(left,right),
                        nodeOuterRange: new ve.Range(left - isWrapped,right + isWrapped),
                        parentOuterRange: new ve.Range(parentRange.start - currentFrame.node.isWrapped(),parentRange.end + currentFrame.node.isWrapped())
                    }];
                    if (isEmptyBranch) {
                        retval[0].indexInNode = 0;
                    }
                    return retval;
                }
            } else if (startInside) {
                if ((mode === 'leaves' || mode === 'covered' || (mode === 'branches' && node.canHaveChildrenNotContent())) && node.children && node.children.length) {
                    currentFrame = {
                        node: node,
                        index: 0,
                        startOffset: left
                    };
                    stack.push(currentFrame);
                    if (node.children[0].isWrapped()) {
                        left++;
                    }
                    continue;
                } else {
                    retval.push({
                        node: node,
                        range: new ve.Range(start,right),
                        index: currentFrame.index,
                        nodeRange: new ve.Range(left,right),
                        nodeOuterRange: new ve.Range(left - isWrapped,right + isWrapped),
                        parentOuterRange: new ve.Range(parentRange.start - currentFrame.node.isWrapped(),parentRange.end + currentFrame.node.isWrapped())
                    });
                    startFound = !0;
                }
            } else if (endBetween) {
                if ((mode === 'leaves' || (mode === 'branches' && node.canHaveChildrenNotContent())) && node.children && node.children.length) {
                    currentFrame = {
                        node: node,
                        index: 0,
                        startOffset: left
                    };
                    stack.push(currentFrame);
                    if (node.children[0].isWrapped()) {
                        left++;
                    }
                    continue;
                } else {
                    retval.push({
                        node: node,
                        index: currentFrame.index,
                        nodeRange: new ve.Range(left,right),
                        nodeOuterRange: new ve.Range(left - isWrapped,right + isWrapped),
                        parentOuterRange: new ve.Range(parentRange.start - currentFrame.node.isWrapped(),parentRange.end + currentFrame.node.isWrapped())
                    });
                    return retval;
                }
            } else if (endInside) {
                if ((mode === 'leaves' || mode === 'covered' || (mode === 'branches' && node.canHaveChildrenNotContent())) && node.children && node.children.length) {
                    currentFrame = {
                        node: node,
                        index: 0,
                        startOffset: left
                    };
                    stack.push(currentFrame);
                    if (node.children[0].isWrapped()) {
                        left++;
                    }
                    continue;
                } else {
                    retval.push({
                        node: node,
                        range: new ve.Range(left,end),
                        index: currentFrame.index,
                        nodeRange: new ve.Range(left,right),
                        nodeOuterRange: new ve.Range(left - isWrapped,right + isWrapped),
                        parentOuterRange: new ve.Range(parentRange.start - currentFrame.node.isWrapped(),parentRange.end + currentFrame.node.isWrapped())
                    });
                    return retval;
                }
            } else if (startFound && end > right) {
                if ((mode === 'leaves' || (mode === 'branches' && node.canHaveChildrenNotContent())) && node.children && node.children.length) {
                    currentFrame = {
                        node: node,
                        index: 0,
                        startOffset: left
                    };
                    stack.push(currentFrame);
                    if (node.children[0].isWrapped()) {
                        left++;
                    }
                    continue;
                } else {
                    retval.push({
                        node: node,
                        index: currentFrame.index,
                        nodeRange: new ve.Range(left,right),
                        nodeOuterRange: new ve.Range(left - isWrapped,right + isWrapped),
                        parentOuterRange: new ve.Range(parentRange.start - currentFrame.node.isWrapped(),parentRange.end + currentFrame.node.isWrapped())
                    });
                }
            }
            if (nextNode) {
                currentFrame.index++;
                left = right + (node.isWrapped() ? 1 : 0) + (nextNode.isWrapped() ? 1 : 0);
            } else {
                left = right + (node.isWrapped() ? 1 : 0);
                while (!nextNode) {
                    if (node.isWrapped() && start === left) {
                        parentRange = new ve.Range(currentFrame.startOffset,currentFrame.startOffset + currentFrame.node.getLength());
                        isWrapped = currentFrame.node.isWrapped();
                        retval = [{
                            node: currentFrame.node,
                            indexInNode: currentFrame.index + 1,
                            range: new ve.Range(left,left),
                            nodeRange: parentRange,
                            nodeOuterRange: new ve.Range(parentRange.start - isWrapped,parentRange.end + isWrapped)
                        }];
                        parentFrame = stack[stack.length - 2];
                        if (parentFrame) {
                            retval[0].index = parentFrame.index;
                        }
                    }
                    stack.pop();
                    if (stack.length === 0) {
                        return retval;
                    }
                    currentFrame = stack[stack.length - 1];
                    currentFrame.index++;
                    nextNode = currentFrame.node.children[currentFrame.index];
                    left++;
                }
                if (nextNode.isWrapped()) {
                    left++;
                }
            }
        } while (end >= left - 1);if (retval.length === 0) {
            throw new Error('Failed to select any nodes');
        }
        return retval;
    }
    ;
    ve.Document.prototype.getCoveredSiblingGroups = function(range) {
        var i, firstCoveredSibling, node, parentNode, siblingNode, leaves = this.selectNodes(range, 'leaves'), groups = [], lastEndOffset = 0;
        for (i = 0; i < leaves.length; i++) {
            if (leaves[i].nodeOuterRange.end <= lastEndOffset) {
                continue;
            }
            node = leaves[i].node;
            if (node.isContent()) {
                node = node.getParent();
            }
            parentNode = node.getParent();
            if (!parentNode) {
                break;
            }
            groups.push({
                parent: parentNode,
                grandparent: parentNode.getParent(),
                nodes: []
            });
            firstCoveredSibling = node;
            siblingNode = firstCoveredSibling;
            do {
                groups[groups.length - 1].nodes.push(siblingNode);
                i++;
                if (leaves[i] === undefined) {
                    break;
                }
                siblingNode = leaves[i].node;
                if (siblingNode.isContent()) {
                    siblingNode = siblingNode.getParent();
                }
            } while (siblingNode.getParent() === parentNode);i--;
            lastEndOffset = parentNode.getOuterRange().end;
        }
        return groups;
    }
    ;
    ve.Document.prototype.rangeInsideOneLeafNode = function(range) {
        var selected = this.selectNodes(range, 'leaves');
        return selected.length === 1 && selected[0].nodeRange.containsRange(range) && selected[0].indexInNode === undefined;
    }
    ;
    ve.Document.prototype.nodeAttached = function(node) {
        this.emit('nodeAttached', node);
    }
    ;
    ve.Document.prototype.nodeDetached = function(node) {
        this.emit('nodeDetached', node);
    }
    ;
    ve.EventSequencer = function VeEventSequencer(eventNames) {
        var i, len, eventName, eventSequencer = this;
        this.$node = null;
        this.eventNames = eventNames;
        this.eventHandlers = {};
        function makeEventHandler(eventName) {
            return function(ev) {
                return eventSequencer.onEvent(eventName, ev);
            }
            ;
        }
        this.pendingCalls = [];
        this.onListenersForEvent = {};
        this.afterListenersForEvent = {};
        this.afterOneListenersForEvent = {};
        for (i = 0,
        len = eventNames.length; i < len; i++) {
            eventName = eventNames[i];
            this.onListenersForEvent[eventName] = [];
            this.afterListenersForEvent[eventName] = [];
            this.afterOneListenersForEvent[eventName] = [];
            this.eventHandlers[eventName] = makeEventHandler(eventName);
        }
        this.onLoopListeners = [];
        this.afterLoopListeners = [];
        this.afterLoopOneListeners = [];
        this.doneOnLoop = !1;
        this.afterLoopTimeoutId = null;
    }
    ;
    ve.EventSequencer.prototype.attach = function($node) {
        this.detach();
        this.$node = $node.on(this.eventHandlers);
        return this;
    }
    ;
    ve.EventSequencer.prototype.detach = function() {
        if (this.$node === null) {
            return;
        }
        this.runPendingCalls();
        this.$node.off(this.eventHandlers);
        this.$node = null;
        return this;
    }
    ;
    ve.EventSequencer.prototype.onLoop = function(listeners) {
        if (!Array.isArray(listeners)) {
            listeners = [listeners];
        }
        ve.batchPush(this.onLoopListeners, listeners);
        return this;
    }
    ;
    ve.EventSequencer.prototype.on = function(listeners) {
        var eventName;
        for (eventName in listeners) {
            this.onListenersForEvent[eventName].push(listeners[eventName]);
        }
        return this;
    }
    ;
    ve.EventSequencer.prototype.after = function(listeners) {
        var eventName;
        for (eventName in listeners) {
            this.afterListenersForEvent[eventName].push(listeners[eventName]);
        }
        return this;
    }
    ;
    ve.EventSequencer.prototype.afterOne = function(listeners) {
        var eventName;
        for (eventName in listeners) {
            this.afterOneListenersForEvent[eventName].push(listeners[eventName]);
        }
        return this;
    }
    ;
    ve.EventSequencer.prototype.afterLoop = function(listeners) {
        if (!Array.isArray(listeners)) {
            listeners = [listeners];
        }
        ve.batchPush(this.afterLoopListeners, listeners);
        return this;
    }
    ;
    ve.EventSequencer.prototype.afterLoopOne = function(listeners) {
        if (!Array.isArray(listeners)) {
            listeners = [listeners];
        }
        ve.batchPush(this.afterLoopOneListeners, listeners);
        return this;
    }
    ;
    ve.EventSequencer.prototype.onEvent = function(eventName, ev) {
        var i, len, onListener, onListeners, pendingCall, eventSequencer, id;
        this.runPendingCalls(eventName);
        if (!this.doneOnLoop) {
            this.doneOnLoop = !0;
            this.doOnLoop();
        }
        onListeners = (this.onListenersForEvent[eventName] || []).slice();
        for (i = 0,
        len = onListeners.length; i < len; i++) {
            onListener = onListeners[i];
            this.callListener('on', eventName, i, onListener, ev);
        }
        pendingCall = {
            id: null,
            ev: ev,
            eventName: eventName
        };
        eventSequencer = this;
        id = this.postpone(function() {
            if (pendingCall.id === null) {
                return;
            }
            eventSequencer.resetAfterLoopTimeout();
            pendingCall.id = null;
            eventSequencer.afterEvent(eventName, ev);
        });
        pendingCall.id = id;
        this.pendingCalls.push(pendingCall);
    }
    ;
    ve.EventSequencer.prototype.afterEvent = function(eventName, ev) {
        var i, len, afterListeners, afterOneListeners;
        afterListeners = (this.afterListenersForEvent[eventName] || []).slice();
        afterOneListeners = (this.afterOneListenersForEvent[eventName] || []).splice(0);
        for (i = 0,
        len = afterListeners.length; i < len; i++) {
            this.callListener('after', eventName, i, afterListeners[i], ev);
        }
        for (i = 0,
        len = afterOneListeners.length; i < len; i++) {
            this.callListener('afterOne', eventName, i, afterOneListeners[i], ev);
        }
    }
    ;
    ve.EventSequencer.prototype.doOnLoop = function() {
        var i, len;
        for (i = 0,
        len = this.onLoopListeners.length; i < len; i++) {
            this.callListener('onLoop', null, i, this.onLoopListeners[i], null);
        }
    }
    ;
    ve.EventSequencer.prototype.doAfterLoop = function(myTimeoutId) {
        var i, len, afterLoopListeners, afterLoopOneListeners;
        if (this.afterLoopTimeoutId !== myTimeoutId) {
            return;
        }
        this.afterLoopTimeoutId = null;
        afterLoopListeners = this.afterLoopListeners.slice();
        afterLoopOneListeners = this.afterLoopOneListeners.splice(0);
        for (i = 0,
        len = afterLoopListeners.length; i < len; i++) {
            this.callListener('afterLoop', null, i, this.afterLoopListeners[i], null);
        }
        for (i = 0,
        len = afterLoopOneListeners.length; i < len; i++) {
            this.callListener('afterLoopOne', null, i, afterLoopOneListeners[i], null);
        }
        this.doneOnLoop = !1;
    }
    ;
    ve.EventSequencer.prototype.resetAfterLoopTimeout = function() {
        var timeoutId, eventSequencer = this;
        if (this.afterLoopTimeoutId !== null) {
            this.cancelPostponed(this.afterLoopTimeoutId);
        }
        timeoutId = this.postpone(function() {
            eventSequencer.doAfterLoop(timeoutId);
        });
        this.afterLoopTimeoutId = timeoutId;
    }
    ;
    ve.EventSequencer.prototype.runPendingCalls = function(eventName) {
        var i, pendingCall, afterKeyDownCalls = [];
        for (i = 0; i < this.pendingCalls.length; i++) {
            pendingCall = this.pendingCalls[i];
            if (pendingCall.id === null) {
                continue;
            }
            if (eventName === 'keypress' && pendingCall.eventName === 'keydown') {
                afterKeyDownCalls.push(pendingCall);
                continue;
            }
            this.cancelPostponed(pendingCall.id);
            pendingCall.id = null;
            this.afterEvent(pendingCall.eventName, pendingCall.ev);
        }
        this.pendingCalls.length = 0;
        this.pendingCalls.push.apply(this.pendingCalls, afterKeyDownCalls);
    }
    ;
    ve.EventSequencer.prototype.postpone = function(callback) {
        return setTimeout(callback);
    }
    ;
    ve.EventSequencer.prototype.cancelPostponed = function(timeoutId) {
        clearTimeout(timeoutId);
    }
    ;
    ve.EventSequencer.prototype.callListener = function(timing, eventName, i, listener, ev) {
        listener(ev);
    }
    ;
    ve.Scheduler = function VeScheduler() {}
    ;
    OO.initClass(ve.Scheduler);
    ve.Scheduler.static.maxDelay = 1000;
    ve.Scheduler.prototype.schedule = function(immediateAction, completionTest, delayHint) {
        var deferred = ve.createDeferred()
          , startTime = this.now()
          , testThenAct = function() {
            var complete;
            try {
                complete = completionTest();
            } catch (e) {
                deferred.reject(e);
                return;
            }
            if (complete) {
                deferred.resolve();
                return;
            }
            if (this.now() - startTime > this.constructor.static.maxDelay) {
                deferred.reject();
                return;
            }
            this.postpone(testThenAct, delayHint);
        }
        .bind(this);
        immediateAction();
        testThenAct();
        return deferred.promise();
    }
    ;
    ve.Scheduler.prototype.postpone = function(callback, delay) {
        return setTimeout(callback, delay);
    }
    ;
    ve.Scheduler.prototype.now = function() {
        return Date.now();
    }
    ;
    ve.scheduler = new ve.Scheduler();
    ve.dm = {};
    ve.dm.Model = function VeDmModel(element) {
        this.element = element || {
            type: this.constructor.static.name
        };
        this.store = null;
    }
    ;
    OO.initClass(ve.dm.Model);
    ve.dm.Model.static.name = null;
    ve.dm.Model.static.matchTagNames = null;
    ve.dm.Model.static.matchRdfaTypes = null;
    ve.dm.Model.static.allowedRdfaTypes = [];
    ve.dm.Model.static.matchFunction = null;
    ve.dm.Model.static.toDataElement = function() {
        return {
            type: this.name
        };
    }
    ;
    ve.dm.Model.static.toDomElements = function(dataElement, doc) {
        if (this.matchTagNames && this.matchTagNames.length === 1) {
            return [doc.createElement(this.matchTagNames[0])];
        }
        throw new Error('ve.dm.Model subclass must match a single tag name or implement toDomElements');
    }
    ;
    ve.dm.Model.static.enableAboutGrouping = !1;
    ve.dm.Model.static.preserveHtmlAttributes = !0;
    ve.dm.Model.static.getHashObject = function(dataElement) {
        var hash = {
            type: dataElement.type,
            attributes: dataElement.attributes
        };
        if (dataElement.originalDomElementsHash !== undefined) {
            hash.originalDomElementsHash = dataElement.originalDomElementsHash;
        }
        return hash;
    }
    ;
    ve.dm.Model.static.getMatchRdfaTypes = function() {
        return this.matchRdfaTypes;
    }
    ;
    ve.dm.Model.static.getAllowedRdfaTypes = function() {
        return this.allowedRdfaTypes;
    }
    ;
    ve.dm.Model.static.describeChanges = function(attributeChanges) {
        var key, change, descriptions = [];
        for (key in attributeChanges) {
            change = this.describeChange(key, attributeChanges[key]);
            if (change) {
                descriptions.push(change);
            }
        }
        return descriptions;
    }
    ;
    ve.dm.Model.static.describeChange = function(key, change) {
        if ((typeof change.from === 'object' && change.from !== null) || (typeof change.to === 'object' && change.to !== null)) {
            return ve.htmlMsg('visualeditor-changedesc-unknown', key);
        } else if (change.from === undefined) {
            return ve.htmlMsg('visualeditor-changedesc-set', key, this.wrapText('ins', change.to));
        } else if (change.to === undefined) {
            return ve.htmlMsg('visualeditor-changedesc-unset', key, this.wrapText('del', change.from));
        } else {
            return ve.htmlMsg('visualeditor-changedesc-changed', key, this.wrapText('del', change.from), this.wrapText('ins', change.to));
        }
    }
    ;
    ve.dm.Model.static.wrapText = function(tag, text) {
        var wrapper = document.createElement(tag);
        wrapper.appendChild(document.createTextNode(text));
        return wrapper;
    }
    ;
    ve.dm.Model.static.isDiffComparable = function(element, other) {
        return element.type === other.type;
    }
    ;
    ve.dm.Model.prototype.isInspectable = function() {
        return true;
    }
    ;
    ve.dm.Model.prototype.isEditable = function() {
        return true;
    }
    ;
    ve.dm.Model.prototype.getElement = function() {
        return this.element;
    }
    ;
    ve.dm.Model.prototype.getStore = function() {
        return this.store;
    }
    ;
    ve.dm.Model.prototype.getType = function() {
        return this.constructor.static.name;
    }
    ;
    ve.dm.Model.prototype.getAttribute = function(key) {
        return this.element && this.element.attributes ? this.element.attributes[key] : undefined;
    }
    ;
    ve.dm.Model.prototype.getAttributes = function(prefix) {
        var key, filtered, attributes = this.element && this.element.attributes ? this.element.attributes : {};
        if (prefix) {
            filtered = {};
            for (key in attributes) {
                if (key.indexOf(prefix) === 0) {
                    filtered[key.slice(prefix.length)] = attributes[key];
                }
            }
            return filtered;
        }
        return ve.extendObject({}, attributes);
    }
    ;
    ve.dm.Model.prototype.getOriginalDomElementsHash = function() {
        return this.element ? this.element.originalDomElementsHash : undefined;
    }
    ;
    ve.dm.Model.prototype.getOriginalDomElements = function(store) {
        return store.value(this.getOriginalDomElementsHash()) || [];
    }
    ;
    ve.dm.Model.prototype.getClonedElement = function() {
        return ve.copy(this.element);
    }
    ;
    ve.dm.Model.prototype.getHashObject = function() {
        return this.constructor.static.getHashObject(this.element);
    }
    ;
    ve.dm.Model.prototype.isDiffComparable = function(other) {
        return this.constructor.static.isDiffComparable(this.element, other.element, this.getStore(), other.getStore());
    }
    ;
    (function(ve) {
        ve.dm.ModelRegistry = function VeDmModelRegistry() {
            OO.Registry.call(this);
            this.modelsByTag = [{}, {}];
            this.modelsByTypeAndTag = [];
            this.modelsWithTypeRegExps = [[], []];
            this.registrationOrder = {};
            this.nextNumber = 0;
            this.extSpecificTypes = [];
        }
        ;
        OO.inheritClass(ve.dm.ModelRegistry, OO.Registry);
        function addType(obj) {
            var i, len, keys = Array.prototype.slice.call(arguments, 1, -1), value = arguments[arguments.length - 1], o = obj;
            for (i = 0,
            len = keys.length - 1; i < len; i++) {
                if (o[keys[i]] === undefined) {
                    o[keys[i]] = {};
                }
                o = o[keys[i]];
            }
            o[keys[i]] = o[keys[i]] || [];
            o[keys[i]].unshift(value);
        }
        function removeType(obj) {
            var index, keys = Array.prototype.slice.call(arguments, 1, -1), value = arguments[arguments.length - 1], arr = ve.getProp.apply(obj, [obj].concat(keys));
            if (arr) {
                index = arr.indexOf(value);
                if (index !== -1) {
                    arr.splice(index, 1);
                }
            }
        }
        ve.dm.ModelRegistry.prototype.register = function(constructor) {
            var i, j, tags, types, name = constructor.static && constructor.static.name;
            if (typeof name !== 'string' || name === '') {
                throw new Error('Model names must be strings and must not be empty');
            }
            if (!(constructor.prototype instanceof ve.dm.Model)) {
                throw new Error('Models must be subclasses of ve.dm.Model');
            }
            if (this.lookup(name) === constructor) {
                return;
            }
            if (constructor.prototype instanceof ve.dm.Annotation) {
                ve.dm.annotationFactory.register(constructor);
            } else if (constructor.prototype instanceof ve.dm.Node) {
                ve.dm.nodeFactory.register(constructor);
            } else {
                throw new Error('No factory associated with this ve.dm.Model subclass');
            }
            ve.dm.ModelRegistry.super.prototype.register.call(this, name, constructor);
            tags = constructor.static.matchTagNames === null ? [''] : constructor.static.matchTagNames;
            types = constructor.static.getMatchRdfaTypes() === null ? [''] : constructor.static.getMatchRdfaTypes();
            for (i = 0; i < tags.length; i++) {
                addType(this.modelsByTag, +!!constructor.static.matchFunction, tags[i], name);
            }
            for (i = 0; i < types.length; i++) {
                if (types[i]instanceof RegExp) {
                    addType(this.modelsWithTypeRegExps, +!!constructor.static.matchFunction, name);
                } else {
                    for (j = 0; j < tags.length; j++) {
                        addType(this.modelsByTypeAndTag, +!!constructor.static.matchFunction, types[i], tags[j], name);
                    }
                }
            }
            this.registrationOrder[name] = this.nextNumber++;
        }
        ;
        ve.dm.ModelRegistry.prototype.unregister = function(constructor) {
            var i, j, tags, types, name = constructor.static && constructor.static.name;
            if (typeof name !== 'string' || name === '') {
                throw new Error('Model names must be strings and must not be empty');
            }
            if (!(constructor.prototype instanceof ve.dm.Model)) {
                throw new Error('Models must be subclasses of ve.dm.Model');
            }
            if (constructor.prototype instanceof ve.dm.Annotation) {
                ve.dm.annotationFactory.unregister(constructor);
            } else if (constructor.prototype instanceof ve.dm.Node) {
                ve.dm.nodeFactory.unregister(constructor);
            } else {
                throw new Error('No factory associated with this ve.dm.Model subclass');
            }
            ve.dm.ModelRegistry.super.prototype.unregister.call(this, name);
            tags = constructor.static.matchTagNames === null ? [''] : constructor.static.matchTagNames;
            types = constructor.static.getMatchRdfaTypes() === null ? [''] : constructor.static.getMatchRdfaTypes();
            for (i = 0; i < tags.length; i++) {
                removeType(this.modelsByTag, +!!constructor.static.matchFunction, tags[i], name);
            }
            for (i = 0; i < types.length; i++) {
                if (types[i]instanceof RegExp) {
                    removeType(this.modelsWithTypeRegExps, +!!constructor.static.matchFunction, name);
                } else {
                    for (j = 0; j < tags.length; j++) {
                        removeType(this.modelsByTypeAndTag, +!!constructor.static.matchFunction, types[i], tags[j], name);
                    }
                }
            }
            delete this.registrationOrder[name];
        }
        ;
        ve.dm.ModelRegistry.prototype.matchElement = function(node, forceAboutGrouping, excludeTypes) {
            var i, name, model, matches, winner, types, tag = node.nodeName.toLowerCase(), reg = this;
            function byRegistrationOrderDesc(a, b) {
                return reg.registrationOrder[b] - reg.registrationOrder[a];
            }
            function matchTypeRegExps(type, tag, withFunc) {
                var i, j, types, matches = [], models = reg.modelsWithTypeRegExps[+withFunc];
                for (i = 0; i < models.length; i++) {
                    if (excludeTypes && excludeTypes.indexOf(models[i]) !== -1) {
                        continue;
                    }
                    types = reg.registry[models[i]].static.getMatchRdfaTypes();
                    for (j = 0; j < types.length; j++) {
                        if (types[j]instanceof RegExp && type.match(types[j]) && ((tag === '' && reg.registry[models[i]].static.matchTagNames === null) || (reg.registry[models[i]].static.matchTagNames || []).indexOf(tag) !== -1)) {
                            matches.push(models[i]);
                        }
                    }
                }
                return matches;
            }
            function allTypesAllowed(types, name) {
                var i, j, typeAllowed, model = reg.lookup(name), allowedTypes = model.static.getAllowedRdfaTypes(), matchTypes = model.static.getMatchRdfaTypes();
                if (allowedTypes === null || matchTypes === null) {
                    return true;
                }
                allowedTypes = allowedTypes.concat(matchTypes);
                function checkType(rule, type) {
                    return rule instanceof RegExp ? !!type.match(rule) : rule === type;
                }
                for (i = 0; i < types.length; i++) {
                    typeAllowed = !1;
                    for (j = 0; j < allowedTypes.length; j++) {
                        if (checkType(allowedTypes[j], types[i])) {
                            typeAllowed = !0;
                            break;
                        }
                    }
                    if (!typeAllowed) {
                        return false;
                    }
                }
                return true;
            }
            function matchWithFunc(types, tag) {
                var i, queue = [], queue2 = [];
                for (i = 0; i < types.length; i++) {
                    queue = queue.concat(ve.getProp(reg.modelsByTypeAndTag, 1, types[i], tag) || []);
                    if (excludeTypes) {
                        queue = OO.simpleArrayDifference(queue, excludeTypes);
                    }
                    queue2 = queue2.concat(matchTypeRegExps(types[i], tag, true));
                }
                queue = queue.filter(function(name) {
                    return allTypesAllowed(types, name);
                });
                queue2 = queue2.filter(function(name) {
                    return allTypesAllowed(types, name);
                });
                if (forceAboutGrouping) {
                    queue = queue.filter(function(name) {
                        return reg.registry[name].static.enableAboutGrouping;
                    });
                    queue2 = queue2.filter(function(name) {
                        return reg.registry[name].static.enableAboutGrouping;
                    });
                }
                queue.sort(byRegistrationOrderDesc);
                queue2.sort(byRegistrationOrderDesc);
                queue = queue.concat(queue2);
                for (i = 0; i < queue.length; i++) {
                    if (reg.registry[queue[i]].static.matchFunction(node)) {
                        return queue[i];
                    }
                }
                return null;
            }
            function matchWithoutFunc(types, tag) {
                var i, queue = [], queue2 = [], winningName = null;
                for (i = 0; i < types.length; i++) {
                    queue = queue.concat(ve.getProp(reg.modelsByTypeAndTag, 0, types[i], tag) || []);
                    if (excludeTypes) {
                        queue = OO.simpleArrayDifference(queue, excludeTypes);
                    }
                    queue2 = queue2.concat(matchTypeRegExps(types[i], tag, false));
                }
                queue = queue.filter(function(name) {
                    return allTypesAllowed(types, name);
                });
                queue2 = queue2.filter(function(name) {
                    return allTypesAllowed(types, name);
                });
                if (forceAboutGrouping) {
                    queue = queue.filter(function(name) {
                        return reg.registry[name].static.enableAboutGrouping;
                    });
                    queue2 = queue2.filter(function(name) {
                        return reg.registry[name].static.enableAboutGrouping;
                    });
                }
                queue = queue.length > 0 ? queue : queue2;
                for (i = 0; i < queue.length; i++) {
                    if (winningName === null || reg.registrationOrder[winningName] < reg.registrationOrder[queue[i]]) {
                        winningName = queue[i];
                    }
                }
                return winningName;
            }
            types = [];
            if (node.getAttribute) {
                if (node.getAttribute('rel')) {
                    types = types.concat(node.getAttribute('rel').trim().split(/\s+/));
                }
                if (node.getAttribute('typeof')) {
                    types = types.concat(node.getAttribute('typeof').trim().split(/\s+/));
                }
                if (node.getAttribute('property')) {
                    types = types.concat(node.getAttribute('property').trim().split(/\s+/));
                }
            }
            if (types.length) {
                winner = matchWithFunc(types, tag);
                if (winner !== null) {
                    return winner;
                }
                winner = matchWithFunc(types, '');
                if (winner !== null) {
                    return winner;
                }
            }
            matches = ve.getProp(this.modelsByTag, 1, tag) || [];
            for (i = 0; i < matches.length; i++) {
                name = matches[i];
                model = this.registry[name];
                if (model.static.getMatchRdfaTypes() === null && model.static.matchFunction(node)) {
                    return matches[i];
                }
            }
            matches = ve.getProp(this.modelsByTypeAndTag, 1, '', '') || [];
            for (i = 0; i < matches.length; i++) {
                if (this.registry[matches[i]].static.matchFunction(node)) {
                    return matches[i];
                }
            }
            winner = matchWithoutFunc(types, tag);
            if (winner !== null) {
                return winner;
            }
            winner = matchWithoutFunc(types, '');
            if (winner !== null) {
                return winner;
            }
            matches = ve.getProp(this.modelsByTag, 0, tag) || [];
            for (i = 0; i < matches.length; i++) {
                name = matches[i];
                model = this.registry[name];
                if (model.static.getMatchRdfaTypes() === null) {
                    return matches[i];
                }
            }
            matches = ve.getProp(this.modelsByTypeAndTag, 0, '', '') || [];
            if (matches.length > 0) {
                return matches[0];
            }
            return null;
        }
        ;
        ve.dm.ModelRegistry.prototype.isAnnotation = function(node) {
            var modelClass = this.lookup(this.matchElement(node));
            return (modelClass && modelClass.prototype)instanceof ve.dm.Annotation;
        }
        ;
        ve.dm.modelRegistry = new ve.dm.ModelRegistry();
    }(ve));
    ve.dm.ModelFactory = function VeDmModelFactory() {
        ve.dm.ModelFactory.super.call(this);
    }
    ;
    OO.inheritClass(ve.dm.ModelFactory, OO.Factory);
    ve.dm.ModelFactory.prototype.createFromElement = function(element) {
        if (element && element.type) {
            return this.create.apply(this, Array.prototype.concat.apply([element.type], arguments));
        }
        throw new Error('Element must have a .type property');
    }
    ;
    ve.dm.NodeFactory = function VeDmNodeFactory() {
        ve.dm.NodeFactory.super.call(this);
    }
    ;
    OO.inheritClass(ve.dm.NodeFactory, ve.dm.ModelFactory);
    ve.dm.NodeFactory.prototype.getDataElement = function(type, attributes) {
        var element = {
            type: type
        };
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            attributes = ve.extendObject({}, this.registry[type].static.defaultAttributes, attributes);
            if (!ve.isEmptyObject(attributes)) {
                element.attributes = ve.copy(attributes);
            }
            return element;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.getChildNodeTypes = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.childNodeTypes;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.getParentNodeTypes = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.parentNodeTypes;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.getSuggestedParentNodeTypes = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.suggestedParentNodeTypes;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.canNodeHaveChildren = function(type) {
        var types;
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            types = this.registry[type].static.childNodeTypes;
            return types === null || (Array.isArray(types) && types.length > 0);
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.canNodeHaveChildrenNotContent = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.canNodeHaveChildren(type) && !this.registry[type].static.canContainContent && !this.registry[type].static.isContent;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.isNodeWrapped = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.isWrapped;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.isNodeUnwrappable = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.isNodeWrapped(type) && this.registry[type].static.isUnwrappable;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.isMetaData = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.isMetaData;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.isRemovableMetaData = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.removable;
        }
        throw new Error('Unknown item type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.canNodeContainContent = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.canContainContent;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.canNodeTakeAnnotation = function(type, annotation) {
        var i, len, disallowedList;
        if (!Object.prototype.hasOwnProperty.call(this.registry, type)) {
            throw new Error('Unknown node type: ' + type);
        }
        disallowedList = this.registry[type].static.disallowedAnnotationTypes;
        for (i = 0,
        len = disallowedList.length; i < len; i++) {
            if (annotation instanceof ve.dm.annotationFactory.lookup(disallowedList[i])) {
                return false;
            }
        }
        return true;
    }
    ;
    ve.dm.NodeFactory.prototype.isNodeContent = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.isContent;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.canNodeSerializeAsContent = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.isContent || this.registry[type].static.canSerializeAsContent;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.isNodeFocusable = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.isFocusable;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.doesNodeHaveSignificantWhitespace = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.hasSignificantWhitespace;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.doesNodeHandleOwnChildren = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.handlesOwnChildren;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.shouldIgnoreChildren = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.ignoreChildren;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.isNodeInternal = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.isInternal;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.NodeFactory.prototype.isNodeDeletable = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.isDeletable;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.dm.nodeFactory = new ve.dm.NodeFactory();
    ve.dm.AnnotationFactory = function VeDmAnnotationFactory() {
        ve.dm.AnnotationFactory.super.call(this);
    }
    ;
    OO.inheritClass(ve.dm.AnnotationFactory, ve.dm.ModelFactory);
    ve.dm.annotationFactory = new ve.dm.AnnotationFactory();
    ve.dm.AnnotationSet = function VeDmAnnotationSet(store, storeHashes) {
        this.store = store;
        this.storeHashes = storeHashes || [];
        if (this.get().indexOf(undefined) !== -1) {
            throw new Error('Annotation with hash ' + this.storeHashes[this.get().indexOf(undefined)] + ' not found in store');
        }
    }
    ;
    ve.dm.AnnotationSet.prototype.getStore = function() {
        return this.store;
    }
    ;
    ve.dm.AnnotationSet.prototype.clone = function() {
        return new ve.dm.AnnotationSet(this.getStore(),this.storeHashes.slice());
    }
    ;
    ve.dm.AnnotationSet.prototype.getAnnotationsByName = function(name) {
        return this.filter(function(annotation) {
            return annotation.name === name;
        });
    }
    ;
    ve.dm.AnnotationSet.prototype.getComparableAnnotations = function(annotation) {
        return this.filter(function(a) {
            return ve.compare(annotation.getComparableObject(), a.getComparableObject());
        });
    }
    ;
    ve.dm.AnnotationSet.prototype.getComparableAnnotationsFromSet = function(annotations) {
        return this.filter(function(a) {
            return annotations.containsComparable(a);
        });
    }
    ;
    ve.dm.AnnotationSet.prototype.hasAnnotationWithName = function(name) {
        return this.containsMatching(function(annotation) {
            return annotation.name === name;
        });
    }
    ;
    ve.dm.AnnotationSet.prototype.get = function(offset) {
        if (offset !== undefined) {
            return this.getStore().value(this.getHash(offset));
        } else {
            return this.getStore().values(this.getHashes());
        }
    }
    ;
    ve.dm.AnnotationSet.prototype.getHash = function(offset) {
        return this.storeHashes[offset];
    }
    ;
    ve.dm.AnnotationSet.prototype.getHashes = function() {
        return this.storeHashes;
    }
    ;
    ve.dm.AnnotationSet.prototype.getLength = function() {
        return this.storeHashes.length;
    }
    ;
    ve.dm.AnnotationSet.prototype.isEmpty = function() {
        return this.getLength() === 0;
    }
    ;
    ve.dm.AnnotationSet.prototype.contains = function(annotation) {
        return this.offsetOf(annotation) !== -1;
    }
    ;
    ve.dm.AnnotationSet.prototype.containsHash = function(storeHash) {
        return this.getHashes().indexOf(storeHash) !== -1;
    }
    ;
    ve.dm.AnnotationSet.prototype.containsAnyOf = function(set) {
        var i, length, setHashes = set.getHashes(), thisHashes = this.getHashes();
        for (i = 0,
        length = setHashes.length; i < length; i++) {
            if (thisHashes.indexOf(setHashes[i]) !== -1) {
                return true;
            }
        }
        return false;
    }
    ;
    ve.dm.AnnotationSet.prototype.containsAllOf = function(set) {
        var i, length, setHashes = set.getHashes(), thisHashes = this.getHashes();
        for (i = 0,
        length = setHashes.length; i < length; i++) {
            if (thisHashes.indexOf(setHashes[i]) === -1) {
                return false;
            }
        }
        return true;
    }
    ;
    ve.dm.AnnotationSet.prototype.offsetOf = function(annotation) {
        return this.offsetOfHash(this.getStore().hashOfValue(annotation));
    }
    ;
    ve.dm.AnnotationSet.prototype.offsetOfHash = function(storeHash) {
        return this.getHashes().indexOf(storeHash);
    }
    ;
    ve.dm.AnnotationSet.prototype.filter = function(callback, returnBool) {
        var i, length, result, storeHash, annotation;
        if (!returnBool) {
            result = this.clone();
            result.removeAll();
        }
        for (i = 0,
        length = this.getLength(); i < length; i++) {
            storeHash = this.getHash(i);
            annotation = this.getStore().value(storeHash);
            if (callback(annotation)) {
                if (returnBool) {
                    return true;
                } else {
                    result.storeHashes.push(storeHash);
                }
            }
        }
        return returnBool ? false : result;
    }
    ;
    ve.dm.AnnotationSet.prototype.containsComparable = function(annotation) {
        return this.filter(function(a) {
            return annotation.compareTo(a);
        }, true);
    }
    ;
    ve.dm.AnnotationSet.prototype.getComparable = function(annotation) {
        var i, len, ann;
        for (i = 0,
        len = this.getLength(); i < len; i++) {
            ann = this.getStore().value(this.getHash(i));
            if (ann.compareTo(annotation)) {
                return ann;
            }
        }
        return null;
    }
    ;
    ve.dm.AnnotationSet.prototype.containsComparableForSerialization = function(annotation) {
        return this.filter(function(a) {
            return annotation.compareToForSerialization(a);
        }, true);
    }
    ;
    ve.dm.AnnotationSet.prototype.containsMatching = function(callback) {
        return this.filter(callback, true);
    }
    ;
    ve.dm.AnnotationSet.prototype.compareTo = function(annotationSet) {
        var i, length = this.getHashes().length;
        if (length === annotationSet.getLength()) {
            for (i = 0; i < length; i++) {
                if (!annotationSet.containsComparable(this.get(i))) {
                    return false;
                }
            }
        } else {
            return false;
        }
        return true;
    }
    ;
    ve.dm.AnnotationSet.prototype.withoutComparableSet = function(set) {
        return this.filter(function(annotation) {
            return !set.containsComparable(annotation);
        });
    }
    ;
    ve.dm.AnnotationSet.prototype.equalsInOrder = function(set) {
        var i, len, ourHashes = this.getHashes(), theirHashes = set.getHashes();
        if (ourHashes.length !== theirHashes.length) {
            return false;
        }
        for (i = 0,
        len = ourHashes.length; i < len; i++) {
            if (ourHashes[i] !== theirHashes[i]) {
                return false;
            }
        }
        return true;
    }
    ;
    ve.dm.AnnotationSet.prototype.add = function(annotation, offset) {
        var storeHash = this.getStore().hash(annotation);
        if (offset < 0) {
            offset = this.getLength() + offset;
        }
        if (offset >= this.getLength()) {
            this.push(annotation);
            return;
        }
        if (!this.containsHash(storeHash)) {
            this.storeHashes.splice(offset, 0, storeHash);
        }
    }
    ;
    ve.dm.AnnotationSet.prototype.addSet = function(set, offset) {
        var hashes = this.getHashes();
        if (offset === undefined) {
            offset = hashes.length;
        }
        this.storeHashes = OO.simpleArrayUnion(hashes.slice(0, offset), set.getHashes(), hashes.slice(offset));
    }
    ;
    ve.dm.AnnotationSet.prototype.push = function(annotation) {
        this.pushHash(this.getStore().hash(annotation));
    }
    ;
    ve.dm.AnnotationSet.prototype.pushHash = function(storeHash) {
        this.storeHashes.push(storeHash);
    }
    ;
    ve.dm.AnnotationSet.prototype.removeAt = function(offset) {
        if (offset < 0) {
            offset = this.getLength() + offset;
        }
        if (offset >= this.getLength()) {
            throw new Error('Offset out of bounds');
        }
        this.storeHashes.splice(offset, 1);
    }
    ;
    ve.dm.AnnotationSet.prototype.removeHash = function(storeHash) {
        var offset = this.offsetOfHash(storeHash);
        if (offset !== -1) {
            this.storeHashes.splice(offset, 1);
        }
    }
    ;
    ve.dm.AnnotationSet.prototype.remove = function(annotation) {
        var offset = this.offsetOf(annotation);
        if (offset !== -1) {
            this.storeHashes.splice(offset, 1);
        }
    }
    ;
    ve.dm.AnnotationSet.prototype.removeAll = function() {
        this.storeHashes = [];
    }
    ;
    ve.dm.AnnotationSet.prototype.removeSet = function(set) {
        this.storeHashes = OO.simpleArrayDifference(this.getHashes(), set.getHashes());
    }
    ;
    ve.dm.AnnotationSet.prototype.removeNotInSet = function(set) {
        this.storeHashes = OO.simpleArrayIntersection(this.getHashes(), set.getHashes());
    }
    ;
    ve.dm.AnnotationSet.prototype.reversed = function() {
        var newSet = this.clone();
        newSet.storeHashes.reverse();
        return newSet;
    }
    ;
    ve.dm.AnnotationSet.prototype.mergeWith = function(set) {
        var newSet = this.clone();
        newSet.addSet(set);
        return newSet;
    }
    ;
    ve.dm.AnnotationSet.prototype.diffWith = function(set) {
        var newSet = this.clone();
        newSet.removeSet(set);
        return newSet;
    }
    ;
    ve.dm.AnnotationSet.prototype.intersectWith = function(set) {
        var newSet = this.clone();
        newSet.removeNotInSet(set);
        return newSet;
    }
    ;
    ve.dm.Node = function VeDmNode(element) {
        ve.dm.Node.super.apply(this, arguments);
        ve.Node.call(this);
        OO.EventEmitter.call(this);
        this.length = 0;
        this.element = element;
    }
    ;
    OO.inheritClass(ve.dm.Node, ve.dm.Model);
    OO.mixinClass(ve.dm.Node, ve.Node);
    OO.mixinClass(ve.dm.Node, OO.EventEmitter);
    ve.dm.Node.static.handlesOwnChildren = !1;
    ve.dm.Node.static.ignoreChildren = !1;
    ve.dm.Node.static.isDeletable = !0;
    ve.dm.Node.static.isInternal = !1;
    ve.dm.Node.static.isWrapped = !0;
    ve.dm.Node.static.isUnwrappable = !0;
    ve.dm.Node.static.isContent = !1;
    ve.dm.Node.static.isMetaData = !1;
    ve.dm.Node.static.canSerializeAsContent = !1;
    ve.dm.Node.static.isFocusable = !1;
    ve.dm.Node.static.isAlignable = !1;
    ve.dm.Node.static.isCellable = !1;
    ve.dm.Node.static.canContainContent = !1;
    ve.dm.Node.static.isDiffedAsList = !1;
    ve.dm.Node.static.isDiffedAsLeaf = !1;
    ve.dm.Node.static.hasSignificantWhitespace = !1;
    ve.dm.Node.static.childNodeTypes = null;
    ve.dm.Node.static.parentNodeTypes = null;
    ve.dm.Node.static.suggestedParentNodeTypes = null;
    ve.dm.Node.static.disallowedAnnotationTypes = [];
    ve.dm.Node.static.defaultAttributes = {};
    ve.dm.Node.static.sanitize = function() {}
    ;
    ve.dm.Node.static.remapInternalListIndexes = function() {}
    ;
    ve.dm.Node.static.remapInternalListKeys = function() {}
    ;
    ve.dm.Node.static.isHybridInline = function(domElements, converter) {
        var i, length, allTagsInline = !0;
        for (i = 0,
        length = domElements.length; i < length; i++) {
            if (ve.isBlockElement(domElements[i])) {
                allTagsInline = !1;
                break;
            }
        }
        return (converter.isExpectingContent() && !converter.isInWrapper()) || (converter.isInWrapper() && !converter.canCloseWrapper()) || allTagsInline;
    }
    ;
    ve.dm.Node.static.cloneElement = function(element, store, preserveGenerated) {
        var about, originalDomElements, domElements, modified = !1, clone = ve.copy(element);
        if (!preserveGenerated) {
            ve.deleteProp(clone, 'internal', 'generated');
        }
        originalDomElements = store.value(clone.originalDomElementsHash);
        if (originalDomElements) {
            about = '#mwt' + Math.floor(1000000000 * Math.random());
            domElements = originalDomElements.map(function(el) {
                var elClone = el.cloneNode(true);
                if (elClone.hasAttribute && elClone.hasAttribute('about')) {
                    elClone.setAttribute('about', about);
                    modified = !0;
                }
                return elClone;
            });
            if (modified) {
                clone.originalDomElementsHash = store.hash(domElements, domElements.map(ve.getNodeHtml).join(''));
            }
        }
        return clone;
    }
    ;
    ve.dm.Node.prototype.getStore = function() {
        return this.doc && this.doc.store;
    }
    ;
    ve.dm.Node.prototype.getClonedElement = function(preserveGenerated) {
        var store = this.getStore();
        if (!store) {
            throw new Error('Node must be attached to the document to be cloned.');
        }
        return this.constructor.static.cloneElement(this.element, store, preserveGenerated);
    }
    ;
    ve.dm.Node.prototype.getChildNodeTypes = function() {
        return this.constructor.static.childNodeTypes;
    }
    ;
    ve.dm.Node.prototype.getParentNodeTypes = function() {
        return this.constructor.static.parentNodeTypes;
    }
    ;
    ve.dm.Node.prototype.getSuggestedParentNodeTypes = function() {
        return this.constructor.static.suggestedParentNodeTypes;
    }
    ;
    ve.dm.Node.prototype.canHaveChildren = function() {
        return ve.dm.nodeFactory.canNodeHaveChildren(this.type);
    }
    ;
    ve.dm.Node.prototype.canHaveChildrenNotContent = function() {
        return ve.dm.nodeFactory.canNodeHaveChildrenNotContent(this.type);
    }
    ;
    ve.dm.Node.prototype.isInternal = function() {
        return this.constructor.static.isInternal;
    }
    ;
    ve.dm.Node.prototype.isMetaData = function() {
        return this.constructor.static.isMetaData;
    }
    ;
    ve.dm.Node.prototype.isWrapped = function() {
        return this.constructor.static.isWrapped;
    }
    ;
    ve.dm.Node.prototype.isUnwrappable = function() {
        return this.isWrapped() && this.constructor.static.isUnwrappable;
    }
    ;
    ve.dm.Node.prototype.canContainContent = function() {
        return this.constructor.static.canContainContent;
    }
    ;
    ve.dm.Node.prototype.isContent = function() {
        return this.constructor.static.isContent;
    }
    ;
    ve.dm.Node.prototype.isFocusable = function() {
        return this.constructor.static.isFocusable;
    }
    ;
    ve.dm.Node.prototype.isAlignable = function() {
        return this.constructor.static.isAlignable;
    }
    ;
    ve.dm.Node.prototype.isCellable = function() {
        return this.constructor.static.isCellable;
    }
    ;
    ve.dm.Node.prototype.isCellEditable = function() {
        return this.constructor.static.isCellEditable;
    }
    ;
    ve.dm.Node.prototype.isDiffedAsList = function() {
        return this.constructor.static.isDiffedAsList;
    }
    ;
    ve.dm.Node.prototype.isDiffedAsLeaf = function() {
        return this.constructor.static.isDiffedAsLeaf;
    }
    ;
    ve.dm.Node.prototype.canHaveSlugBefore = function() {
        return !this.canContainContent() && this.getParentNodeTypes() === null;
    }
    ;
    ve.dm.Node.prototype.canHaveSlugAfter = ve.dm.Node.prototype.canHaveSlugBefore;
    ve.dm.Node.prototype.suppressSlugType = function() {
        return null;
    }
    ;
    ve.dm.Node.prototype.hasSignificantWhitespace = function() {
        return this.constructor.static.hasSignificantWhitespace;
    }
    ;
    ve.dm.Node.prototype.handlesOwnChildren = function() {
        return this.constructor.static.handlesOwnChildren;
    }
    ;
    ve.dm.Node.prototype.shouldIgnoreChildren = function() {
        return this.constructor.static.ignoreChildren;
    }
    ;
    ve.dm.Node.prototype.isSurfaceable = function() {
        return this.hasChildren() && !this.canContainContent() && !this.isMetaData() && !this.getChildNodeTypes();
    }
    ;
    ve.dm.Node.prototype.hasMatchingAncestor = function(type, attributes) {
        var node = this;
        while (node && !node.matches(type, attributes)) {
            node = node.getParent();
            if (node === null) {
                return false;
            }
        }
        return true;
    }
    ;
    ve.dm.Node.prototype.matches = function(type, attributes) {
        var key;
        if (this.getType() !== type) {
            return false;
        }
        if (attributes) {
            for (key in attributes) {
                if (this.getAttribute(key) !== attributes[key]) {
                    return false;
                }
            }
        }
        return true;
    }
    ;
    ve.dm.Node.prototype.getLength = function() {
        return this.length;
    }
    ;
    ve.dm.Node.prototype.setLength = function(length) {
        var diff;
        if (length < 0) {
            throw new Error('Length cannot be negative');
        }
        diff = length - this.length;
        this.length = length;
        if (this.parent) {
            this.parent.adjustLength(diff);
        }
        this.emit('lengthChange', diff);
        this.emit('update');
    }
    ;
    ve.dm.Node.prototype.adjustLength = function(adjustment) {
        this.setLength(this.length + adjustment);
    }
    ;
    ve.dm.Node.prototype.getOffset = function() {
        var i, len, siblings, offset;
        if (!this.parent) {
            return 0;
        }
        siblings = this.parent.children;
        offset = this.parent.getOffset() + (this.parent === this.root ? 0 : 1);
        for (i = 0,
        len = siblings.length; i < len; i++) {
            if (siblings[i] === this) {
                break;
            }
            offset += siblings[i].getOuterLength();
        }
        if (i === len) {
            throw new Error('Node not found in parent\'s children array');
        }
        return offset;
    }
    ;
    ve.dm.Node.prototype.canBeMergedWith = function(node) {
        var n1 = this
          , n2 = node;
        if (n1.canContainContent() && n2.isContent()) {
            n2 = n2.getParent();
        } else if (n2.canContainContent() && n1.isContent()) {
            n1 = n1.getParent();
        }
        while (n1 !== n2) {
            if ((n1 === null || n2 === null) || n1.getType() !== n2.getType()) {
                return false;
            }
            n1 = n1.getParent();
            n2 = n2.getParent();
        }
        return true;
    }
    ;
    ve.dm.ClassAttributeNode = function VeDmClassAttributeNode() {}
    ;
    OO.initClass(ve.dm.ClassAttributeNode);
    ve.dm.ClassAttributeNode.static.classAttributes = {};
    ve.dm.ClassAttributeNode.static.preserveHtmlAttributes = function(attribute) {
        return attribute !== 'class';
    }
    ;
    ve.dm.ClassAttributeNode.static.setClassAttributes = function(attributes, classAttr) {
        var className, i, l, unrecognizedClasses = [], classNames = classAttr ? classAttr.trim().split(/\s+/) : [];
        if (!classNames.length) {
            return;
        }
        for (i = 0,
        l = classNames.length; i < l; i++) {
            className = classNames[i];
            if (Object.prototype.hasOwnProperty.call(this.classAttributes, className)) {
                attributes = ve.extendObject(attributes, this.classAttributes[className]);
            } else {
                unrecognizedClasses.push(className);
            }
        }
        attributes.originalClasses = classAttr;
        attributes.unrecognizedClasses = unrecognizedClasses;
    }
    ;
    ve.dm.ClassAttributeNode.static.getClassAttrFromAttributes = function(attributes) {
        var className, key, classAttributeSet, hasClass, classNames = [];
        attributes = attributes || {};
        for (className in this.classAttributes) {
            classAttributeSet = this.classAttributes[className];
            hasClass = !0;
            for (key in classAttributeSet) {
                if (attributes[key] !== classAttributeSet[key]) {
                    hasClass = !1;
                    break;
                }
            }
            if (hasClass) {
                classNames.push(className);
            }
        }
        if (attributes.unrecognizedClasses) {
            classNames = OO.simpleArrayUnion(classNames, attributes.unrecognizedClasses);
        }
        if (attributes.originalClasses && ve.compareClassLists(attributes.originalClasses, classNames)) {
            return attributes.originalClasses;
        } else if (classNames.length > 0) {
            return classNames.join(' ');
        }
        return null;
    }
    ;
    ve.dm.ClassAttributeNode.static.sanitize = function(dataElement) {
        if (dataElement.attributes) {
            delete dataElement.attributes.unrecognizedClasses;
        }
    }
    ;
    ve.dm.AlignableNode = function VeDmAlignableNode() {
        ve.dm.AlignableNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.AlignableNode, ve.dm.ClassAttributeNode);
    ve.dm.AlignableNode.static.isAlignable = !0;
    ve.dm.AlignableNode.static.classAttributes = {
        've-align-left': {
            align: 'left'
        },
        've-align-right': {
            align: 'right'
        },
        've-align-center': {
            align: 'center'
        }
    };
    ve.dm.FocusableNode = function VeDmFocusableNode() {}
    ;
    OO.initClass(ve.dm.FocusableNode);
    ve.dm.FocusableNode.static.isFocusable = !0;
    ve.dm.ResizableNode = function VeDmResizableNode() {
        this.scalable = null;
        this.connect(this, {
            attributeChange: 'onResizableAttributeChange'
        });
    }
    ;
    OO.initClass(ve.dm.ResizableNode);
    ve.dm.ResizableNode.prototype.getScalable = function() {
        if (!this.scalable) {
            this.scalable = this.createScalable();
        }
        return this.scalable;
    }
    ;
    ve.dm.ResizableNode.prototype.createScalable = null;
    ve.dm.ResizableNode.prototype.onResizableAttributeChange = function(key) {
        if (key === 'width' || key === 'height') {
            this.getScalable().setCurrentDimensions(this.getCurrentDimensions());
        }
    }
    ;
    ve.dm.ResizableNode.prototype.getCurrentDimensions = function() {
        return {
            width: this.getAttribute('width'),
            height: this.getAttribute('height')
        };
    }
    ;
    ve.dm.TableCellableNode = function VeDmTableCellableNode() {
        this.connect(this, {
            attributeChange: 'onCellableAttributeChange'
        });
    }
    ;
    OO.initClass(ve.dm.TableCellableNode);
    ve.dm.TableCellableNode.static.isCellable = !0;
    ve.dm.TableCellableNode.static.setAttributes = function(attributes, domElements) {
        var style = domElements[0].nodeName.toLowerCase() === 'th' ? 'header' : 'data'
          , colspan = domElements[0].getAttribute('colspan')
          , rowspan = domElements[0].getAttribute('rowspan');
        attributes.style = style;
        if (colspan !== null) {
            attributes.originalColspan = colspan;
            if (colspan !== '' && !isNaN(Number(colspan))) {
                attributes.colspan = Number(colspan);
            }
        }
        if (rowspan !== null) {
            attributes.originalRowspan = rowspan;
            if (rowspan !== '' && !isNaN(Number(rowspan))) {
                attributes.rowspan = Number(rowspan);
            }
        }
    }
    ;
    ve.dm.TableCellableNode.static.applyAttributes = function(attributes, domElement) {
        var spans = {
            colspan: attributes.colspan,
            rowspan: attributes.rowspan
        };
        if (attributes.colspan === 1 && Number(attributes.originalColspan) !== 1) {
            spans.colspan = null;
        }
        if (attributes.rowspan === 1 && Number(attributes.originalRowspan) !== 1) {
            spans.rowspan = null;
        }
        if (attributes.colspan === undefined || attributes.colspan === Number(attributes.originalColspan)) {
            spans.colspan = attributes.originalColspan;
        }
        if (attributes.rowspan === undefined || attributes.rowspan === Number(attributes.originalRowspan)) {
            spans.rowspan = attributes.originalRowspan;
        }
        ve.setDomAttributes(domElement, spans);
    }
    ;
    ve.dm.TableCellableNode.prototype.getRowspan = function() {
        return this.element.attributes.rowspan || 1;
    }
    ;
    ve.dm.TableCellableNode.prototype.getColspan = function() {
        return this.element.attributes.colspan || 1;
    }
    ;
    ve.dm.TableCellableNode.prototype.getSpans = function() {
        return {
            col: this.getColspan(),
            row: this.getRowspan()
        };
    }
    ;
    ve.dm.TableCellableNode.prototype.getStyle = function() {
        return this.element.attributes.style || 'data';
    }
    ;
    ve.dm.TableCellableNode.prototype.onCellableAttributeChange = function(key) {
        if (this.getParent() && (key === 'colspan' || key === 'rowspan')) {
            this.findParent(ve.dm.TableNode).getMatrix().invalidate();
        }
    }
    ;
    ve.dm.Scalable = function VeDmScalable(config) {
        config = ve.extendObject({
            fixedRatio: !0,
            enforceMin: !0,
            enforceMax: !0
        }, config);
        OO.EventEmitter.call(this);
        this.ratio = null;
        this.valid = null;
        this.defaultSize = !1;
        this.currentDimensions = null;
        this.defaultDimensions = null;
        this.originalDimensions = null;
        this.minDimensions = null;
        this.maxDimensions = null;
        this.fixedRatio = config.fixedRatio;
        if (config.currentDimensions) {
            this.setCurrentDimensions(config.currentDimensions);
        }
        if (config.originalDimensions) {
            this.setOriginalDimensions(config.originalDimensions);
        }
        if (config.defaultDimensions) {
            this.setDefaultDimensions(config.defaultDimensions);
        }
        if (config.isDefault) {
            this.toggleDefault(!!config.isDefault);
        }
        if (config.minDimensions) {
            this.setMinDimensions(config.minDimensions);
        }
        if (config.maxDimensions) {
            this.setMaxDimensions(config.maxDimensions);
        }
        this.setEnforcedMin(config.enforceMin);
        this.setEnforcedMax(config.enforceMax);
    }
    ;
    OO.mixinClass(ve.dm.Scalable, OO.EventEmitter);
    ve.dm.Scalable.static.getDimensionsFromValue = function(dimensions, ratio) {
        dimensions = ve.copy(dimensions);
        if (dimensions.width === '') {
            dimensions.width = 0;
        }
        if (dimensions.height === '') {
            dimensions.height = 0;
        }
        if (!dimensions.height && ratio !== null && +dimensions.width) {
            dimensions.height = Math.round(dimensions.width / ratio);
        }
        if (!dimensions.width && ratio !== null && +dimensions.height) {
            dimensions.width = Math.round(dimensions.height * ratio);
        }
        return dimensions;
    }
    ;
    ve.dm.Scalable.static.isDimensionsObjectValid = function(dimensions) {
        if (dimensions && !ve.isEmptyObject(dimensions) && (dimensions.width !== undefined || dimensions.height !== undefined)) {
            return true;
        }
        return false;
    }
    ;
    ve.dm.Scalable.prototype.clone = function() {
        var currentDimensions = this.getCurrentDimensions()
          , originalDimensions = this.getOriginalDimensions()
          , defaultDimensions = this.getDefaultDimensions()
          , minDimensions = this.getMinDimensions()
          , maxDimensions = this.getMaxDimensions()
          , config = {
            isDefault: !!this.isDefault(),
            enforceMin: !!this.isEnforcedMin(),
            enforceMax: !!this.isEnforcedMax()
        };
        if (currentDimensions) {
            config.currentDimensions = ve.copy(currentDimensions);
        }
        if (originalDimensions) {
            config.originalDimensions = ve.copy(originalDimensions);
        }
        if (defaultDimensions) {
            config.defaultDimensions = ve.copy(defaultDimensions);
        }
        if (minDimensions) {
            config.minDimensions = ve.copy(minDimensions);
        }
        if (maxDimensions) {
            config.maxDimensions = ve.copy(maxDimensions);
        }
        return new this.constructor(config);
    }
    ;
    ve.dm.Scalable.prototype.setRatioFromDimensions = function(dimensions) {
        if (dimensions && dimensions.width && dimensions.height) {
            this.ratio = dimensions.width / dimensions.height;
        }
        this.valid = null;
    }
    ;
    ve.dm.Scalable.prototype.setCurrentDimensions = function(dimensions) {
        if (this.constructor.static.isDimensionsObjectValid(dimensions) && !ve.compare(dimensions, this.getCurrentDimensions())) {
            this.currentDimensions = ve.copy(dimensions);
            if (this.fixedRatio && !this.ratio) {
                this.setRatioFromDimensions(this.getCurrentDimensions());
            }
            this.valid = null;
            this.emit('currentSizeChange', this.getCurrentDimensions());
        }
    }
    ;
    ve.dm.Scalable.prototype.setOriginalDimensions = function(dimensions) {
        if (this.constructor.static.isDimensionsObjectValid(dimensions) && !ve.compare(dimensions, this.getOriginalDimensions())) {
            this.originalDimensions = ve.copy(dimensions);
            if (this.fixedRatio) {
                this.setRatioFromDimensions(this.getOriginalDimensions());
            }
            this.valid = null;
            this.emit('originalSizeChange', this.getOriginalDimensions());
        }
    }
    ;
    ve.dm.Scalable.prototype.setDefaultDimensions = function(dimensions) {
        if (this.constructor.static.isDimensionsObjectValid(dimensions) && !ve.compare(dimensions, this.getDefaultDimensions())) {
            this.defaultDimensions = ve.copy(dimensions);
            this.valid = null;
            this.emit('defaultSizeChange', this.isDefault());
        }
    }
    ;
    ve.dm.Scalable.prototype.clearDefaultDimensions = function() {
        if (this.defaultDimensions !== null) {
            this.defaultDimensions = null;
            this.valid = null;
            this.emit('defaultSizeChange', this.isDefault());
        }
    }
    ;
    ve.dm.Scalable.prototype.clearOriginalDimensions = function() {
        if (this.originalDimensions !== null) {
            this.originalDimensions = null;
            this.valid = null;
            this.emit('originalSizeChange', this.isDefault());
        }
    }
    ;
    ve.dm.Scalable.prototype.toggleDefault = function(isDefault) {
        if (isDefault === undefined) {
            isDefault = !this.isDefault();
        }
        if (this.isDefault() !== isDefault) {
            this.defaultSize = isDefault;
            if (isDefault) {
                this.setCurrentDimensions(this.getDefaultDimensions());
            }
            this.emit('defaultSizeChange', this.isDefault());
        }
    }
    ;
    ve.dm.Scalable.prototype.setMinDimensions = function(dimensions) {
        if (this.constructor.static.isDimensionsObjectValid(dimensions) && !ve.compare(dimensions, this.getMinDimensions())) {
            this.minDimensions = ve.copy(dimensions);
            this.valid = null;
            this.emit('minSizeChange', dimensions);
        }
    }
    ;
    ve.dm.Scalable.prototype.setMaxDimensions = function(dimensions) {
        if (this.constructor.static.isDimensionsObjectValid(dimensions) && !ve.compare(dimensions, this.getMaxDimensions())) {
            this.maxDimensions = ve.copy(dimensions);
            this.emit('maxSizeChange', dimensions);
            this.valid = null;
        }
    }
    ;
    ve.dm.Scalable.prototype.clearMinDimensions = function() {
        if (this.minDimensions !== null) {
            this.minDimensions = null;
            this.valid = null;
            this.emit('minSizeChange', this.minDimensions);
        }
    }
    ;
    ve.dm.Scalable.prototype.clearMaxDimensions = function() {
        if (this.maxDimensions !== null) {
            this.maxDimensions = null;
            this.valid = null;
            this.emit('maxSizeChange', this.maxDimensions);
        }
    }
    ;
    ve.dm.Scalable.prototype.getCurrentDimensions = function() {
        return this.currentDimensions;
    }
    ;
    ve.dm.Scalable.prototype.getOriginalDimensions = function() {
        return this.originalDimensions;
    }
    ;
    ve.dm.Scalable.prototype.getDefaultDimensions = function() {
        return this.defaultDimensions;
    }
    ;
    ve.dm.Scalable.prototype.isDefault = function() {
        return this.defaultSize;
    }
    ;
    ve.dm.Scalable.prototype.getMinDimensions = function() {
        return this.minDimensions;
    }
    ;
    ve.dm.Scalable.prototype.getMaxDimensions = function() {
        return this.maxDimensions;
    }
    ;
    ve.dm.Scalable.prototype.isEnforcedMin = function() {
        return this.enforceMin;
    }
    ;
    ve.dm.Scalable.prototype.isEnforcedMax = function() {
        return this.enforceMax;
    }
    ;
    ve.dm.Scalable.prototype.setEnforcedMin = function(enforceMin) {
        this.valid = null;
        this.enforceMin = !!enforceMin;
    }
    ;
    ve.dm.Scalable.prototype.setEnforcedMax = function(enforceMax) {
        this.valid = null;
        this.enforceMax = !!enforceMax;
    }
    ;
    ve.dm.Scalable.prototype.getRatio = function() {
        return this.ratio;
    }
    ;
    ve.dm.Scalable.prototype.isFixedRatio = function() {
        return this.fixedRatio;
    }
    ;
    ve.dm.Scalable.prototype.getCurrentScale = function() {
        if (!this.isFixedRatio() || !this.getCurrentDimensions() || !this.getOriginalDimensions()) {
            return null;
        }
        return this.getCurrentDimensions().width / this.getOriginalDimensions().width;
    }
    ;
    ve.dm.Scalable.prototype.isTooSmall = function() {
        return !!(this.getCurrentDimensions() && this.getMinDimensions() && (this.getCurrentDimensions().width < this.getMinDimensions().width || this.getCurrentDimensions().height < this.getMinDimensions().height));
    }
    ;
    ve.dm.Scalable.prototype.isTooLarge = function() {
        return !!(this.getCurrentDimensions() && this.getMaxDimensions() && (this.getCurrentDimensions().width > this.getMaxDimensions().width || this.getCurrentDimensions().height > this.getMaxDimensions().height));
    }
    ;
    ve.dm.Scalable.prototype.getBoundedDimensions = function(dimensions, grid) {
        var ratio, snap, snapMin, snapMax, minDimensions = this.isEnforcedMin() && this.getMinDimensions(), maxDimensions = this.isEnforcedMax() && this.getMaxDimensions();
        dimensions = ve.copy(dimensions);
        if (minDimensions) {
            dimensions.width = Math.max(dimensions.width, this.minDimensions.width);
            dimensions.height = Math.max(dimensions.height, this.minDimensions.height);
        }
        if (maxDimensions) {
            dimensions.width = Math.min(dimensions.width, this.maxDimensions.width);
            dimensions.height = Math.min(dimensions.height, this.maxDimensions.height);
        }
        if (this.isFixedRatio()) {
            ratio = dimensions.width / dimensions.height;
            if (ratio < this.getRatio()) {
                dimensions.height = Math.round(dimensions.width / this.getRatio());
            } else {
                dimensions.width = Math.round(dimensions.height * this.getRatio());
            }
        }
        if (grid) {
            snapMin = minDimensions ? Math.ceil(minDimensions.width / grid) : -Infinity;
            snapMax = maxDimensions ? Math.floor(maxDimensions.width / grid) : Infinity;
            snap = Math.round(dimensions.width / grid);
            dimensions.width = Math.max(Math.min(snap, snapMax), snapMin) * grid;
            if (this.isFixedRatio()) {
                dimensions.height = Math.round(dimensions.width / this.getRatio());
            } else {
                snapMin = minDimensions ? Math.ceil(minDimensions.height / grid) : -Infinity;
                snapMax = maxDimensions ? Math.floor(maxDimensions.height / grid) : Infinity;
                snap = Math.round(dimensions.height / grid);
                dimensions.height = Math.max(Math.min(snap, snapMax), snapMin) * grid;
            }
        }
        return dimensions;
    }
    ;
    ve.dm.Scalable.prototype.isCurrentDimensionsValid = function() {
        var dimensions = this.getCurrentDimensions()
          , minDimensions = this.isEnforcedMin() && !ve.isEmptyObject(this.getMinDimensions()) && this.getMinDimensions()
          , maxDimensions = this.isEnforcedMax() && !ve.isEmptyObject(this.getMaxDimensions()) && this.getMaxDimensions();
        this.valid = (!!dimensions && +dimensions.width && +dimensions.height && (!minDimensions || (dimensions.width >= minDimensions.width && dimensions.height >= minDimensions.height)) && (!maxDimensions || (dimensions.width <= maxDimensions.width && dimensions.height <= maxDimensions.height)));
        return this.valid;
    }
    ;
    ve.dm.BranchNode = function VeDmBranchNode(element, children) {
        ve.BranchNode.call(this);
        ve.dm.BranchNode.super.call(this, element);
        this.slugPositions = {};
        if (Array.isArray(children) && children.length) {
            this.splice.apply(this, [0, 0].concat(children));
        }
    }
    ;
    OO.inheritClass(ve.dm.BranchNode, ve.dm.Node);
    OO.mixinClass(ve.dm.BranchNode, ve.BranchNode);
    ve.dm.BranchNode.prototype.push = function(childModel) {
        this.splice(this.children.length, 0, childModel);
        return this.children.length;
    }
    ;
    ve.dm.BranchNode.prototype.pop = function() {
        var childModel;
        if (this.children.length) {
            childModel = this.children[this.children.length - 1];
            this.splice(this.children.length - 1, 1);
            return childModel;
        }
    }
    ;
    ve.dm.BranchNode.prototype.unshift = function(childModel) {
        this.splice(0, 0, childModel);
        return this.children.length;
    }
    ;
    ve.dm.BranchNode.prototype.shift = function() {
        var childModel;
        if (this.children.length) {
            childModel = this.children[0];
            this.splice(0, 1);
            return childModel;
        }
    }
    ;
    ve.dm.BranchNode.prototype.splice = function() {
        var i, length, removals, args = Array.prototype.slice.call(arguments), diff = 0;
        removals = this.children.splice.apply(this.children, args);
        for (i = 0,
        length = removals.length; i < length; i++) {
            removals[i].detach();
            diff -= removals[i].getOuterLength();
        }
        if (args.length >= 3) {
            length = args.length;
            for (i = 2; i < length; i++) {
                args[i].attach(this);
                diff += args[i].getOuterLength();
            }
        }
        this.adjustLength(diff, true);
        this.setupBlockSlugs();
        this.emit.apply(this, ['splice'].concat(args));
        return removals;
    }
    ;
    ve.dm.BranchNode.prototype.setupBlockSlugs = function() {
        var i, j, len, canHaveSlugAfter, canHaveSlugBefore, suppressSlugTypeAfter, suppressSlugTypeBefore, isBlock = this.canHaveChildrenNotContent();
        this.slugPositions = {};
        if (isBlock && !this.isAllowedChildNodeType('paragraph')) {
            return;
        }
        len = this.children.length;
        i = -1;
        j = 0;
        while (i < len) {
            while (j < len && this.children[j].isMetaData()) {
                j++;
            }
            canHaveSlugAfter = i === -1 || (this.children[i].canHaveSlugAfter() && !this.children[i].isInternal());
            canHaveSlugBefore = j === len || this.children[j].canHaveSlugBefore();
            if (canHaveSlugAfter && canHaveSlugBefore) {
                suppressSlugTypeAfter = this.children[j] && this.children[j].suppressSlugType();
                suppressSlugTypeBefore = this.children[i] && this.children[i].suppressSlugType();
                if (!(typeof suppressSlugTypeAfter === 'string' && suppressSlugTypeAfter === suppressSlugTypeBefore)) {
                    this.slugPositions[j] = !0;
                }
            }
            i = j;
            j++;
        }
    }
    ;
    ve.dm.BranchNode.prototype.hasSlugAtOffset = function(offset) {
        var i, startOffset = this.getOffset() + (this.isWrapped() ? 1 : 0);
        if (offset === startOffset) {
            return !!this.slugPositions[0];
        }
        for (i = 0; i < this.children.length; i++) {
            startOffset += this.children[i].getOuterLength();
            if (offset === startOffset) {
                return !!this.slugPositions[i + 1];
            }
        }
        return false;
    }
    ;
    ve.dm.ContentBranchNode = function VeDmContentBranchNode() {
        ve.dm.ContentBranchNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.ContentBranchNode, ve.dm.BranchNode);
    ve.dm.ContentBranchNode.static.canContainContent = !0;
    ve.dm.ContentBranchNode.static.isDiffedAsLeaf = !0;
    ve.dm.LeafNode = function VeDmLeafNode() {
        ve.LeafNode.call(this);
        ve.dm.LeafNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.LeafNode, ve.dm.Node);
    OO.mixinClass(ve.dm.LeafNode, ve.LeafNode);
    ve.dm.LeafNode.static.childNodeTypes = [];
    ve.dm.LeafNode.static.isDiffedAsLeaf = !0;
    ve.dm.LeafNode.prototype.getAnnotations = function() {
        return this.element.annotations || [];
    }
    ;
    ve.dm.Annotation = function VeDmAnnotation(element, store) {
        ve.dm.Annotation.super.call(this, element);
        this.name = this.constructor.static.name;
        this.store = store;
    }
    ;
    OO.inheritClass(ve.dm.Annotation, ve.dm.Model);
    ve.dm.Annotation.static.enableAboutGrouping = !1;
    ve.dm.Annotation.static.applyToAppendedContent = !0;
    ve.dm.Annotation.static.inferFromView = !1;
    ve.dm.Annotation.static.removes = [];
    ve.dm.Annotation.static.trimWhitespace = !0;
    ve.dm.Annotation.static.toDomElements = null;
    ve.dm.Annotation.prototype.getComparableObject = function() {
        var hashObject = this.getHashObject();
        delete hashObject.originalDomElementsHash;
        return hashObject;
    }
    ;
    ve.dm.Annotation.prototype.getComparableHtmlAttributes = function() {
        var comparableAttributes, metadataIdRegExp, domElements = this.store && this.getOriginalDomElements(this.store);
        if (domElements && domElements[0]) {
            comparableAttributes = ve.getDomAttributes(domElements[0]);
            delete comparableAttributes['data-parsoid'];
            if (comparableAttributes.id) {
                metadataIdRegExp = ve.init.platform.getMetadataIdRegExp();
                if (metadataIdRegExp && comparableAttributes.id.match(metadataIdRegExp)) {
                    delete comparableAttributes.id;
                }
            }
            return comparableAttributes;
        }
        return {};
    }
    ;
    ve.dm.Annotation.prototype.getComparableObjectForSerialization = function() {
        var object = this.getComparableObject()
          , htmlAttributes = this.getComparableHtmlAttributes();
        if (!ve.isEmptyObject(htmlAttributes)) {
            object.htmlAttributes = htmlAttributes;
        }
        return object;
    }
    ;
    ve.dm.Annotation.prototype.isGenerated = function() {
        return this.getOriginalDomElementsHash() !== undefined;
    }
    ;
    ve.dm.Annotation.prototype.compareTo = function(annotation) {
        return ve.compare(this.getComparableObject(), annotation.getComparableObject());
    }
    ;
    ve.dm.Annotation.prototype.compareToForSerialization = function(annotation) {
        if (this.isGenerated() && annotation.isGenerated()) {
            return ve.compare(this.getHashObject(), annotation.getHashObject());
        }
        return ve.compare(this.getComparableObjectForSerialization(), annotation.getComparableObjectForSerialization());
    }
    ;
    ve.dm.InternalList = function VeDmInternalList(doc) {
        OO.EventEmitter.call(this);
        this.document = doc;
        this.itemHtmlQueue = [];
        this.listNode = null;
        this.nodes = {};
        this.groupsChanged = [];
        this.keyIndexes = {};
        this.keys = [];
        this.nextUniqueNumber = 0;
        if (doc) {
            doc.connect(this, {
                transact: 'onTransact'
            });
        }
    }
    ;
    OO.mixinClass(ve.dm.InternalList, OO.EventEmitter);
    ve.dm.InternalList.prototype.queueItemHtml = function(groupName, key, html) {
        var isNew = !1
          , index = this.getKeyIndex(groupName, key);
        if (index === undefined) {
            index = this.itemHtmlQueue.length;
            this.keyIndexes[groupName + '/' + key] = index;
            this.itemHtmlQueue.push(html);
            isNew = !0;
        } else if (this.itemHtmlQueue[index] === '') {
            this.itemHtmlQueue[index] = html;
            isNew = !0;
        }
        return {
            index: index,
            isNew: isNew
        };
    }
    ;
    ve.dm.InternalList.prototype.getItemHtmlQueue = function() {
        return this.itemHtmlQueue;
    }
    ;
    ve.dm.InternalList.prototype.getDocument = function() {
        return this.document;
    }
    ;
    ve.dm.InternalList.prototype.getListNode = function() {
        var i, nodes;
        if (!this.listNode || !this.listNode.doc) {
            nodes = this.getDocument().getDocumentNode().children;
            for (i = nodes.length; i >= 0; i--) {
                if (nodes[i]instanceof ve.dm.InternalListNode) {
                    this.listNode = nodes[i];
                    break;
                }
            }
        }
        return this.listNode;
    }
    ;
    ve.dm.InternalList.prototype.getItemNodeCount = function() {
        return this.getListNode().children.length;
    }
    ;
    ve.dm.InternalList.prototype.getItemNode = function(index) {
        return this.getListNode().children[index];
    }
    ;
    ve.dm.InternalList.prototype.getNodeGroups = function() {
        return this.nodes;
    }
    ;
    ve.dm.InternalList.prototype.getNodeGroup = function(groupName) {
        return this.nodes[groupName];
    }
    ;
    ve.dm.InternalList.prototype.getUniqueListKey = function(groupName, oldListKey, prefix) {
        var group = this.getNodeGroup(groupName)
          , num = 0;
        if (group.uniqueListKeys[oldListKey] !== undefined) {
            return group.uniqueListKeys[oldListKey];
        }
        while (group.keyedNodes[prefix + num] || group.uniqueListKeysInUse[prefix + num]) {
            num++;
        }
        group.uniqueListKeys[oldListKey] = prefix + num;
        group.uniqueListKeysInUse[prefix + num] = !0;
        return prefix + num;
    }
    ;
    ve.dm.InternalList.prototype.getNextUniqueNumber = function() {
        return this.nextUniqueNumber++;
    }
    ;
    ve.dm.InternalList.prototype.convertToData = function(converter, doc) {
        var i, length, itemData, div, itemHtmlQueue = this.getItemHtmlQueue(), list = [];
        list.push({
            type: 'internalList'
        });
        for (i = 0,
        length = itemHtmlQueue.length; i < length; i++) {
            if (itemHtmlQueue[i] !== '') {
                div = doc.createElement('div');
                div.innerHTML = itemHtmlQueue[i];
                itemData = [].concat([{
                    type: 'internalItem'
                }], converter.getDataFromDomSubtree(div), [{
                    type: '/internalItem'
                }]);
                if (!converter.isFromClipboard()) {
                    itemData[0].attributes = {
                        originalHtml: itemHtmlQueue[i]
                    };
                }
                list = list.concat(itemData);
            } else {
                list = list.concat([{
                    type: 'internalItem'
                }, {
                    type: '/internalItem'
                }]);
            }
        }
        list.push({
            type: '/internalList'
        });
        this.itemHtmlQueue = [];
        return list;
    }
    ;
    ve.dm.InternalList.prototype.getItemInsertion = function(groupName, key, data) {
        var tx, itemData, index = this.getKeyIndex(groupName, key);
        if (index === undefined) {
            index = this.getItemNodeCount();
            this.keyIndexes[groupName + '/' + key] = index;
            itemData = [{
                type: 'internalItem'
            }].concat(data, [{
                type: '/internalItem'
            }]);
            tx = ve.dm.TransactionBuilder.static.newFromInsertion(this.getDocument(), this.getListNode().getRange().end, itemData);
        } else {
            tx = null;
        }
        return {
            transaction: tx,
            index: index
        };
    }
    ;
    ve.dm.InternalList.prototype.getIndexPosition = function(groupName, key) {
        return this.nodes[groupName].indexOrder.indexOf(key);
    }
    ;
    ve.dm.InternalList.prototype.getKeyIndex = function(groupName, key) {
        return this.keyIndexes[groupName + '/' + key];
    }
    ;
    ve.dm.InternalList.prototype.addNode = function(groupName, key, index, node) {
        var i, len, start, keyedNodes, group = this.nodes[groupName];
        if (group === undefined) {
            group = this.nodes[groupName] = {
                keyedNodes: {},
                firstNodes: [],
                indexOrder: [],
                uniqueListKeys: {},
                uniqueListKeysInUse: {}
            };
        }
        keyedNodes = group.keyedNodes[key];
        this.keys[index] = key;
        if (keyedNodes === undefined) {
            keyedNodes = group.keyedNodes[key] = [];
        }
        if (node.getDocument().buildingNodeTree) {
            keyedNodes.push(node);
            if (keyedNodes.length === 1) {
                group.firstNodes[index] = node;
            }
        } else {
            start = node.getRange().start;
            for (i = 0,
            len = keyedNodes.length; i < len; i++) {
                if (start < keyedNodes[i].getRange().start) {
                    break;
                }
            }
            keyedNodes.splice(i, 0, node);
            if (i === 0) {
                group.firstNodes[index] = node;
            }
        }
        if (group.indexOrder.indexOf(index) === -1) {
            group.indexOrder.push(index);
        }
        this.markGroupAsChanged(groupName);
    }
    ;
    ve.dm.InternalList.prototype.markGroupAsChanged = function(groupName) {
        if (this.groupsChanged.indexOf(groupName) === -1) {
            this.groupsChanged.push(groupName);
        }
    }
    ;
    ve.dm.InternalList.prototype.onTransact = function() {
        var i;
        if (this.groupsChanged.length > 0) {
            for (i = 0; i < this.groupsChanged.length; i++) {
                this.sortGroupIndexes(this.nodes[this.groupsChanged[i]]);
            }
            this.emit('update', this.groupsChanged);
            this.groupsChanged = [];
        }
    }
    ;
    ve.dm.InternalList.prototype.removeNode = function(groupName, key, index, node) {
        var i, len, j, keyedNodes, group = this.nodes[groupName];
        keyedNodes = group.keyedNodes[key];
        for (i = 0,
        len = keyedNodes.length; i < len; i++) {
            if (keyedNodes[i] === node) {
                keyedNodes.splice(i, 1);
                if (i === 0) {
                    group.firstNodes[index] = keyedNodes[0];
                }
                break;
            }
        }
        if (keyedNodes.length === 0) {
            delete group.keyedNodes[key];
            delete group.firstNodes[index];
            j = group.indexOrder.indexOf(index);
            group.indexOrder.splice(j, 1);
        }
        this.markGroupAsChanged(groupName);
    }
    ;
    ve.dm.InternalList.prototype.sortGroupIndexes = function(group) {
        group.indexOrder.sort(function(index1, index2) {
            return group.firstNodes[index1].getRange().start - group.firstNodes[index2].getRange().start;
        });
    }
    ;
    ve.dm.InternalList.prototype.clone = function(doc) {
        var clone = new this.constructor(doc || this.getDocument());
        clone.nextUniqueNumber = this.nextUniqueNumber;
        clone.itemHtmlQueue = ve.copy(this.itemHtmlQueue);
        return clone;
    }
    ;
    ve.dm.InternalList.prototype.merge = function(list, commonLength) {
        var i, k, key, listLen = list.getItemNodeCount(), nextIndex = this.getItemNodeCount(), newItemRanges = [], mapping = {};
        for (i = 0; i < commonLength; i++) {
            mapping[i] = i;
        }
        for (i = commonLength; i < listLen; i++) {
            key = undefined;
            for (k in list.keyIndexes) {
                if (list.keyIndexes[k] === i) {
                    key = k;
                    break;
                }
            }
            if (this.keyIndexes[key] !== undefined) {
                mapping[i] = this.keyIndexes[key];
            } else {
                mapping[i] = nextIndex;
                if (key !== undefined) {
                    this.keyIndexes[key] = nextIndex;
                }
                nextIndex++;
                newItemRanges.push(list.getItemNode(i).getOuterRange());
            }
        }
        return {
            mapping: mapping,
            newItemRanges: newItemRanges
        };
    }
    ;
    ve.dm.MetaItem = function VeDmMetaItem() {
        ve.dm.MetaItem.super.apply(this, arguments);
        OO.EventEmitter.call(this);
        this.list = null;
    }
    ;
    OO.inheritClass(ve.dm.MetaItem, ve.dm.LeafNode);
    OO.mixinClass(ve.dm.MetaItem, OO.EventEmitter);
    ve.dm.MetaItem.static.isContent = !1;
    ve.dm.MetaItem.static.isMetaData = !0;
    ve.dm.MetaItem.static.canSerializeAsContent = !0;
    ve.dm.MetaItem.static.group = 'misc';
    ve.dm.MetaItem.static.removable = !1;
    ve.dm.MetaItem.prototype.remove = function() {
        if (!this.list) {
            throw new Error('Cannot remove detached item');
        }
        this.list.removeMeta(this);
    }
    ;
    ve.dm.MetaItem.prototype.replaceWith = function(item) {
        this.list.replaceMeta(this, item);
    }
    ;
    ve.dm.MetaItem.prototype.getGroup = function() {
        return this.constructor.static.group;
    }
    ;
    ve.dm.MetaItem.prototype.attachToMetaList = function(list) {
        this.list = list;
    }
    ;
    ve.dm.MetaItem.prototype.detachFromMetaList = function(list) {
        if (this.list === list) {
            this.list = null;
        }
    }
    ;
    ve.dm.MetaItem.prototype.isAttached = function() {
        return this.list !== null;
    }
    ;
    ve.dm.MetaList = function VeDmMetaList(surface) {
        var items, metaList = this;
        OO.EventEmitter.call(this);
        this.surface = surface;
        this.document = surface.getDocument();
        this.items = items = [];
        this.document.connect(this, {
            nodeAttached: 'onNodeAttached',
            nodeDetached: 'onNodeDetached'
        });
        this.document.documentNode.traverse(function(node) {
            if (node instanceof ve.dm.MetaItem) {
                items.push(node);
                node.attachToMetaList(metaList);
            }
        });
    }
    ;
    OO.mixinClass(ve.dm.MetaList, OO.EventEmitter);
    ve.dm.MetaList.prototype.onNodeAttached = function(node) {
        var i, offsetPath = node.getOffsetPath();
        if (node instanceof ve.dm.MetaItem) {
            i = OO.binarySearch(this.items, function searchFunc(other) {
                return ve.compareTuples(offsetPath, other.getOffsetPath());
            }, true);
            this.items.splice(i, 0, node);
            node.attachToMetaList(this);
            this.emit('insert', node);
        }
    }
    ;
    ve.dm.MetaList.prototype.onNodeDetached = function(node) {
        var i;
        if (node instanceof ve.dm.MetaItem) {
            i = this.items.indexOf(node);
            if (i !== -1) {
                node.detachFromMetaList(this);
                this.items.splice(i, 1);
                this.emit('remove', node);
            }
        }
    }
    ;
    ve.dm.MetaList.prototype.indexOf = function(item, group) {
        var items = group ? this.getItemsInGroup(group) : this.items;
        return items.indexOf(item);
    }
    ;
    ve.dm.MetaList.prototype.getItemsInGroup = function(group) {
        return this.items.filter(function(item) {
            return item.getGroup() === group;
        });
    }
    ;
    ve.dm.MetaList.prototype.getAllItems = function() {
        return this.items.slice(0);
    }
    ;
    ve.dm.MetaList.prototype.insertMeta = function(meta, offset) {
        var closeMeta, tx;
        if (arguments[2] !== undefined) {
            throw new Error('Old "index" argument is no longer supported');
        }
        if (meta instanceof ve.dm.MetaItem) {
            meta = meta.getElement();
        }
        closeMeta = {
            type: '/' + meta.type
        };
        if (offset === undefined) {
            offset = this.document.getDocumentRange().end;
        }
        tx = ve.dm.TransactionBuilder.static.newFromInsertion(this.document, offset, [meta, closeMeta]);
        this.surface.change(tx);
    }
    ;
    ve.dm.MetaList.prototype.removeMeta = function(item) {
        var tx;
        tx = ve.dm.TransactionBuilder.static.newFromRemoval(this.document, item.getOuterRange(), true);
        this.surface.change(tx);
    }
    ;
    ve.dm.MetaList.prototype.replaceMeta = function(oldItem, meta) {
        var closeMeta, tx;
        if (meta instanceof ve.dm.MetaItem) {
            meta = meta.getElement();
        }
        closeMeta = {
            type: '/' + meta.type
        };
        tx = ve.dm.TransactionBuilder.static.newFromReplacement(this.document, oldItem.getOuterRange(), [meta, closeMeta], true);
        this.surface.change(tx);
    }
    ;
    ve.dm.TableMatrix = function VeDmTableMatrix(tableNode) {
        OO.EventEmitter.call(this);
        this.tableNode = tableNode;
        this.matrix = null;
        this.rowNodes = null;
    }
    ;
    OO.mixinClass(ve.dm.TableMatrix, OO.EventEmitter);
    ve.dm.TableMatrix.prototype.invalidate = function() {
        this.matrix = null;
        this.rowNodes = null;
        this.emit('structureChange');
    }
    ;
    ve.dm.TableMatrix.prototype.update = function() {
        var cellNode, cell, rowSpan, colSpan, i, j, r, c, matrix = [], rowNodes = [], iterator = this.tableNode.getIterator(), row = -1, col = -1;
        iterator.on('newRow', function(rowNode) {
            row++;
            col = -1;
            matrix[row] = matrix[row] || [];
            rowNodes.push(rowNode);
        });
        while ((cellNode = iterator.next()) !== undefined) {
            col++;
            while (matrix[row][col]) {
                col++;
            }
            if (!cellNode) {
                matrix[row][col] = null;
                continue;
            }
            cell = new ve.dm.TableMatrixCell(cellNode,row,col);
            matrix[row][col] = cell;
            rowSpan = cellNode.getRowspan();
            colSpan = cellNode.getColspan();
            if (rowSpan === 1 && colSpan === 1) {
                continue;
            }
            for (i = 0; i < rowSpan; i++) {
                for (j = 0; j < colSpan; j++) {
                    if (i === 0 && j === 0) {
                        continue;
                    }
                    r = row + i;
                    c = col + j;
                    matrix[r] = matrix[r] || [];
                    matrix[r][c] = new ve.dm.TableMatrixCell(cellNode,r,c,cell);
                }
            }
        }
        this.matrix = matrix;
        this.rowNodes = rowNodes;
    }
    ;
    ve.dm.TableMatrix.prototype.getCell = function(row, col) {
        var matrix = this.getMatrix();
        return matrix[row] ? matrix[row][col] : undefined;
    }
    ;
    ve.dm.TableMatrix.prototype.getColumn = function(col) {
        var cells, row, matrix = this.getMatrix();
        cells = [];
        for (row = 0; row < matrix.length; row++) {
            cells.push(matrix[row][col]);
        }
        return cells;
    }
    ;
    ve.dm.TableMatrix.prototype.getRow = function(row) {
        var matrix = this.getMatrix();
        return matrix[row];
    }
    ;
    ve.dm.TableMatrix.prototype.getRowNode = function(row) {
        var rowNodes = this.getRowNodes();
        return rowNodes[row];
    }
    ;
    ve.dm.TableMatrix.prototype.getMatrix = function() {
        if (!this.matrix) {
            this.update();
        }
        return this.matrix;
    }
    ;
    ve.dm.TableMatrix.prototype.getRowNodes = function() {
        if (!this.rowNodes) {
            this.update();
        }
        return this.rowNodes;
    }
    ;
    ve.dm.TableMatrix.prototype.getRowCount = function() {
        return this.getMatrix().length;
    }
    ;
    ve.dm.TableMatrix.prototype.getColCount = function(row) {
        var matrix = this.getMatrix();
        return matrix.length ? matrix[row].length : 0;
    }
    ;
    ve.dm.TableMatrix.prototype.getMaxColCount = function() {
        var row, colCount = 0;
        for (row = this.getRowCount() - 1; row >= 0; row--) {
            colCount = Math.max(colCount, this.getColCount(row));
        }
        return colCount;
    }
    ;
    ve.dm.TableMatrix.prototype.lookupCell = function(cellNode) {
        var row, col, cols, rowCells, matrix = this.getMatrix(), rowNodes = this.getRowNodes();
        row = rowNodes.indexOf(cellNode.getParent());
        if (row < 0) {
            return null;
        }
        rowCells = matrix[row];
        for (col = 0,
        cols = rowCells.length; col < cols; col++) {
            if (rowCells[col] && rowCells[col].node === cellNode) {
                return rowCells[col];
            }
        }
        return null;
    }
    ;
    ve.dm.TableMatrix.prototype.findClosestCell = function(cell) {
        var col, cols, rowCells, matrix = this.getMatrix();
        rowCells = matrix[cell.row];
        for (col = cell.col; col >= 0; col--) {
            if (!rowCells[col].isPlaceholder()) {
                return rowCells[col];
            }
        }
        for (col = cell.col + 1,
        cols = rowCells.length; col < cols; col++) {
            if (!rowCells[col].isPlaceholder()) {
                return rowCells[col];
            }
        }
        return null;
    }
    ;
    ve.dm.TableMatrixCell = function VeDmTableMatrixCell(node, row, col, owner) {
        this.node = node;
        this.row = row;
        this.col = col;
        this.key = row + '_' + col;
        this.owner = owner || this;
        this.data = null;
    }
    ;
    OO.initClass(ve.dm.TableMatrixCell);
    ve.dm.TableMatrixCell.static.sortDescending = function(a, b) {
        if (a.row !== b.row) {
            return b.row - a.row;
        }
        return b.col - a.col;
    }
    ;
    ve.dm.TableMatrixCell.prototype.isPlaceholder = function() {
        return this.owner !== this;
    }
    ;
    ve.dm.TableMatrixCell.prototype.getOwner = function() {
        return this.owner;
    }
    ;
    ve.dm.TableMatrixCell.prototype.equals = function(other) {
        return this.getOwner().key === other.getOwner().key;
    }
    ;
    ve.dm.TransactionProcessor = function VeDmTransactionProcessor(doc, transaction, isStaging) {
        this.document = doc;
        this.transaction = transaction;
        this.operations = transaction.getOperations();
        this.isStaging = isStaging;
        this.modificationQueue = [];
        this.rollbackQueue = [];
        this.eventQueue = [];
        this.cursor = 0;
        this.adjustment = 0;
        this.replaceRemoveLevel = 0;
        this.replaceInsertLevel = 0;
        this.replaceMinInsertLevel = 0;
        this.retainDepth = 0;
        this.balanced = !0;
    }
    ;
    ve.dm.TransactionProcessor.modifiers = {};
    ve.dm.TransactionProcessor.processors = {};
    ve.dm.TransactionProcessor.prototype.executeOperation = function(op) {
        if (Object.prototype.hasOwnProperty.call(ve.dm.TransactionProcessor.processors, op.type)) {
            ve.dm.TransactionProcessor.processors[op.type].call(this, op);
        } else {
            throw new Error('Invalid operation error. Operation type is not supported: ' + op.type);
        }
    }
    ;
    ve.dm.TransactionProcessor.prototype.process = function() {
        var i, completed;
        this.document.getDocumentNode();
        for (i = 0; i < this.operations.length; i++) {
            this.executeOperation(this.operations[i]);
        }
        if (!this.balanced) {
            throw new Error('Unbalanced set of replace operations found');
        }
        try {
            completed = !1;
            this.applyModifications();
            ve.dm.treeModifier.process(this.document, this.transaction);
            completed = !0;
        } finally {
            if (!completed) {
                if (this.treeModifier) {
                    this.treeModifier.undoLinearSplices();
                }
                this.rollbackModifications();
                this.document.rebuildTree();
            }
        }
        this.transaction.markAsApplied();
        this.emitQueuedEvents();
    }
    ;
    ve.dm.TransactionProcessor.prototype.queueModification = function(modification) {
        if (typeof ve.dm.TransactionProcessor.modifiers[modification.type] !== 'function') {
            throw new Error('Unrecognized modification type ' + modification.type);
        }
        this.modificationQueue.push(modification);
    }
    ;
    ve.dm.TransactionProcessor.prototype.queueUndoFunction = function(func) {
        this.rollbackQueue.push(func);
    }
    ;
    ve.dm.TransactionProcessor.prototype.applyModifications = function() {
        var i, len, modifier, modifications = this.modificationQueue;
        this.modificationQueue = [];
        for (i = 0,
        len = modifications.length; i < len; i++) {
            modifier = ve.dm.TransactionProcessor.modifiers[modifications[i].type];
            modifier.apply(this, modifications[i].args || []);
        }
    }
    ;
    ve.dm.TransactionProcessor.prototype.rollbackModifications = function() {
        var i, rollbacks = this.rollbackQueue;
        this.rollbackQueue = [];
        for (i = rollbacks.length - 1; i >= 0; i--) {
            rollbacks[i]();
        }
    }
    ;
    ve.dm.TransactionProcessor.prototype.queueEvent = function(node) {
        var args = Array.prototype.slice.call(arguments, 1);
        this.eventQueue.push({
            node: node,
            args: args.concat(this.transaction)
        });
    }
    ;
    ve.dm.TransactionProcessor.prototype.emitQueuedEvents = function() {
        var i, event, queue = this.eventQueue;
        function isDuplicate(otherEvent) {
            return otherEvent.node === event.node && otherEvent.args.every(function(arg, index) {
                return arg === event.args[index];
            });
        }
        this.eventQueue = [];
        for (i = 0; i < queue.length; i++) {
            event = queue[i];
            if (!queue.slice(0, i).some(isDuplicate)) {
                event.node.emit.apply(event.node, event.args);
            }
        }
    }
    ;
    ve.dm.TransactionProcessor.prototype.advanceCursor = function(increment) {
        this.cursor += increment;
    }
    ;
    ve.dm.TransactionProcessor.modifiers.splice = function(splices) {
        var i, s, lengthDiff = 0, data = this.document.data;
        this.queueUndoFunction(function() {
            var i, s;
            for (i = splices.length - 1; i >= 0; i--) {
                s = splices[i];
                if (s.removedData !== undefined) {
                    data.batchSplice(s.offset, s.insert.length, s.removedData);
                }
            }
        });
        for (i = 0; i < splices.length; i++) {
            s = splices[i];
            s.treeOffset = s.offset + this.adjustment;
            s.offset = s.treeOffset + lengthDiff;
            s.removedData = data.batchSplice(s.offset, s.removeLength, s.insert);
            lengthDiff += s.insert.length - s.removeLength;
        }
        this.adjustment += lengthDiff;
    }
    ;
    ve.dm.TransactionProcessor.modifiers.setAttribute = function(offset, key, value) {
        var item, oldValue, node, data = this.document.data;
        offset += this.adjustment;
        item = data.getData(offset);
        oldValue = item.attributes && item.attributes[key];
        data.setAttributeAtOffset(offset, key, value);
        this.queueUndoFunction(function() {
            data.setAttributeAtOffset(offset, key, oldValue);
        });
        node = this.document.getDocumentNode().getNodeFromOffset(offset + 1);
        this.queueEvent(node, 'attributeChange', key, oldValue, value);
        this.queueEvent(node, 'update', this.isStaging);
    }
    ;
    ve.dm.TransactionProcessor.processors.retain = function(op) {
        var i, type, retainedData;
        if (!this.balanced) {
            retainedData = this.document.getData(new ve.Range(this.cursor,this.cursor + op.length));
            for (i = 0; i < retainedData.length; i++) {
                type = retainedData[i].type;
                if (type !== undefined) {
                    this.retainDepth += type.charAt(0) === '/' ? -1 : 1;
                }
            }
        }
        this.advanceCursor(op.length);
    }
    ;
    ve.dm.TransactionProcessor.processors.attribute = function(op) {
        if (!this.document.data.isElementData(this.cursor)) {
            throw new Error('Invalid element error, cannot set attributes on non-element data');
        }
        this.queueModification({
            type: 'setAttribute',
            args: [this.cursor, op.key, op.to]
        });
    }
    ;
    ve.dm.TransactionProcessor.processors.replace = function(op) {
        var i, type;
        for (i = 0; i < op.remove.length; i++) {
            type = op.remove[i].type;
            if (type !== undefined) {
                if (type.charAt(0) === '/') {
                    this.replaceRemoveLevel--;
                } else {
                    this.replaceRemoveLevel++;
                }
            }
        }
        for (i = 0; i < op.insert.length; i++) {
            type = op.insert[i].type;
            if (type !== undefined) {
                if (type.charAt(0) === '/') {
                    this.replaceInsertLevel--;
                } else {
                    this.replaceInsertLevel++;
                }
            }
        }
        this.advanceCursor(op.remove.length);
        this.balanced = this.replaceRemoveLevel === 0 && this.replaceInsertLevel === 0 && this.retainDepth === 0;
    }
    ;
    ve.dm.Transaction = function VeDmTransaction(operations, authorId) {
        this.operations = operations || [];
        this.operations.forEach(function(op) {
            if (op.type && op.type.match(/meta/i)) {
                throw new Error('Metadata ops are no longer supported');
            }
        });
        this.applied = !1;
        this.authorId = authorId || null;
        this.isReversed = !1;
    }
    ;
    OO.initClass(ve.dm.Transaction);
    ve.dm.Transaction.static.reversers = {
        attribute: {
            from: 'to',
            to: 'from'
        },
        replace: {
            insert: 'remove',
            remove: 'insert'
        }
    };
    ve.dm.Transaction.static.deserialize = function(data) {
        function deminifyLinearData(data) {
            if (typeof data === 'string') {
                return data.split('');
            }
            return JSON.parse(JSON.stringify(data));
        }
        function deminify(op) {
            if (typeof op === 'number') {
                return {
                    type: 'retain',
                    length: op
                };
            }
            if (Array.isArray(op)) {
                return {
                    type: 'replace',
                    remove: deminifyLinearData(op[0]),
                    insert: deminifyLinearData(op[1])
                };
            }
            return JSON.parse(JSON.stringify(op));
        }
        if (Array.isArray(data)) {
            return new ve.dm.Transaction(data.map(deminify));
        } else {
            return new ve.dm.Transaction(data.o.map(deminify),data.a);
        }
    }
    ;
    ve.dm.Transaction.prototype.toJSON = function() {
        var operations;
        function isSingleCodePoint(x) {
            return typeof x === 'string' && x.length === 1;
        }
        function minifyLinearData(data) {
            if (data.every(isSingleCodePoint)) {
                return data.join('');
            }
            return data;
        }
        function minify(op) {
            if (op.type === 'retain') {
                return op.length;
            }
            if (op.type === 'replace' && !op.insertedDataOffset && (op.insertedDataLength === undefined || op.insertedDataLength === op.insert.length)) {
                return [minifyLinearData(op.remove), minifyLinearData(op.insert)];
            }
            return op;
        }
        operations = this.operations.map(minify);
        if (this.authorId !== null) {
            return {
                o: operations,
                a: this.authorId
            };
        } else {
            return operations;
        }
    }
    ;
    ve.dm.Transaction.prototype.serialize = ve.dm.Transaction.prototype.toJSON;
    ve.dm.Transaction.prototype.pushRetainOp = function(length) {
        this.operations.push({
            type: 'retain',
            length: length
        });
    }
    ;
    ve.dm.Transaction.prototype.pushReplaceOp = function(remove, insert, insertedDataOffset, insertedDataLength) {
        var op = {
            type: 'replace',
            remove: remove,
            insert: insert
        };
        if (insertedDataOffset !== undefined && insertedDataLength !== undefined) {
            op.insertedDataOffset = insertedDataOffset;
            op.insertedDataLength = insertedDataLength;
        }
        this.operations.push(op);
    }
    ;
    ve.dm.Transaction.prototype.pushAttributeOp = function(key, from, to) {
        this.operations.push({
            type: 'attribute',
            key: key,
            from: from,
            to: to
        });
    }
    ;
    ve.dm.Transaction.prototype.clone = function() {
        return new this.constructor(JSON.parse(JSON.stringify(this.operations)),this.authorId);
    }
    ;
    ve.dm.Transaction.prototype.reversed = function() {
        var i, len, op, newOp, reverse, prop, tx = new this.constructor();
        tx.isReversed = !this.isReversed;
        for (i = 0,
        len = this.operations.length; i < len; i++) {
            op = this.operations[i];
            newOp = ve.copy(op);
            reverse = this.constructor.static.reversers[op.type] || {};
            for (prop in reverse) {
                if (typeof reverse[prop] === 'string') {
                    newOp[prop] = op[reverse[prop]];
                } else {
                    newOp[prop] = reverse[prop][op[prop]];
                }
            }
            tx.operations.push(newOp);
        }
        tx.authorId = this.authorId;
        return tx;
    }
    ;
    ve.dm.Transaction.prototype.isNoOp = function() {
        if (this.operations.length === 0) {
            return true;
        }
        if (this.operations.length === 1) {
            return this.operations[0].type === 'retain';
        }
        return false;
    }
    ;
    ve.dm.Transaction.prototype.getOperations = function() {
        return this.operations;
    }
    ;
    ve.dm.Transaction.prototype.hasOperationWithType = function(type) {
        var i, len;
        for (i = 0,
        len = this.operations.length; i < len; i++) {
            if (this.operations[i].type === type) {
                return true;
            }
        }
        return false;
    }
    ;
    ve.dm.Transaction.prototype.hasContentDataOperations = function() {
        return this.hasOperationWithType('replace');
    }
    ;
    ve.dm.Transaction.prototype.hasElementAttributeOperations = function() {
        return this.hasOperationWithType('attribute');
    }
    ;
    ve.dm.Transaction.prototype.hasBeenApplied = function() {
        return this.applied;
    }
    ;
    ve.dm.Transaction.prototype.markAsApplied = function() {
        this.applied = !0;
    }
    ;
    ve.dm.Transaction.prototype.translateOffset = function(offset, excludeInsertion) {
        var i, op, insertLength, removeLength, retainLength, prevAdjustment, cursor = 0, adjustment = 0;
        for (i = 0; i < this.operations.length; i++) {
            op = this.operations[i];
            if (op.type === 'retain' || (op.type === 'replace' && op.insert.length === op.remove.length && op.insert.every(function(insert, j) {
                return ve.dm.ElementLinearData.static.compareElementsUnannotated(insert, op.remove[j]);
            }))) {
                retainLength = op.type === 'retain' ? op.length : op.remove.length;
                if (offset >= cursor && offset < cursor + retainLength) {
                    return offset + adjustment;
                }
                cursor += retainLength;
                continue;
            } else if (op.type === 'replace') {
                insertLength = op.insert.length;
                removeLength = op.remove.length;
                prevAdjustment = adjustment;
                adjustment += insertLength - removeLength;
                if (offset === cursor + removeLength) {
                    if (excludeInsertion && insertLength > removeLength) {
                        return offset + adjustment - insertLength + removeLength;
                    } else {
                        return offset + adjustment;
                    }
                } else if (offset === cursor) {
                    if (insertLength === 0) {
                        return cursor + removeLength + adjustment;
                    } else {
                        return cursor + prevAdjustment;
                    }
                } else if (offset > cursor && offset < cursor + removeLength) {
                    return cursor + removeLength + adjustment;
                }
                cursor += removeLength;
            }
        }
        return offset + adjustment;
    }
    ;
    ve.dm.Transaction.prototype.translateRange = function(range, excludeInsertion) {
        var start = this.translateOffset(range.start, !excludeInsertion)
          , end = this.translateOffset(range.end, excludeInsertion);
        return range.isBackwards() ? new ve.Range(end,start) : new ve.Range(start,end);
    }
    ;
    ve.dm.Transaction.prototype.translateRangeWithAuthor = function(range, authorId) {
        var backward = !this.authorId || !authorId || authorId < this.authorId
          , start = this.translateOffset(range.start, backward)
          , end = this.translateOffset(range.end, backward);
        return range.isBackwards() ? new ve.Range(end,start) : new ve.Range(start,end);
    }
    ;
    ve.dm.Transaction.prototype.getModifiedRange = function(doc, includeInternalList) {
        var i, len, op, start, end, internalListNode, docEndOffset = doc.data.getLength(), oldOffset = 0, offset = 0;
        if (!includeInternalList) {
            internalListNode = doc.getInternalList().getListNode();
            if (internalListNode) {
                docEndOffset = internalListNode.getOuterRange().start;
            }
        }
        opLoop: for (i = 0,
        len = this.operations.length; i < len; i++) {
            op = this.operations[i];
            switch (op.type) {
            case 'retain':
                if (oldOffset + op.length > docEndOffset) {
                    break opLoop;
                }
                offset += op.length;
                oldOffset += op.length;
                break;
            case 'attribute':
                if (start === undefined) {
                    start = offset;
                }
                end = offset + 1;
                break;
            default:
                if (start === undefined) {
                    start = offset + (op.insertedDataOffset || 0);
                }
                if (op.type === 'replace') {
                    offset += op.insert.length;
                    oldOffset += op.remove.length;
                }
                if (op.insertedDataLength) {
                    end = start + op.insertedDataLength;
                } else {
                    end = offset;
                }
                break;
            }
        }
        if (start === undefined || end === undefined) {
            return null;
        }
        return new ve.Range(start,end);
    }
    ;
    ve.dm.Transaction.prototype.getActiveRangeAndLengthDiff = function() {
        var i, len, op, start, end, startOpIndex, endOpIndex, active, offset = 0, diff = 0;
        for (i = 0,
        len = this.operations.length; i < len; i++) {
            op = this.operations[i];
            active = op.type !== 'retain';
            if (active && start === undefined) {
                start = offset;
                startOpIndex = i;
            }
            if (op.type === 'retain') {
                offset += op.length;
            } else if (op.type === 'replace') {
                offset += op.remove.length;
                diff += op.insert.length - op.remove.length;
            }
            if (op.type === 'attribute' || op.type === 'replaceMetadata') {
                end = offset + 1;
                endOpIndex = i + 1;
            } else if (active) {
                end = offset;
                endOpIndex = i + 1;
            }
        }
        return {
            start: start,
            end: end,
            startOpIndex: startOpIndex,
            endOpIndex: endOpIndex,
            diff: diff
        };
    }
    ;
    ve.dm.Transaction.prototype.adjustRetain = function(place, diff) {
        var start = place === 'start'
          , ops = this.operations
          , i = start ? 0 : ops.length - 1;
        if (diff === 0) {
            return;
        }
        if (!start && ops[i] && ops[i].type === 'retainMetadata') {
            i = ops.length - 2;
        }
        if (ops[i] && ops[i].type === 'retain') {
            ops[i].length += diff;
            if (ops[i].length < 0) {
                throw new Error('Negative retain length');
            } else if (ops[i].length === 0) {
                ops.splice(i, 1);
            }
            return;
        }
        if (diff < 0) {
            throw new Error('Negative retain length');
        }
        ops.splice(start ? 0 : ops.length, 0, {
            type: 'retain',
            length: diff
        });
    }
    ;
    ve.dm.Transaction.prototype.trySplit = function(offset) {
        var i, iLen, op, opLen, n = 0;
        for (i = 0,
        iLen = this.operations.length; i < iLen; i++) {
            op = this.operations[i];
            opLen = (op.type === 'retain' ? op.length : op.type === 'replace' ? op.remove.length : 0);
            if (n + opLen <= offset) {
                n += opLen;
                continue;
            }
            if (n === offset) {
                return i;
            }
            if (op.type !== 'retain') {
                throw new Error('Cannot split operation of type ' + op.type);
            }
            op.length -= n + opLen - offset;
            this.operations.splice(i + 1, 0, {
                type: 'retain',
                length: n + opLen - offset
            });
            return i + 1;
        }
        if (n === offset) {
            return iLen + 1;
        }
        throw new Error('Offset beyond end of transaction');
    }
    ;
    ve.dm.Transaction.prototype.tryUnsplit = function(index) {
        var op1 = this.operations[index - 1]
          , op2 = this.operations[index];
        if (!op1 || !op2 || op1.type !== op2.type) {
            return;
        }
        if (op1.type === 'retain') {
            op1.length += op2.length;
            this.operations.splice(index, 1);
        } else if (op1.type === 'replace') {
            ve.batchSplice(op1.remove, op1.remove.length, 0, op2.remove);
            ve.batchSplice(op1.insert, op1.insert.length, 0, op2.insert);
            this.operations.splice(index, 1);
        }
    }
    ;
    ve.dm.Transaction.prototype.insertOperations = function(offset, operations) {
        var opIndex;
        if (operations.length === 0) {
            return;
        }
        opIndex = this.trySplit(offset);
        ve.batchSplice(this.operations, opIndex, 0, ve.copy(operations));
        this.tryUnsplit(opIndex + operations.length);
        this.tryUnsplit(opIndex);
    }
    ;
    ve.dm.TransactionBuilder = function VeDmTransactionBuilder() {
        this.transaction = new ve.dm.Transaction();
    }
    ;
    OO.initClass(ve.dm.TransactionBuilder);
    ve.dm.TransactionBuilder.static.newFromReplacement = function(doc, range, data, removeMetadata) {
        var endOffset, txBuilder = new ve.dm.TransactionBuilder();
        endOffset = txBuilder.pushRemoval(doc, 0, range, removeMetadata);
        endOffset = txBuilder.pushInsertion(doc, endOffset, endOffset, data);
        txBuilder.pushFinalRetain(doc, endOffset);
        return txBuilder.getTransaction();
    }
    ;
    ve.dm.TransactionBuilder.static.newFromInsertion = function(doc, offset, data) {
        var txBuilder = new ve.dm.TransactionBuilder()
          , endOffset = txBuilder.pushInsertion(doc, 0, offset, data);
        txBuilder.pushFinalRetain(doc, endOffset);
        return txBuilder.getTransaction();
    }
    ;
    ve.dm.TransactionBuilder.static.newFromRemoval = function(doc, range, removeMetadata) {
        var txBuilder = new ve.dm.TransactionBuilder()
          , endOffset = txBuilder.pushRemoval(doc, 0, range, removeMetadata);
        if (range.start === 0 && range.end >= doc.getDocumentRange().end) {
            endOffset = txBuilder.pushInsertion(doc, endOffset, endOffset, [{
                type: 'paragraph'
            }, {
                type: '/paragraph'
            }]);
        }
        txBuilder.pushFinalRetain(doc, endOffset);
        return txBuilder.getTransaction();
    }
    ;
    ve.dm.TransactionBuilder.static.newFromDocumentInsertion = function(doc, offset, newDoc, newDocRange) {
        var i, len, listMerge, data, listData, linearData, oldEndOffset, newEndOffset, txBuilder, insertion, spliceItemRange, spliceListNodeRange, listNode = doc.internalList.getListNode(), listNodeRange = listNode.getRange(), newListNode = newDoc.internalList.getListNode(), newListNodeRange = newListNode.getRange(), newListNodeOuterRange = newListNode.getOuterRange();
        if (newDocRange) {
            data = new ve.dm.ElementLinearData(doc.getStore(),newDoc.getData(newDocRange, true));
        } else {
            data = new ve.dm.ElementLinearData(doc.getStore(),newDoc.getData(new ve.Range(0,newListNodeOuterRange.start), true).concat(newDoc.getData(new ve.Range(newListNodeOuterRange.end,newDoc.data.getLength()), true)));
        }
        doc.getStore().merge(newDoc.getStore());
        listMerge = doc.internalList.merge(newDoc.internalList, newDoc.origInternalListLength || 0);
        data.remapInternalListIndexes(listMerge.mapping, doc.internalList);
        if (newDoc.origInternalListLength !== null) {
            if (newDoc.origInternalListLength > 0) {
                oldEndOffset = doc.internalList.getItemNode(newDoc.origInternalListLength - 1).getOuterRange().end;
                newEndOffset = newDoc.internalList.getItemNode(newDoc.origInternalListLength - 1).getOuterRange().end;
            } else {
                oldEndOffset = listNodeRange.start;
                newEndOffset = newListNodeRange.start;
            }
            linearData = new ve.dm.ElementLinearData(doc.getStore(),newDoc.getData(new ve.Range(newListNodeRange.start,newEndOffset), true));
            listData = linearData.data.concat(doc.getData(new ve.Range(oldEndOffset,listNodeRange.end), true));
        } else {
            listData = doc.getData(listNodeRange, true);
        }
        for (i = 0,
        len = listMerge.newItemRanges.length; i < len; i++) {
            linearData = new ve.dm.ElementLinearData(doc.getStore(),newDoc.getData(listMerge.newItemRanges[i], true));
            listData = listData.concat(linearData.data);
        }
        txBuilder = new ve.dm.TransactionBuilder();
        if (offset <= listNodeRange.start) {
            insertion = doc.fixupInsertion(data.data, offset);
            txBuilder.pushRetain(insertion.offset);
            txBuilder.pushReplacement(doc, insertion.offset, insertion.remove, insertion.data, true);
            txBuilder.pushRetain(listNodeRange.start - (insertion.offset + insertion.remove));
            txBuilder.pushReplacement(doc, listNodeRange.start, listNodeRange.end - listNodeRange.start, listData, true);
            txBuilder.pushFinalRetain(doc, listNodeRange.end);
        } else if (offset >= listNodeRange.end) {
            insertion = doc.fixupInsertion(data.data, offset);
            txBuilder.pushRetain(listNodeRange.start);
            txBuilder.pushReplacement(doc, listNodeRange.start, listNodeRange.end - listNodeRange.start, listData, true);
            txBuilder.pushRetain(insertion.offset - listNodeRange.end);
            txBuilder.pushReplacement(doc, insertion.offset, insertion.remove, insertion.data, true);
            txBuilder.pushFinalRetain(doc, insertion.offset + insertion.remove);
        } else if (offset >= listNodeRange.start && offset <= listNodeRange.end) {
            i = 0;
            while ((spliceItemRange = doc.internalList.getItemNode(i).getRange()) && offset > spliceItemRange.end) {
                i++;
            }
            if (newDoc.origInternalListLength !== null) {
                spliceItemRange = newDoc.internalList.getItemNode(i).getRange();
                spliceListNodeRange = newListNodeRange;
            } else {
                spliceListNodeRange = listNodeRange;
            }
            ve.batchSplice(listData, spliceItemRange.start - spliceListNodeRange.start, spliceItemRange.end - spliceItemRange.start, data.data);
            txBuilder.pushRetain(listNodeRange.start);
            txBuilder.pushReplacement(doc, listNodeRange.start, listNodeRange.end - listNodeRange.start, listData, true);
            txBuilder.pushFinalRetain(doc, listNodeRange.end);
        }
        return txBuilder.getTransaction();
    }
    ;
    ve.dm.TransactionBuilder.static.newFromAttributeChanges = function(doc, offset, attr) {
        var txBuilder = new ve.dm.TransactionBuilder()
          , data = doc.getData();
        if (data[offset].type === undefined) {
            throw new Error('Cannot set attributes to non-element data');
        }
        if (data[offset].type.charAt(0) === '/') {
            throw new Error('Cannot set attributes on closing element');
        }
        txBuilder.pushRetain(offset);
        txBuilder.pushAttributeChanges(attr, data[offset].attributes || {});
        txBuilder.pushFinalRetain(doc, offset);
        return txBuilder.getTransaction();
    }
    ;
    ve.dm.TransactionBuilder.static.newFromAnnotation = function(doc, range, method, annotation) {
        var i, iLen, covered, arrayIndex, annotatable, txBuilder, j, jLen, item, anns, clear = method === 'clear', run = null, runs = [], data = doc.data, hash = doc.getStore().hash(annotation), insideContentNode = !1, ignoreChildrenDepth = 0;
        function findAnnotation() {
            return data.getAnnotationHashesFromOffset(i).lastIndexOf(hash);
        }
        function startRun() {
            run = {
                start: i,
                end: null,
                data: null,
                spliceAt: clear ? findAnnotation() : null
            };
        }
        function endRun() {
            run.end = i;
            if (!clear) {
                run.spliceAt = data.getCommonAnnotationArrayLength(new ve.Range(run.start,i));
            }
            run.data = doc.getData(new ve.Range(run.start,run.end));
            for (j = 0,
            jLen = run.data.length; j < jLen; j++) {
                item = ve.copy(run.data[j]);
                anns = new ve.dm.AnnotationSet(doc.getStore(),ve.dm.ElementLinearData.static.getAnnotationHashesFromItem(item));
                if (clear) {
                    anns.remove(annotation);
                } else {
                    anns.add(annotation, run.spliceAt);
                }
                item = ve.dm.ElementLinearData.static.replaceAnnotationHashesForItem(item, anns.getHashes());
                run.data[j] = item;
            }
            runs.push(run);
            run = null;
        }
        for (i = range.start; i < range.end; i++) {
            if (data.isElementData(i) && ve.dm.nodeFactory.shouldIgnoreChildren(data.getType(i))) {
                ignoreChildrenDepth += data.isOpenElementData(i) ? 1 : -1;
            }
            annotatable = !ignoreChildrenDepth && data.canTakeAnnotationAtOffset(i, annotation);
            if (!annotatable || (insideContentNode && !data.isCloseElementData(i))) {
                if (run) {
                    endRun();
                }
                continue;
            }
            if (data.isCloseElementData(i)) {
                insideContentNode = !1;
                continue;
            }
            if (insideContentNode) {
                continue;
            }
            if (data.isElementData(i)) {
                insideContentNode = !0;
            }
            if (!clear) {
                covered = data.getAnnotationsFromOffset(i).containsComparable(annotation);
            } else {
                arrayIndex = findAnnotation();
            }
            if (run && ((clear && arrayIndex !== run.spliceAt) || (!clear && covered))) {
                endRun();
            }
            if (!run && ((clear && arrayIndex > -1) || (!clear && !covered))) {
                startRun();
            }
        }
        if (run) {
            endRun();
        }
        txBuilder = new ve.dm.TransactionBuilder();
        for (i = 0,
        iLen = runs.length; i < iLen; i++) {
            run = runs[i];
            txBuilder.pushRetain(run.start - (i > 0 ? runs[i - 1].end : 0));
            txBuilder.pushReplacement(doc, run.start, run.end - run.start, run.data, false);
        }
        txBuilder.pushFinalRetain(doc, runs.length > 0 ? runs[runs.length - 1].end : 0);
        return txBuilder.getTransaction();
    }
    ;
    ve.dm.TransactionBuilder.static.newFromContentBranchConversion = function(doc, range, type, attr) {
        var i, selected, branch, branchOuterRange, txBuilder = new ve.dm.TransactionBuilder(), selection = doc.selectNodes(range, 'leaves'), opening = {
            type: type
        }, closing = {
            type: '/' + type
        }, previousBranch, previousBranchOuterRange;
        if (ve.isPlainObject(attr)) {
            opening.attributes = attr;
        } else {
            attr = {};
        }
        for (i = 0; i < selection.length; i++) {
            selected = selection[i];
            branch = selected.node.isContent() ? selected.node.getParent() : selected.node;
            if (branch.canContainContent()) {
                if (branch.getType() === type && ve.compare(attr, branch.getAttributes(), true)) {
                    continue;
                }
                branchOuterRange = branch.getOuterRange();
                if (branch === previousBranch) {
                    continue;
                }
                txBuilder.pushRetain(branchOuterRange.start - (previousBranch ? previousBranchOuterRange.end : 0));
                if (branch.getType() === type) {
                    txBuilder.pushAttributeChanges(attr, branch.getAttributes());
                    txBuilder.pushRetain(branch.getOuterLength());
                } else {
                    txBuilder.pushReplacement(doc, branchOuterRange.start, 1, [ve.copy(opening)]);
                    txBuilder.pushRetain(branch.getLength());
                    txBuilder.pushReplacement(doc, branchOuterRange.end - 1, 1, [ve.copy(closing)]);
                }
                previousBranch = branch;
                previousBranchOuterRange = branchOuterRange;
            }
        }
        txBuilder.pushFinalRetain(doc, previousBranch ? previousBranchOuterRange.end : 0);
        return txBuilder.getTransaction();
    }
    ;
    ve.dm.TransactionBuilder.static.newFromWrap = function(doc, range, unwrapOuter, wrapOuter, unwrapEach, wrapEach) {
        var i, startOffset, closingUnwrapEach, closingWrapEach, ptr, txBuilder = new ve.dm.TransactionBuilder(), depth = 0;
        function match(direction, offset, matchList, matchName) {
            var start, stop, step, i, item;
            if (direction === 'forwards') {
                start = 0;
                stop = matchList.length;
                step = 1;
                offset--;
            } else {
                start = matchList.length - 1;
                stop = -1;
                step = -1;
            }
            for (i = start; i !== stop; i += step) {
                while (true) {
                    offset += step;
                    item = doc.data.data[offset];
                    if (!(ve.dm.LinearData.static.isElementData(item) && ve.dm.nodeFactory.isMetaData(ve.dm.LinearData.static.getType(item)))) {
                        break;
                    }
                }
                if (!item || item.type !== matchList[i].type) {
                    throw new Error('Unmatched item ' + matchList[i].type + ' in ' + matchName + ' (found ' + (item && item.type) + ')');
                }
            }
            if (direction === 'forwards') {
                offset++;
            }
            return offset;
        }
        function closingArray(openings) {
            var i, closings = [], len = openings.length;
            for (i = 0; i < len; i++) {
                closings[closings.length] = {
                    type: '/' + openings[len - i - 1].type
                };
            }
            return closings;
        }
        closingUnwrapEach = closingArray(unwrapEach);
        closingWrapEach = closingArray(wrapEach);
        ptr = match('backwards', range.start, unwrapOuter, 'unwrapOuter');
        txBuilder.pushRetain(ptr);
        txBuilder.pushReplacement(doc, ptr, range.start - ptr, ve.copy(wrapOuter));
        ptr = range.start;
        if (wrapEach.length === 0 && unwrapEach.length === 0) {
            txBuilder.pushRetain(range.end - range.start);
            ptr = range.end;
        } else {
            for (i = range.start; i < range.end; i++) {
                if (!doc.data.isElementData(i)) {
                    continue;
                }
                if (doc.data.isOpenElementData(i)) {
                    depth++;
                    if (depth !== 1 || ve.dm.nodeFactory.isMetaData(ve.dm.LinearData.static.getType(doc.data.data[i]))) {
                        continue;
                    }
                    txBuilder.pushRetain(i - ptr);
                    ptr = match('forwards', i, unwrapEach, 'unwrapEach');
                    txBuilder.pushReplacement(doc, i, ptr - i, ve.copy(wrapEach));
                    startOffset = ptr;
                    continue;
                }
                depth--;
                if (depth !== 0 || ve.dm.nodeFactory.isMetaData(ve.dm.LinearData.static.getType(doc.data.data[i]))) {
                    continue;
                }
                ptr = match('backwards', i + 1, closingUnwrapEach, 'closingUnwrapEach');
                txBuilder.pushRetain(ptr - startOffset);
                txBuilder.pushReplacement(doc, ptr, i + 1 - ptr, ve.copy(closingWrapEach));
                ptr = i + 1;
            }
        }
        txBuilder.pushRetain(range.end - ptr);
        ptr = match('forwards', range.end, closingArray(unwrapOuter), 'unwrapOuter');
        txBuilder.pushReplacement(doc, range.end, ptr - range.end, closingArray(wrapOuter));
        txBuilder.pushFinalRetain(doc, ptr);
        return txBuilder.getTransaction();
    }
    ;
    ve.dm.TransactionBuilder.prototype.getTransaction = function() {
        return this.transaction;
    }
    ;
    ve.dm.TransactionBuilder.prototype.pushFinalRetain = function(doc, offset) {
        if (offset < doc.data.getLength()) {
            this.pushRetain(doc.data.getLength() - offset);
        }
    }
    ;
    ve.dm.TransactionBuilder.prototype.pushRetain = function(length) {
        var end;
        if (length < 0) {
            throw new Error('Invalid retain length, cannot retain backwards:' + length);
        }
        if (length) {
            end = this.transaction.operations.length - 1;
            if (this.transaction.operations.length && this.transaction.operations[end].type === 'retain') {
                this.transaction.operations[end].length += length;
            } else {
                this.transaction.pushRetainOp(length);
            }
        }
    }
    ;
    ve.dm.TransactionBuilder.prototype.addSafeRemoveOps = function(doc, removeStart, removeEnd, removeMetadata) {
        var i, queuedRetain, retainStart = removeStart, undeletableStackDepth = 0;
        for (i = removeStart; i < removeEnd; i++) {
            if (doc.data.isElementData(i) && !ve.dm.nodeFactory.isNodeDeletable(doc.data.getType(i))) {
                if (!doc.data.isCloseElementData(i)) {
                    if (undeletableStackDepth === 0) {
                        if (queuedRetain) {
                            this.pushRetain(queuedRetain);
                        }
                        this.pushReplacement(doc, removeStart, i - removeStart, [], removeMetadata);
                        retainStart = i;
                    }
                    undeletableStackDepth++;
                } else {
                    undeletableStackDepth--;
                    if (undeletableStackDepth === 0) {
                        queuedRetain = i + 1 - retainStart;
                        removeStart = i + 1;
                    }
                }
            }
        }
        if (removeEnd - removeStart) {
            if (queuedRetain) {
                this.pushRetain(queuedRetain);
            }
            this.pushReplacement(doc, removeStart, removeEnd - removeStart, [], removeMetadata);
            retainStart = removeEnd;
        }
        return retainStart;
    }
    ;
    ve.dm.TransactionBuilder.prototype.pushReplaceInternal = function(remove, insert, insertedDataOffset, insertedDataLength) {
        if (remove.length === 0 && insert.length === 0) {
            return;
        }
        this.transaction.pushReplaceOp(remove, insert, insertedDataOffset, insertedDataLength);
    }
    ;
    ve.dm.TransactionBuilder.prototype.pushReplacement = function(doc, offset, removeLength, insert, removeMetadata, insertedDataOffset, insertedDataLength) {
        var op, lastOp, remove, collapse;
        remove = doc.getData(new ve.Range(offset,offset + removeLength));
        collapse = removeMetadata ? [] : remove.filter(function(item) {
            var type = ve.dm.LinearData.static.isElementData(item) && ve.dm.LinearData.static.getType(item);
            return type && ve.dm.nodeFactory.isMetaData(type) && !ve.dm.nodeFactory.isRemovableMetaData(type);
        });
        if (removeLength === collapse.length && insert.length === 0) {
            return;
        }
        if (collapse.length > 0) {
            this.pushMeta(doc, offset, collapse);
        }
        lastOp = this.transaction.operations[this.transaction.operations.length - 1];
        if (lastOp && lastOp.type === 'replace' && !lastOp.insertedDataOffset && !insertedDataOffset) {
            this.transaction.operations.pop();
            remove = lastOp.remove.concat(remove);
            insert = lastOp.insert.concat(insert);
        }
        op = {
            type: 'replace',
            remove: remove,
            insert: insert
        };
        if (insertedDataOffset !== undefined) {
            op.insertedDataOffset = insertedDataOffset;
        }
        if (insertedDataLength !== undefined) {
            op.insertedDataLength = insertedDataLength;
        }
        this.transaction.operations.push(op);
    }
    ;
    ve.dm.TransactionBuilder.prototype.pushReplaceElementAttribute = function(key, from, to) {
        this.transaction.pushAttributeOp(key, from, to);
    }
    ;
    ve.dm.TransactionBuilder.prototype.pushAttributeChanges = function(changes, oldAttrs) {
        var key;
        for (key in changes) {
            if (oldAttrs[key] !== changes[key]) {
                this.pushReplaceElementAttribute(key, ve.copy(oldAttrs[key]), ve.copy(changes[key]));
            }
        }
    }
    ;
    ve.dm.TransactionBuilder.prototype.pushInsertion = function(doc, currentOffset, insertOffset, data) {
        var insertion = doc.fixupInsertion(data, insertOffset);
        this.pushRetain(insertion.offset - currentOffset);
        this.pushReplacement(doc, insertion.offset, insertion.remove, insertion.data, false, insertion.insertedDataOffset, insertion.insertedDataLength);
        return insertion.offset + insertion.remove;
    }
    ;
    ve.dm.TransactionBuilder.prototype.pushRemoval = function(doc, currentOffset, range, removeMetadata) {
        var i, selection, first, last, nodeStart, nodeEnd, offset = currentOffset, removeStart = null, removeEnd = null;
        if (range.isCollapsed()) {
            this.pushRetain(range.start - currentOffset);
            return range.start;
        }
        selection = doc.selectNodes(range, 'covered');
        if (selection.length === 0) {
            throw new Error('Invalid range, cannot remove from ' + range.start + ' to ' + range.end);
        }
        first = selection[0];
        last = selection[selection.length - 1];
        if (first.node.canBeMergedWith(last.node)) {
            if (!first.range && !last.range) {
                removeStart = first.nodeOuterRange.start;
                removeEnd = last.nodeOuterRange.end;
            } else {
                removeStart = (first.range || (first.node.isContent() ? first.nodeOuterRange : first.nodeRange)).start;
                removeEnd = (last.range || (last.node.isContent() ? last.nodeOuterRange : last.nodeRange)).end;
            }
            this.pushRetain(removeStart - currentOffset);
            removeEnd = this.addSafeRemoveOps(doc, removeStart, removeEnd, removeMetadata);
            return removeEnd;
        }
        for (i = 0; i < selection.length; i++) {
            if (!selection[i].range) {
                nodeStart = selection[i].nodeOuterRange.start;
                nodeEnd = selection[i].nodeOuterRange.end;
            } else {
                nodeStart = selection[i].range.start;
                nodeEnd = selection[i].range.end;
            }
            if (removeEnd === null) {
                removeStart = nodeStart;
                removeEnd = nodeEnd;
            } else if (removeEnd === nodeStart) {
                removeEnd = nodeEnd;
            } else {
                this.pushRetain(removeStart - offset);
                offset = this.addSafeRemoveOps(doc, removeStart, removeEnd, removeMetadata);
                removeStart = nodeStart;
                removeEnd = nodeEnd;
            }
        }
        if (removeEnd !== null) {
            this.pushRetain(removeStart - offset);
            offset = this.addSafeRemoveOps(doc, removeStart, removeEnd, removeMetadata);
        }
        return offset;
    }
    ;
    ve.dm.TransactionBuilder.prototype.pushMeta = function(doc, offset, metaItems) {
        var i, op, items, j, type, position = null, ops = this.transaction.operations, relDepth = 0;
        if (ops.length === 0) {
            ops.push({
                type: 'replace',
                remove: [],
                insert: metaItems
            });
            return;
        }
        position = {
            opIndex: ops.length - 1,
            itemIndex: ops[ops.length - 1].length
        };
        findPositionLoop: for (i = ops.length - 1; i >= 0; i--) {
            op = ops[i];
            if (op.type === 'replace') {
                items = op.insert;
                offset -= op.remove.length;
            } else if (op.type === 'retain') {
                items = doc.getData(new ve.Range(offset - op.length,offset));
                offset -= op.length;
            } else {
                continue;
            }
            for (j = items.length - 1; j >= 0; j--) {
                type = items[j].type;
                if (!type || typeof type !== 'string') {
                    continue;
                }
                if (type.charAt(0) === '/') {
                    relDepth++;
                    continue;
                }
                relDepth--;
                if (relDepth >= 0) {
                    continue;
                }
                if (!ve.dm.nodeFactory.canNodeContainContent(type) && !ve.dm.nodeFactory.getChildNodeTypes(type)) {
                    break findPositionLoop;
                }
                position = {
                    opIndex: i,
                    itemIndex: j
                };
                relDepth = 0;
            }
        }
        op = ops[position.opIndex];
        if (op.type === 'replace') {
            ve.batchSplice(op.insert, position.itemIndex, 0, metaItems);
            return;
        }
        if (position.itemIndex > 0) {
            ops.splice(position.opIndex, 0, {
                type: 'retain',
                length: position.itemIndex
            });
            position.opIndex++;
        }
        ops.splice(position.opIndex, 0, {
            type: 'replace',
            remove: [],
            insert: metaItems
        });
        op.length -= position.itemIndex;
        if (op.length === 0) {
            ops.splice(position.opIndex + 1, 1);
        }
    }
    ;
    ve.dm.Change = function VeDmChange(start, transactions, stores, selections) {
        var change = this;
        this.start = start || 0;
        this.transactions = transactions || [];
        this.store = new ve.dm.HashValueStore();
        this.storeLengthAtTransaction = [];
        if (stores) {
            stores.forEach(function(store) {
                change.store.merge(store);
                change.storeLengthAtTransaction.push(change.store.getLength());
            });
        }
        this.selections = selections || {};
    }
    ;
    ve.dm.Change.static = {};
    ve.dm.Change.static.deserialize = function(data, preserveStoreValues, unsafe) {
        var authorId, deserializeStore, i, iLen, txSerialized, insertion, tx, prevInfo, hasOwn = Object.prototype.hasOwnProperty, getTransactionInfo = this.getTransactionInfo, deserializeValue = this.deserializeValue, selections = {}, transactions = [], stores = data.stores || data.transactions.map(function() {
            return null;
        });
        function annotate(items, annotations) {
            var i, iLen;
            if (!annotations || !annotations.length) {
                return;
            }
            for (i = 0,
            iLen = items.length; i < iLen; i++) {
                items[i] = [items[i], annotations.slice()];
            }
        }
        for (authorId in data.selections) {
            selections[authorId] = ve.dm.Selection.static.newFromJSON(data.selections[authorId]);
        }
        deserializeStore = ve.dm.HashValueStore.static.deserialize.bind(null, preserveStoreValues ? function noop(x) {
            return x;
        }
        : function(x) {
            return deserializeValue(x, unsafe);
        }
        );
        for (i = 0,
        iLen = data.transactions.length; i < iLen; i++) {
            txSerialized = data.transactions[i];
            if (typeof txSerialized === 'string') {
                insertion = txSerialized.split('');
                annotate(insertion, prevInfo.uniformInsert && prevInfo.uniformInsert.annotations);
                tx = new ve.dm.Transaction([{
                    type: 'retain',
                    length: prevInfo.end
                }, {
                    type: 'replace',
                    remove: [],
                    insert: insertion
                }, {
                    type: 'retain',
                    length: prevInfo.docLength - prevInfo.end
                }],prevInfo.authorId);
                if (tx.operations[2].length === 0) {
                    tx.operations.pop();
                }
            } else {
                tx = ve.dm.Transaction.static.deserialize(txSerialized);
                if (prevInfo && !hasOwn.call(txSerialized, 'authorId')) {
                    tx.authorId = prevInfo.authorId;
                }
            }
            transactions.push(tx);
            prevInfo = getTransactionInfo(tx);
        }
        return new ve.dm.Change(data.start,transactions,stores.map(deserializeStore),selections);
    }
    ;
    ve.dm.Change.static.unsafeDeserialize = function(data) {
        return this.deserialize(data, false, true);
    }
    ;
    ve.dm.Change.static.serializeValue = function(value) {
        if (value instanceof ve.dm.Annotation) {
            return {
                type: 'annotation',
                value: value.element
            };
        } else if (Array.isArray(value) && value[0]instanceof Node) {
            return {
                type: 'domNodes',
                value: value.map(ve.getNodeHtml).join('')
            };
        } else {
            return {
                type: 'plain',
                value: value
            };
        }
    }
    ;
    ve.dm.Change.static.deserializeValue = function(serialized, unsafe) {
        if (serialized.type === 'annotation') {
            return ve.dm.annotationFactory.createFromElement(serialized.value);
        } else if (serialized.type === 'domNodes') {
            if (unsafe) {
                return $.parseHTML(serialized.value, undefined, true);
            } else {
                return Array.prototype.slice.call(ve.sanitizeHtml(serialized.value));
            }
        } else if (serialized.type === 'plain') {
            return serialized.value;
        } else {
            throw new Error('Unrecognized type: ' + serialized.type);
        }
    }
    ;
    ve.dm.Change.static.rebaseTransactions = function(transactionA, transactionB) {
        var infoA, infoB;
        transactionA = transactionA.clone();
        transactionB = transactionB.clone();
        infoA = transactionA.getActiveRangeAndLengthDiff();
        infoB = transactionB.getActiveRangeAndLengthDiff();
        if (infoA.start === undefined || infoB.start === undefined) {
            transactionA.adjustRetain('start', infoB.diff);
            transactionB.adjustRetain('start', infoA.diff);
        } else if (infoA.end <= infoB.start) {
            transactionB.adjustRetain('start', infoA.diff);
            transactionA.adjustRetain('end', infoB.diff);
        } else if (infoB.end <= infoA.start) {
            transactionA.adjustRetain('start', infoB.diff);
            transactionB.adjustRetain('end', infoA.diff);
        } else {
            return [null, null];
        }
        return [transactionA, transactionB];
    }
    ;
    ve.dm.Change.static.rebaseUncommittedChange = function(history, uncommitted) {
        var i, iLen, b, j, jLen, a, rebases, rebasedTransactionsA, rebased, transposedHistory, storeB, rebasedStoresA, storeA, authorId, transactionsA = history.transactions.slice(), transactionsB = uncommitted.transactions.slice(), storesA = history.getStores(), storesB = uncommitted.getStores(), selectionsA = OO.cloneObject(history.selections), selectionsB = OO.cloneObject(uncommitted.selections), rejected = null;
        if (history.start !== uncommitted.start) {
            throw new Error('Different starts: ' + history.start + ' and ' + uncommitted.start);
        }
        bLoop: for (i = 0,
        iLen = transactionsB.length; i < iLen; i++) {
            b = transactionsB[i];
            storeB = storesB[i];
            rebasedTransactionsA = [];
            rebasedStoresA = [];
            for (j = 0,
            jLen = transactionsA.length; j < jLen; j++) {
                a = transactionsA[j];
                storeA = storesA[j];
                if (b.authorId < a.authorId) {
                    rebases = ve.dm.Change.static.rebaseTransactions(b, a).reverse();
                } else {
                    rebases = ve.dm.Change.static.rebaseTransactions(a, b);
                }
                if (rebases[0] === null) {
                    rejected = uncommitted.mostRecent(uncommitted.start + i);
                    transactionsB.length = i;
                    storesB.length = i;
                    selectionsB = {};
                    break bLoop;
                }
                rebasedTransactionsA[j] = rebases[0];
                rebasedStoresA[j] = storeA.difference(storeB);
                b = rebases[1];
                storeB = storeB.difference(storeA);
            }
            transactionsA = rebasedTransactionsA;
            storesA = rebasedStoresA;
            transactionsB[i] = b;
            storesB[i] = storeB;
        }
        rebased = new ve.dm.Change(uncommitted.start + transactionsA.length,transactionsB,storesB,{});
        transposedHistory = new ve.dm.Change(history.start + transactionsB.length,transactionsA,storesA,{});
        for (authorId in selectionsB) {
            authorId = +authorId;
            rebased.selections[authorId] = selectionsB[authorId].translateByChange(transposedHistory, authorId);
        }
        for (authorId in selectionsA) {
            authorId = +authorId;
            transposedHistory.selections[authorId] = selectionsA[authorId].translateByChange(rebased, authorId);
        }
        return {
            rebased: rebased,
            transposedHistory: transposedHistory,
            rejected: rejected
        };
    }
    ;
    ve.dm.Change.static.getTransactionInfo = function(tx) {
        var op0, op1, op2, replaceOp, start, end, docLength;
        function getAnnotations(item) {
            if (typeof item === 'string') {
                return [];
            } else if (item.annotations) {
                return item.annotations.slice();
            } else if (item[1]) {
                return item[1].slice();
            } else {
                return [];
            }
        }
        function getSingleCodeUnit(item) {
            if (typeof item === 'string' && item.length === 1) {
                return item;
            }
            if (Array.isArray(item) && item[0].length === 1) {
                return item[0];
            }
            return null;
        }
        function getUniformText(items) {
            var annotations, annotationString, i, iLen, codeUnit, codeUnits = [];
            if (items.length === 0) {
                return null;
            }
            codeUnit = getSingleCodeUnit(items[0]);
            if (codeUnit === null) {
                return null;
            }
            codeUnits.push(codeUnit);
            annotations = getAnnotations(items[0]);
            annotationString = annotations.join(',');
            for (i = 1,
            iLen = items.length; i < iLen; i++) {
                codeUnit = getSingleCodeUnit(items[i]);
                if (codeUnit === null) {
                    return null;
                }
                codeUnits.push(codeUnit);
                if (annotationString !== getAnnotations(items[i]).join(',')) {
                    return null;
                }
            }
            return {
                text: codeUnits.join(''),
                annotations: annotations,
                annotationString: annotationString
            };
        }
        op0 = tx.operations[0];
        op1 = tx.operations[1];
        op2 = tx.operations[2];
        if (op0 && op0.type === 'replace' && (!op1 || op1.type === 'retain') && !op2) {
            replaceOp = op0;
            start = 0;
            end = start + replaceOp.insert.length;
            docLength = end;
        } else if (op0 && op0.type === 'retain' && op1 && op1.type === 'replace' && (!op2 || op2.type === 'retain')) {
            replaceOp = op1;
            start = op0.length;
            end = start + replaceOp.insert.length;
            docLength = end + (op2 ? op2.length : 0);
        } else {
            return null;
        }
        return {
            start: start,
            end: end,
            docLength: docLength,
            authorId: tx.authorId,
            uniformInsert: getUniformText(replaceOp.insert)
        };
    }
    ;
    ve.dm.Change.prototype.clone = function() {
        return this.constructor.static.unsafeDeserialize(this.toJSON());
    }
    ;
    ve.dm.Change.prototype.isEmpty = function() {
        return this.transactions.length === 0 && Object.keys(this.selections).length === 0;
    }
    ;
    ve.dm.Change.prototype.getLength = function() {
        return this.transactions.length;
    }
    ;
    ve.dm.Change.prototype.getStore = function(n) {
        return this.store.slice(n > 0 ? this.storeLengthAtTransaction[n - 1] : 0, this.storeLengthAtTransaction[n]);
    }
    ;
    ve.dm.Change.prototype.getStores = function() {
        var i, len, end, stores = [], start = 0;
        for (i = 0,
        len = this.getLength(); i < len; i++) {
            end = this.storeLengthAtTransaction[i];
            stores.push(this.store.slice(start, end));
            start = end;
        }
        return stores;
    }
    ;
    ve.dm.Change.prototype.firstAuthorId = function() {
        var authors;
        if (this.transactions.length) {
            return this.transactions[0].authorId;
        }
        authors = Object.keys(this.selections);
        if (authors.length) {
            return +authors[0];
        }
        return null;
    }
    ;
    ve.dm.Change.prototype.summarize = function() {
        return '{ start: ' + this.start + ', txs: [ ' + this.transactions.map(function(tx) {
            return tx.summarize();
        }).join(', ') + ' ] }';
    }
    ;
    ve.dm.Change.prototype.reversed = function() {
        return new ve.dm.Change(this.start + this.transactions.length,this.transactions.map(function(tx) {
            return ve.dm.Transaction.prototype.reversed.call(tx);
        }).reverse(),this.transactions.map(function() {
            return new ve.dm.HashValueStore();
        }),{});
    }
    ;
    ve.dm.Change.prototype.rebasedOnto = function(other) {
        var rebases = this.constructor.static.rebaseUncommittedChange(other, this);
        return rebases.rejected ? null : rebases.rebased;
    }
    ;
    ve.dm.Change.prototype.concat = function(other) {
        if (other.start !== this.start + this.transactions.length) {
            throw new Error('this ends at ' + (this.start + this.transactions.length) + ' but other starts at ' + other.start);
        }
        return new ve.dm.Change(this.start,this.transactions.concat(other.transactions),this.getStores().concat(other.getStores()),other.selections);
    }
    ;
    ve.dm.Change.prototype.pushTransaction = function(transaction, storeLength) {
        if (typeof storeLength !== 'number') {
            throw new Error('Expected numerical storeLength argument, not ' + storeLength);
        }
        this.transactions.push(transaction);
        this.storeLengthAtTransaction.push(storeLength);
    }
    ;
    ve.dm.Change.prototype.push = function(other) {
        var i, iLen, stores, transaction, store, change = this;
        if (other.start !== this.start + this.getLength()) {
            throw new Error('this ends at ' + (this.start + this.getLength()) + ' but other starts at ' + other.start);
        }
        stores = other.getStores();
        for (i = 0,
        iLen = other.transactions.length; i < iLen; i++) {
            transaction = other.transactions[i];
            store = stores[i];
            change.store.merge(store);
            this.pushTransaction(transaction, change.store.getLength());
        }
        this.selections = OO.cloneObject(other.selections);
    }
    ;
    ve.dm.Change.prototype.concatRebased = function(other) {
        return this.concat(other.rebasedOnto(this));
    }
    ;
    ve.dm.Change.prototype.mostRecent = function(start) {
        if (arguments.length > 1) {
            throw new Error('storeStart is no longer needed');
        }
        return new ve.dm.Change(start,this.transactions.slice(start - this.start),this.getStores().slice(start - this.start),OO.cloneObject(this.selections));
    }
    ;
    ve.dm.Change.prototype.truncate = function(length) {
        if (arguments.length > 1) {
            throw new Error('storeLength is no longer needed');
        }
        return new ve.dm.Change(this.start,this.transactions.slice(0, length),this.getStores().slice(0, length),{});
    }
    ;
    ve.dm.Change.prototype.applyTo = function(surface, applySelection) {
        var doc = surface.getDocument();
        if (this.start !== doc.completeHistory.getLength()) {
            throw new Error('Change starts at ' + this.start + ', but doc is at ' + doc.completeHistory.getLength());
        }
        this.getStores().forEach(function(store) {
            surface.documentModel.store.merge(store);
        });
        surface.breakpoint();
        this.transactions.forEach(function(tx) {
            var range, offset;
            surface.change(tx);
            tx.applied = !1;
            if (applySelection) {
                range = tx.getModifiedRange(doc);
                if (range) {
                    offset = doc.getNearestCursorOffset(range.end, -1);
                    if (offset !== -1) {
                        surface.setSelection(new ve.dm.LinearSelection(new ve.Range(offset)));
                    }
                }
            }
        });
        surface.breakpoint();
    }
    ;
    ve.dm.Change.prototype.unapplyTo = function(surface) {
        var doc = surface.getDocument()
          , historyLength = doc.completeHistory.getLength() - this.getLength();
        if (this.start !== historyLength) {
            throw new Error('Invalid start: change starts at ' + this.start + ', but doc would be at ' + historyLength);
        }
        this.transactions.slice().reverse().forEach(function(tx) {
            surface.change(tx.reversed());
        });
        doc.completeHistory.transactions.length = historyLength;
        doc.completeHistory.storeLengthAtTransaction.length = historyLength;
        doc.store.truncate(doc.completeHistory.storeLengthAtTransaction[historyLength - 1]);
    }
    ;
    ve.dm.Change.prototype.addToHistory = function(documentModel) {
        documentModel.completeHistory.push(this);
    }
    ;
    ve.dm.Change.prototype.removeFromHistory = function(doc) {
        if (this.start + this.getLength() !== doc.completeHistory.getLength()) {
            throw new Error('this ends at ' + (this.start + this.getLength()) + ' but history ends at ' + doc.completeHistory.getLength());
        }
        doc.completeHistory.transactions.length -= this.transactions.length;
        doc.completeHistory.storeLengthAtTransaction.length -= this.transactions.length;
        doc.store.truncate(doc.completeHistory.storeLengthAtTransaction[doc.completeHistory.getLength() - 1]);
    }
    ;
    ve.dm.Change.prototype.serialize = function(preserveStoreValues) {
        var authorId, serializeStoreValues, serializeStore, i, iLen, tx, info, prevInfo, txSerialized, stores, data, getTransactionInfo = this.constructor.static.getTransactionInfo, selections = {}, transactions = [];
        for (authorId in this.selections) {
            selections[authorId] = this.selections[authorId].toJSON();
        }
        serializeStoreValues = preserveStoreValues ? function noop(x) {
            return x;
        }
        : this.constructor.static.serializeValue;
        serializeStore = function(store) {
            return store.serialize(serializeStoreValues);
        }
        ;
        for (i = 0,
        iLen = this.transactions.length; i < iLen; i++) {
            tx = this.transactions[i];
            info = getTransactionInfo(tx);
            if (info && prevInfo && info.authorId === prevInfo.authorId && info.start === prevInfo.end && info.uniformInsert && prevInfo.uniformInsert && info.uniformInsert.annotationString === prevInfo.uniformInsert.annotationString) {
                transactions.push(info.uniformInsert.text);
            } else {
                txSerialized = tx.toJSON();
                if (i > 0 && tx.authorId === this.transactions[i - 1].authorId) {
                    delete txSerialized.authorId;
                }
                transactions.push(txSerialized);
            }
            prevInfo = info;
        }
        stores = this.getStores().map(serializeStore);
        data = {
            start: this.start,
            transactions: transactions
        };
        if (stores.some(function(store) {
            return store !== null;
        })) {
            data.stores = stores;
        }
        if (Object.keys(selections).length) {
            data.selections = selections;
        }
        return data;
    }
    ;
    ve.dm.Change.prototype.toJSON = function() {
        return this.serialize();
    }
    ;
    ve.dm.Change.prototype.squash = function() {
        if (this.transactions.length <= 1) {
            return this.clone();
        }
        return new ve.dm.Change(this.start,[ve.dm.TransactionSquasher.static.squash(this.transactions)],[this.store.clone()],ve.cloneObject(this.selections));
    }
    ;
    ve.dm.TreeCursor = function VeDmTreeCursor(root, liveIgnoreNodes, linearOffset) {
        this.root = root;
        this.liveIgnoreNodes = liveIgnoreNodes;
        this.path = [];
        this.offset = 0;
        this.nodes = [root];
        this.node = root;
        this.lastStep = null;
        if (linearOffset === undefined) {
            linearOffset = 0;
        }
        this.linearOffset = linearOffset;
    }
    ;
    OO.initClass(ve.dm.TreeCursor);
    ve.dm.TreeCursor.prototype.normalizeCursor = function(tooShort) {
        var item;
        if (!this.node) {
            return;
        }
        if (tooShort === undefined) {
            tooShort = -1;
        }
        if (this.node.type === 'text' && this.offset === this.node.length) {
            this.nodes.pop();
            this.node = this.nodes[this.nodes.length - 1];
            this.offset = this.path.pop() + 1;
        }
        this.crossIgnoredNodes();
        if (this.node.hasChildren() && (item = this.node.children[this.offset]) && item.type === 'text' && item.length > tooShort) {
            this.node = item;
            this.nodes.push(item);
            this.path.push(this.offset);
            this.offset = 0;
        }
    }
    ;
    ve.dm.TreeCursor.prototype.crossIgnoredNodes = function() {
        var parent, nextSibling, len, item;
        if (this.node && this.node.type === 'text' && this.offset === this.node.length && (parent = this.nodes[this.nodes.length - 2]) && (nextSibling = parent.children[this.path[this.path.length - 1] + 1]) && this.liveIgnoreNodes.indexOf(nextSibling) !== -1) {
            this.stepOut();
        }
        len = (this.node && this.node.hasChildren() && this.node.children.length) || 0;
        while (this.offset < len && (item = this.node.children[this.offset]) && this.liveIgnoreNodes.indexOf(item) !== -1) {
            this.offset++;
            this.linearOffset += item.getOuterLength();
        }
    }
    ;
    ve.dm.TreeCursor.prototype.checkLinearOffset = function() {
        var expected = this.node.getOffset();
        if (this.node.type === 'text') {
            expected += this.offset;
        } else {
            if (this.node !== this.root) {
                expected += 1;
            }
            if (this.node.hasChildren()) {
                this.node.children.slice(0, this.offset).forEach(function(child) {
                    expected += child.getOuterLength();
                });
            }
        }
        if (expected !== this.linearOffset) {
            throw new Error('Linear offset does not match tree position');
        }
    }
    ;
    ve.dm.TreeCursor.prototype.stepAtMost = function(maxLength) {
        var childLength, item, step, length;
        if (!this.node) {
            this.lastStep = undefined;
            return undefined;
        }
        if (ve.test) {
            this.checkLinearOffset();
        }
        this.normalizeCursor(maxLength);
        if (this.node.type === 'text') {
            length = Math.min(maxLength, this.node.length - this.offset);
            step = {
                type: 'crosstext',
                length: length,
                path: this.path.slice(),
                node: this.node,
                offset: this.offset,
                offsetLength: length
            };
            this.offset += step.length;
            this.lastStep = step;
            this.linearOffset += length;
            return step;
        }
        childLength = this.node.hasChildren() ? this.node.children.length : 0;
        if (this.offset > childLength) {
            throw new Error('Offset ' + this.offset + ' > childLength ' + childLength);
        }
        if (this.offset === childLength) {
            return this.stepOut();
        }
        item = this.node.children[this.offset];
        if (item.getOuterLength() > maxLength) {
            return this.stepIn();
        }
        length = item.getOuterLength();
        step = {
            type: 'cross',
            length: length,
            path: this.path.slice(),
            node: this.node,
            offset: this.offset,
            item: item
        };
        this.offset++;
        this.lastStep = step;
        this.linearOffset += length;
        return step;
    }
    ;
    ve.dm.TreeCursor.prototype.stepIn = function() {
        var item, length, step;
        if (this.node.type === 'text' || !this.node.hasChildren() || this.offset >= this.node.children.length) {
            throw new Error('No node to step into');
        }
        item = this.node.children[this.offset];
        length = item.type === 'text' ? 0 : 1;
        step = {
            type: 'open',
            length: length,
            path: this.path.slice(),
            node: this.node,
            offset: this.offset,
            item: item
        };
        this.path.push(this.offset);
        this.nodes.push(item);
        this.node = item;
        this.offset = 0;
        this.lastStep = step;
        this.linearOffset += length;
        return step;
    }
    ;
    ve.dm.TreeCursor.prototype.stepOut = function() {
        var item, step, treeCursor = this, priorOffset = this.offset;
        item = this.nodes.pop();
        this.node = this.nodes[this.nodes.length - 1];
        this.offset = this.path.pop();
        if (this.node === undefined) {
            this.lastStep = undefined;
            return undefined;
        }
        if (item.type === 'text') {
            this.linearOffset += item.getLength() - priorOffset;
        } else {
            if (item.hasChildren()) {
                item.children.slice(priorOffset).forEach(function(child) {
                    treeCursor.linearOffset += child.getOuterLength();
                });
            }
            this.linearOffset++;
        }
        step = {
            type: 'close',
            length: item.type === 'text' ? 0 : 1,
            path: this.path.slice(),
            node: this.node,
            offset: this.offset,
            item: item
        };
        this.offset++;
        this.lastStep = step;
        return step;
    }
    ;
    ve.dm.TreeModifier = function VeDmTreeModifier() {
        this.document = null;
        this.insertions = null;
        this.data = null;
        this.deletions = null;
        this.remover = null;
        this.inserter = null;
        this.treeOps = null;
        this.insertedNodes = null;
        this.insertedPositions = null;
        this.adjustmentTree = null;
    }
    ;
    OO.initClass(ve.dm.TreeModifier);
    ve.dm.TreeModifier.static.applyTreeOperations = function(isReversed, document, treeOps) {
        var i, iLen;
        for (i = 0,
        iLen = treeOps.length; i < iLen; i++) {
            this.applyTreeOperation(isReversed, document, treeOps[i]);
        }
    }
    ;
    ve.dm.TreeModifier.static.checkEqualData = function(actual, expected) {
        var jActual, jExpected;
        function replacer(name, value) {
            if (name === 'changesSinceLoad' || name === 'originalDomElementsHash' || name === 'originalMw' || name === 'mw' || name === 'contentsUsed') {
                return undefined;
            }
            return value;
        }
        jActual = JSON.stringify(actual, replacer);
        jExpected = JSON.stringify(expected, replacer);
        if (jActual !== jExpected) {
            throw new Error('Expected ' + jExpected + ' but got ' + jActual);
        }
    }
    ;
    ve.dm.TreeModifier.static.applyTreeOperation = function(isReversed, document, treeOp) {
        var wantText, f, t, a, data, node, adjustment, nodeToInsert, removedNodes = [], addedNodes = [], changedBranchNodes = [];
        function splice(parentNode) {
            var removed = parentNode.splice.apply(parentNode, Array.prototype.slice.call(arguments, 1));
            ve.batchPush(removedNodes, removed);
            ve.batchPush(addedNodes, Array.prototype.slice.call(arguments, 3));
            return removed;
        }
        function ensureText(position) {
            var pre, post, newNode, node = position.node, offset = position.offset;
            if (node.type === 'text') {
                return position;
            }
            pre = node.children[offset - 1];
            post = node.children[offset];
            if (post && post.type === 'text') {
                return {
                    node: post,
                    offset: 0
                };
            }
            if (pre && pre.type === 'text') {
                return {
                    node: pre,
                    offset: pre.length
                };
            }
            if (!node.hasChildren()) {
                throw new Error('Cannot add a child to ' + node.type + ' node');
            }
            newNode = new ve.dm.TextNode(0);
            splice(node, offset, 0, newNode);
            return {
                node: newNode,
                offset: 0
            };
        }
        function ensureNotText(position) {
            var parentNode, parentOffset, length, newNode, node = position.node, offset = position.offset;
            if (node.type !== 'text') {
                return position;
            }
            parentNode = node.parent;
            parentOffset = node.parent.children.indexOf(node);
            if (offset === 0) {
                return {
                    node: parentNode,
                    offset: parentOffset
                };
            }
            if (offset === node.length) {
                return {
                    node: parentNode,
                    offset: parentOffset + 1
                };
            }
            length = node.length - offset;
            node.adjustLength(-length);
            newNode = new ve.dm.TextNode(length);
            splice(parentNode, parentOffset + 1, 0, newNode);
            return {
                node: parentNode,
                offset: parentOffset + 1
            };
        }
        function findContentPosition(node, contentOffset) {
            var i, offset, childLength, child;
            if (contentOffset === 0) {
                return {
                    node: node,
                    offset: 0
                };
            }
            offset = 0;
            for (i = 0; ; i++) {
                child = node.children[i];
                if (!child) {
                    throw new Error('Node does not reach offset');
                }
                childLength = child.getOuterLength();
                offset += childLength;
                if (offset >= contentOffset) {
                    break;
                }
            }
            if (offset === contentOffset) {
                return {
                    node: node,
                    offset: i + 1
                };
            }
            return {
                node: child,
                offset: contentOffset - offset + childLength
            };
        }
        function prepareSplice(pathAndOffset, isContent, wantText) {
            var i, iLen, position, path = pathAndOffset.slice(0, -1), offset = pathAndOffset[pathAndOffset.length - 1], node = document.documentNode;
            for (i = 0,
            iLen = path.length; i < iLen; i++) {
                node = node.children[path[i]];
            }
            if (isContent) {
                if (wantText) {
                    position = ensureText(findContentPosition(node, offset));
                } else {
                    position = ensureNotText(findContentPosition(node, offset));
                }
            } else {
                position = {
                    node: node,
                    offset: offset
                };
            }
            if (position.node.type === 'text' || position.offset === 0) {
                position.linearOffset = position.node.getRange().start + position.offset;
            } else {
                position.linearOffset = position.node.children[position.offset - 1].getOuterRange().end;
            }
            return position;
        }
        function markBranchNodeChanged(offset) {
            var item, adjustment = isReversed ? -1 : 1, i = offset - 1;
            while (i >= 0) {
                item = document.data.getData(i--);
                if (!(ve.dm.LinearData.static.isOpenElementData(item) && ve.dm.nodeFactory.lookup(ve.dm.LinearData.static.getType(item)).prototype instanceof ve.dm.BranchNode)) {
                    continue;
                }
                if (item.internal && item.internal.changesSinceLoad !== undefined) {
                    if (changedBranchNodes.indexOf(item) === -1) {
                        changedBranchNodes.push(item);
                        item.internal.changesSinceLoad += adjustment;
                    }
                }
                break;
            }
        }
        function spliceLinear(offset, remove, data) {
            var content;
            data = data || [];
            content = ve.batchSplice(document.data, offset, remove, data);
            markBranchNodeChanged(offset);
            return content;
        }
        function healTextNodes(node, offset) {
            var pre = node.children[offset - 1]
              , post = node.children[offset];
            if (post && post.type === 'text' && post.length === 0) {
                splice(node, offset, 1);
                post = node.children[offset];
            }
            if (pre && post && pre.type === 'text' && post.type === 'text') {
                pre.adjustLength(post.length);
                splice(node, offset, 1);
            }
        }
        wantText = treeOp.type.slice(-4) === 'Text';
        f = treeOp.from && prepareSplice(treeOp.from, treeOp.isContent, wantText);
        t = treeOp.to && prepareSplice(treeOp.to, treeOp.isContent, wantText);
        a = treeOp.at && prepareSplice(treeOp.at, treeOp.isContent, wantText);
        switch (treeOp.type) {
        case 'removeNode':
            data = spliceLinear(a.linearOffset, 2);
            this.checkEqualData(data, [treeOp.element, {
                type: '/' + treeOp.element.type
            }]);
            splice(a.node, a.offset, 1);
            healTextNodes(a.node, a.offset);
            break;
        case 'insertNode':
            spliceLinear(a.linearOffset, 0, [treeOp.element, {
                type: '/' + treeOp.element.type
            }]);
            nodeToInsert = ve.dm.nodeFactory.createFromElement(treeOp.element);
            if (nodeToInsert instanceof ve.dm.BranchNode) {
                nodeToInsert.setupBlockSlugs();
            }
            splice(a.node, a.offset, 0, nodeToInsert);
            break;
        case 'moveNode':
            data = spliceLinear(f.linearOffset, f.node.children[f.offset].getOuterLength());
            node = f.node.splice(f.offset, 1)[0];
            adjustment = t.linearOffset > f.linearOffset ? data.length : 0;
            spliceLinear(t.linearOffset - adjustment, 0, data);
            t.node.splice(t.offset, 0, node);
            break;
        case 'removeText':
            data = spliceLinear(a.linearOffset, treeOp.data.length);
            this.checkEqualData(data, treeOp.data);
            a.node.adjustLength(-treeOp.data.length);
            healTextNodes(a.node.parent, a.node.parent.children.indexOf(a.node));
            break;
        case 'insertText':
            spliceLinear(a.linearOffset, 0, treeOp.data);
            a.node.adjustLength(treeOp.data.length);
            break;
        case 'moveText':
            data = spliceLinear(f.linearOffset, treeOp.length);
            f.node.adjustLength(-treeOp.length);
            healTextNodes(f.node.parent, f.node.parent.children.indexOf(f.node));
            adjustment = t.linearOffset > f.linearOffset ? data.length : 0;
            spliceLinear(t.linearOffset - adjustment, 0, data);
            t.node.adjustLength(treeOp.length);
            break;
        default:
            throw new Error('Unknown tree op type: ' + treeOp.type);
        }
        if (addedNodes.length || removedNodes.length) {
            document.updateNodesByType(addedNodes, removedNodes);
        }
    }
    ;
    ve.dm.TreeModifier.prototype.process = function(document, transaction) {
        this.setup(document);
        this.calculateTreeOperations(transaction);
        this.constructor.static.applyTreeOperations(transaction.isReversed, document, this.treeOps);
    }
    ;
    ve.dm.TreeModifier.prototype.setup = function(document) {
        this.document = document;
        this.insertions = [];
        this.data = document.data;
        this.deletions = [];
        this.remover = new ve.dm.TreeCursor(document.getDocumentNode(),[]);
        this.inserter = new ve.dm.TreeCursor(document.getDocumentNode(),this.deletions);
        this.treeOps = [];
        this.insertedNodes = [];
        this.insertedPositions = [];
        this.adjustmentTree = {};
    }
    ;
    ve.dm.TreeModifier.prototype.calculateTreeOperations = function(transaction) {
        var i, iLen, linearOps = transaction.operations;
        for (i = 0,
        iLen = linearOps.length; i < iLen; i++) {
            this.processLinearOperation(linearOps[i]);
        }
        this.processImplicitFinalRetain();
    }
    ;
    ve.dm.TreeModifier.prototype.processLinearOperation = function(linearOp) {
        var retainLength, i, iLen, item, data;
        if (linearOp.type === 'retain') {
            retainLength = linearOp.length;
            while (retainLength > 0) {
                retainLength -= this.processRetain(retainLength);
            }
        } else if (linearOp.type === 'replace') {
            for (i = 0,
            iLen = linearOp.remove.length; i < iLen; i++) {
                item = linearOp.remove[i];
                if (item.type) {
                    this.processRemove(item);
                    continue;
                }
                data = [item];
                while (++i < iLen && !linearOp.remove[i].type) {
                    item = linearOp.remove[i];
                    data.push(item);
                }
                i--;
                this.processRemove(data);
            }
            for (i = 0,
            iLen = linearOp.insert.length; i < iLen; i++) {
                item = linearOp.insert[i];
                if (item.type) {
                    this.processInsert(item);
                    continue;
                }
                data = [item];
                while (++i < iLen && !linearOp.insert[i].type) {
                    item = linearOp.insert[i];
                    data.push(item);
                }
                i--;
                this.processInsert(data);
            }
        }
    }
    ;
    ve.dm.TreeModifier.prototype.processImplicitFinalRetain = function() {
        var node, retainLength, item;
        while (true) {
            node = this.remover.node;
            if (!node || (node === this.remover.root && this.remover.offset === node.children.length)) {
                return;
            }
            if (node.type === 'text') {
                retainLength = Math.max(1, node.length - this.remover.offset);
            } else if (!node.hasChildren()) {
                retainLength = 1;
            } else {
                item = node.children[this.remover.offset];
                retainLength = item ? item.getOuterLength() : 1;
            }
            this.processRetain(retainLength);
        }
    }
    ;
    ve.dm.TreeModifier.prototype.cursorsMatch = function() {
        var rawRemoverPosition, rawInserterPosition, adjustedRemoverPosition, adjustedInserterPosition;
        if (this.insertedPositions.length > 0) {
            return false;
        }
        rawRemoverPosition = this.getRawRemoverPosition({
            path: this.remover.path,
            offset: this.remover.offset,
            node: this.remover.node
        });
        rawInserterPosition = this.getRawInserterPosition();
        adjustedRemoverPosition = this.adjustRemoverPosition(rawRemoverPosition);
        adjustedInserterPosition = this.adjustInserterPosition(rawInserterPosition);
        return JSON.stringify(adjustedRemoverPosition) === JSON.stringify(adjustedInserterPosition);
    }
    ;
    ve.dm.TreeModifier.prototype.processRetain = function(maxLength) {
        var removerStep, inserterStep, element, remover = this.remover, inserter = this.inserter;
        if (this.insertedPositions.length === 0) {
            this.inserter.crossIgnoredNodes();
        }
        if (this.cursorsMatch()) {
            removerStep = remover.stepAtMost(maxLength);
            inserterStep = inserter.stepAtMost(maxLength);
            if (!removerStep) {
                throw new Error('Remover past end');
            }
            if (!inserterStep) {
                throw new Error('Inserter past end');
            }
            if (!this.cursorsMatch()) {
                throw new Error('Remover and inserter unexpectedly diverged');
            }
            return removerStep.length;
        }
        removerStep = remover.stepAtMost(maxLength);
        switch (removerStep.type) {
        case 'crosstext':
            this.pushMoveTextOp(removerStep);
            if (this.insertedPositions.length) {
                this.insertedPositions[this.insertedPositions.length - 1] += removerStep.length;
            }
            break;
        case 'cross':
            if (removerStep.item.type === 'text') {
                this.pushMoveTextOp(removerStep);
                if (this.insertedPositions.length) {
                    this.insertedPositions[this.insertedPositions.length - 1] += removerStep.item.length;
                }
            } else {
                this.deletions.push(removerStep.item);
                this.pushMoveNodeOp(removerStep);
                if (this.insertedPositions.length) {
                    this.insertedPositions[this.insertedPositions.length - 1] += this.isInsertionContent() ? 2 : 1;
                }
            }
            break;
        case 'open':
            this.deletions.push(removerStep.item);
            element = removerStep.item.getClonedElement(true);
            this.pushInsertNodeOp(element);
            this.insertedNodes.push(element);
            this.insertedPositions.push(0);
            break;
        case 'close':
            if (this.insertedPositions.length) {
                this.insertedNodes.pop();
                this.insertedPositions.pop();
                if (this.insertedPositions.length) {
                    this.insertedPositions[this.insertedPositions.length - 1] += this.isInsertionContent() ? 2 : 1;
                }
            } else {
                if (inserter.node.type === 'text') {
                    inserter.stepOut();
                }
                inserterStep = inserter.stepOut();
                if (inserterStep.item.type !== removerStep.item.type) {
                    throw new Error('Expected ' + removerStep.item.type + ', not ' + inserterStep.item.type);
                }
            }
            this.pushRemoveLastIfInDeletions();
            break;
        }
        return removerStep.length;
    }
    ;
    ve.dm.TreeModifier.prototype.processRemove = function(itemOrData) {
        var cursorsMatch = this.cursorsMatch()
          , length = itemOrData.length || 1
          , step = this.remover.stepAtMost(length);
        if (cursorsMatch && (step.type === 'cross' || step.type === 'crosstext')) {
            this.inserter.stepAtMost(length);
        }
        if (step.type === 'crosstext') {
            this.pushRemoveTextOp(step);
        } else if (step.type === 'cross') {
            this.pushRemoveLast();
        } else if (step.type === 'open') {
            this.deletions.push(step.item);
        } else if (step.type === 'close') {
            this.pushRemoveLastIfInDeletions();
        }
    }
    ;
    ve.dm.TreeModifier.prototype.processInsert = function(itemOrData) {
        var item, type, data, element, step, inserter = this.inserter;
        if (itemOrData.type) {
            item = itemOrData;
            type = item.type.charAt(0) === '/' ? 'close' : 'open';
        } else {
            data = itemOrData;
            type = 'crosstext';
        }
        if (type === 'open') {
            if (inserter.node.type === 'text') {
                inserter.stepOut();
            }
            element = ve.copy(item);
            this.pushInsertNodeOp(element);
            this.insertedNodes.push(element);
            this.insertedPositions.push(0);
        } else if (type === 'crosstext') {
            this.pushInsertTextOp(ve.copy(data));
            if (this.insertedPositions.length) {
                this.insertedPositions[this.insertedPositions.length - 1] += data.length;
            }
        } else if (type === 'close') {
            if (this.insertedPositions.length) {
                this.insertedNodes.pop();
                this.insertedPositions.pop();
                if (this.insertedPositions.length) {
                    this.insertedPositions[this.insertedPositions.length - 1] += this.isInsertionContent() ? 2 : 1;
                }
            } else {
                if (inserter.node.type === 'text') {
                    inserter.stepOut();
                }
                step = inserter.stepOut();
                if (step.item.type !== item.type.slice(1)) {
                    throw new Error('Expected closing for ' + step.item.type + ' but got closing for ' + item.type.slice(1));
                }
            }
        }
    }
    ;
    ve.dm.TreeModifier.prototype.pushRemoveLast = function() {
        var step = this.remover.lastStep;
        if (step.item.type === 'text') {
            this.pushRemoveTextOp(step);
        } else {
            this.pushRemoveNodeOp(step);
        }
    }
    ;
    ve.dm.TreeModifier.prototype.pushRemoveLastIfInDeletions = function() {
        var i = this.deletions.indexOf(this.remover.lastStep.item);
        if (i !== -1) {
            this.pushRemoveLast();
        }
    }
    ;
    ve.dm.TreeModifier.prototype.pushInsertNodeOp = function(element) {
        var isContent = this.isInsertionContent()
          , rawInserterPosition = this.getRawInserterPosition();
        this.checkCanInsertNodeType(element.type);
        this.treeOps.push({
            type: 'insertNode',
            isContent: isContent,
            at: this.adjustInserterPosition(rawInserterPosition),
            element: element
        });
        if (this.insertedPositions.length === 0) {
            this.modifyAdjustmentTree(rawInserterPosition, isContent ? 2 : 1, false);
        }
    }
    ;
    ve.dm.TreeModifier.prototype.pushInsertTextOp = function(data) {
        var rawInserterPosition = this.getRawInserterPosition();
        this.checkCanInsertText();
        this.treeOps.push({
            type: 'insertText',
            isContent: !0,
            at: this.adjustInserterPosition(rawInserterPosition),
            data: data
        });
        if (this.insertedPositions.length === 0) {
            this.modifyAdjustmentTree(rawInserterPosition, data.length, false);
        }
    }
    ;
    ve.dm.TreeModifier.prototype.pushMoveNodeOp = function(removerStep) {
        var rawRemoverPosition = this.getRawRemoverPosition(removerStep)
          , rawInserterPosition = this.getRawInserterPosition()
          , isContent = this.doesTypeTakeContent(removerStep.node.type);
        this.checkCanInsertNodeType(removerStep.item.type);
        this.treeOps.push({
            type: 'moveNode',
            isContent: isContent,
            from: this.adjustRemoverPosition(rawRemoverPosition),
            to: this.adjustInserterPosition(rawInserterPosition)
        });
        this.modifyAdjustmentTree(rawRemoverPosition, isContent ? -2 : -1, true);
        if (this.insertedPositions.length === 0) {
            this.modifyAdjustmentTree(rawInserterPosition, isContent ? 2 : 1, false);
        }
    }
    ;
    ve.dm.TreeModifier.prototype.pushMoveTextOp = function(removerStep) {
        var length = removerStep.type === 'crosstext' ? removerStep.length : removerStep.item.getLength()
          , rawRemoverPosition = this.getRawRemoverPosition(removerStep)
          , rawInserterPosition = this.getRawInserterPosition();
        this.checkCanInsertText();
        this.treeOps.push({
            type: 'moveText',
            isContent: !0,
            from: this.adjustRemoverPosition(rawRemoverPosition),
            to: this.adjustInserterPosition(rawInserterPosition),
            length: length
        });
        this.modifyAdjustmentTree(rawRemoverPosition, -length, false);
        if (this.insertedPositions.length === 0) {
            this.modifyAdjustmentTree(rawInserterPosition, length, false);
        }
    }
    ;
    ve.dm.TreeModifier.prototype.pushRemoveNodeOp = function(removerStep) {
        var rawRemoverPosition = this.getRawRemoverPosition(removerStep)
          , isContent = this.doesTypeTakeContent(removerStep.node.type);
        this.treeOps.push({
            type: 'removeNode',
            isContent: isContent,
            at: this.adjustRemoverPosition(rawRemoverPosition),
            element: removerStep.item.getClonedElement(true)
        });
        this.modifyAdjustmentTree(rawRemoverPosition, isContent ? -2 : -1, true);
    }
    ;
    ve.dm.TreeModifier.prototype.pushRemoveTextOp = function(removerStep) {
        var start, end, rawRemoverPosition = this.getRawRemoverPosition(removerStep);
        if (removerStep.type === 'crosstext') {
            start = removerStep.node.getRange().start + removerStep.offset;
            end = start + removerStep.length;
        } else {
            start = removerStep.item.getRange().start;
            end = removerStep.item.getRange().end;
        }
        this.treeOps.push({
            type: 'removeText',
            isContent: !0,
            at: this.adjustRemoverPosition(rawRemoverPosition),
            data: ve.copy(this.data.slice(start, end))
        });
        this.modifyAdjustmentTree(rawRemoverPosition, start - end, false);
    }
    ;
    ve.dm.TreeModifier.prototype.findOrCreateAdjustmentNode = function(position) {
        var i, len, offset, adjustmentNode = this.adjustmentTree;
        for (i = 0,
        len = position.length; i < len; i++) {
            offset = position[i];
            if (!adjustmentNode[offset]) {
                adjustmentNode[offset] = {};
            }
            adjustmentNode = adjustmentNode[offset];
        }
        return adjustmentNode;
    }
    ;
    ve.dm.TreeModifier.prototype.modifyAdjustmentTree = function(rawPosition, diff, deleteDescendants) {
        var i, adjustmentNode = this.findOrCreateAdjustmentNode(rawPosition);
        if (diff > 0) {
            adjustmentNode.inserted = (adjustmentNode.inserted || 0) + diff;
        } else {
            adjustmentNode.removed = (adjustmentNode.removed || 0) - diff;
        }
        if (deleteDescendants) {
            for (i in adjustmentNode) {
                if (i === 'inserted' || i === 'removed') {
                    continue;
                }
                delete adjustmentNode[i];
            }
        }
    }
    ;
    ve.dm.TreeModifier.prototype.getRawRemoverPosition = function(step) {
        return this.getRawPosition(step.path, step.offset, step.node);
    }
    ;
    ve.dm.TreeModifier.prototype.getRawInserterPosition = function() {
        return this.getRawPosition(this.inserter.path, this.inserter.offset, this.inserter.node);
    }
    ;
    ve.dm.TreeModifier.prototype.adjustRemoverPosition = function(rawPosition) {
        return this.getAdjustedPosition(rawPosition, false);
    }
    ;
    ve.dm.TreeModifier.prototype.adjustInserterPosition = function(rawPosition) {
        return this.getAdjustedPosition(rawPosition, true).concat(this.insertedPositions);
    }
    ;
    ve.dm.TreeModifier.prototype.getRawPosition = function(path, offset, node) {
        var i, numNodesBefore, linearizedOffset;
        if (node.parent instanceof ve.dm.ContentBranchNode) {
            numNodesBefore = path[path.length - 1];
            linearizedOffset = offset;
            for (i = 0; i < numNodesBefore; i++) {
                linearizedOffset += node.parent.children[i].getOuterLength();
            }
            return path.slice(0, -1).concat(linearizedOffset);
        } else if (node instanceof ve.dm.ContentBranchNode) {
            linearizedOffset = 0;
            for (i = 0; i < offset; i++) {
                linearizedOffset += node.children[i].getOuterLength();
            }
            return path.concat(linearizedOffset);
        } else {
            return path.concat(offset);
        }
    }
    ;
    ve.dm.TreeModifier.prototype.getAdjustedPosition = function(position, isInserter) {
        var i, iLen, j, jLen, positionI, childNode, inserted, removed, node = this.adjustmentTree;
        position = position.slice();
        for (i = 0,
        iLen = position.length; i < iLen; i++) {
            positionI = position[i];
            for (j = 0,
            jLen = positionI + 1; j < jLen; j++) {
                childNode = node[j];
                if (!childNode) {
                    continue;
                }
                inserted = childNode.inserted || 0;
                removed = childNode.removed || 0;
                if (i < iLen - 1 || j < jLen - 1) {
                    position[i] += inserted - removed;
                } else {
                    position[i] += inserted;
                    if (isInserter && this.insertedNodes.length > 0) {
                        position[i]--;
                    }
                }
            }
            node = node[positionI];
            if (!node) {
                break;
            }
        }
        return position;
    }
    ;
    ve.dm.TreeModifier.prototype.doesTypeTakeContent = function(type) {
        return !!ve.dm.nodeFactory.canNodeContainContent(type);
    }
    ;
    ve.dm.TreeModifier.prototype.isInsertionContent = function() {
        return this.doesTypeTakeContent(this.getTypeAtInserter());
    }
    ;
    ve.dm.TreeModifier.prototype.getTypeAtInserter = function() {
        return this.insertedNodes.length > 0 ? this.insertedNodes[this.insertedNodes.length - 1].type : this.inserter.node.type;
    }
    ;
    ve.dm.TreeModifier.prototype.checkCanInsertText = function() {
        var parentType = this.getTypeAtInserter();
        if (parentType === 'text') {
            return;
        }
        if (!ve.dm.nodeFactory.canNodeContainContent(parentType)) {
            throw new Error('Cannot insert text into a ' + parentType + ' node');
        }
    }
    ;
    ve.dm.TreeModifier.prototype.checkCanInsertNodeType = function(nodeType) {
        var parentType = this.getTypeAtInserter()
          , nodeClass = ve.dm.nodeFactory.lookup(nodeType)
          , parentClass = ve.dm.nodeFactory.lookup(parentType)
          , childNodeTypes = parentClass.static.childNodeTypes;
        if (Array.isArray(childNodeTypes) && childNodeTypes.length === 0) {
            throw new Error('Cannot add a child to ' + parentType + ' node');
        }
        if (nodeClass.static.isContent && !parentClass.static.canContainContent) {
            throw new Error('Cannot add content node (' + nodeType + ') to a ' + parentType + ' node');
        }
        if (!nodeClass.static.isMetaData) {
            if (!nodeClass.static.isContent && parentClass.static.canContainContent) {
                throw new Error('Cannot add structure node (' + nodeType + ') to a ' + parentType + ' node');
            }
            if (Array.isArray(childNodeTypes) && childNodeTypes.indexOf(nodeType) === -1) {
                throw new Error('Cannot add a ' + nodeType + ' node to ' + parentType + ' node');
            }
        }
    }
    ;
    ve.dm.treeModifier = new ve.dm.TreeModifier();
    ve.dm.Selection = function VeDmSelection() {}
    ;
    OO.initClass(ve.dm.Selection);
    ve.dm.Selection.static.type = null;
    ve.dm.Selection.static.newFromJSON = function(json) {
        var hash, constructor;
        if (ve.dm.Document && arguments[0]instanceof ve.dm.Document) {
            throw new Error('Got obsolete ve.dm.Document argument');
        }
        hash = typeof json === 'string' ? JSON.parse(json) : json;
        constructor = ve.dm.selectionFactory.lookup(hash.type);
        if (!constructor) {
            throw new Error('Unknown selection type ' + hash.name);
        }
        return constructor.static.newFromHash(hash);
    }
    ;
    ve.dm.Selection.static.newFromHash = null;
    ve.dm.Selection.prototype.toJSON = null;
    ve.dm.Selection.prototype.getDescription = null;
    ve.dm.Selection.prototype.collapseToStart = null;
    ve.dm.Selection.prototype.collapseToEnd = null;
    ve.dm.Selection.prototype.collapseToFrom = null;
    ve.dm.Selection.prototype.collapseToTo = null;
    ve.dm.Selection.prototype.isCollapsed = null;
    ve.dm.Selection.prototype.translateByTransaction = null;
    ve.dm.Selection.prototype.translateByTransactionWithAuthor = null;
    ve.dm.Selection.prototype.translateByTransactions = function(txs, excludeInsertion) {
        var i, l, selection = this;
        for (i = 0,
        l = txs.length; i < l; i++) {
            selection = selection.translateByTransaction(txs[i], excludeInsertion);
        }
        return selection;
    }
    ;
    ve.dm.Selection.prototype.translateByChange = function(change, authorId) {
        var i, len, selection = this;
        for (i = 0,
        len = change.transactions.length; i < len; i++) {
            selection = selection.translateByTransactionWithAuthor(change.transactions[i], authorId);
        }
        return selection;
    }
    ;
    ve.dm.Selection.prototype.isNull = function() {
        return false;
    }
    ;
    ve.dm.Selection.prototype.getRanges = null;
    ve.dm.Selection.prototype.getCoveringRange = null;
    ve.dm.Selection.prototype.getName = function() {
        return this.constructor.static.name;
    }
    ;
    ve.dm.Selection.prototype.equals = null;
    ve.dm.selectionFactory = new OO.Factory();
    ve.dm.Surface = function VeDmSurface(doc, attachedRoot, config) {
        if (!config && ve.isPlainObject(attachedRoot)) {
            config = attachedRoot;
            attachedRoot = undefined;
        }
        attachedRoot = attachedRoot || doc.getDocumentNode();
        config = config || {};
        if (!(attachedRoot instanceof ve.dm.BranchNode)) {
            throw new Error('Expected ve.dm.BranchNode for attachedRoot');
        }
        OO.EventEmitter.call(this);
        this.documentModel = doc;
        this.attachedRoot = attachedRoot;
        this.sourceMode = !!config.sourceMode;
        this.metaList = new ve.dm.MetaList(this);
        this.selection = new ve.dm.NullSelection();
        this.selectionBefore = this.selection;
        this.translatedSelection = null;
        this.branchNodes = {};
        this.selectedNode = null;
        this.newTransactions = [];
        this.stagingStack = [];
        this.undoStack = [];
        this.undoIndex = 0;
        this.undoConflict = !1;
        this.historyTrackingInterval = null;
        this.insertionAnnotations = new ve.dm.AnnotationSet(this.getDocument().getStore());
        this.selectedAnnotations = new ve.dm.AnnotationSet(this.getDocument().getStore());
        this.isCollapsed = null;
        this.multiUser = !1;
        this.readOnly = !1;
        this.transacting = !1;
        this.queueingContextChanges = !1;
        this.contextChangeQueued = !1;
        this.authorId = null;
        this.lastStoredChange = doc.getCompleteHistoryLength();
        this.autosaveFailed = !1;
        this.autosavePrefix = '';
        this.synchronizer = null;
        this.storage = ve.init.platform.sessionStorage;
        this.documentModel.attachedRoot = this.attachedRoot;
        this.getDocument().connect(this, {
            transact: 'onDocumentTransact',
            precommit: 'onDocumentPreCommit'
        });
        this.storeChangesListener = this.storeChanges.bind(this);
    }
    ;
    OO.mixinClass(ve.dm.Surface, OO.EventEmitter);
    ve.dm.Surface.prototype.setReadOnly = function(readOnly) {
        if (!!readOnly !== this.readOnly) {
            this.readOnly = !!readOnly;
            if (readOnly) {
                this.stopHistoryTracking();
            } else {
                this.startHistoryTracking();
            }
            this.emit('contextChange');
        }
    }
    ;
    ve.dm.Surface.prototype.isReadOnly = function() {
        return this.readOnly;
    }
    ;
    ve.dm.Surface.prototype.initialize = function() {
        this.startHistoryTracking();
        this.emit('contextChange');
    }
    ;
    ve.dm.Surface.prototype.getDom = function() {
        if (this.sourceMode) {
            return ve.dm.sourceConverter.getSourceTextFromModel(this.getDocument());
        } else {
            return ve.dm.converter.getDomFromModel(this.getDocument());
        }
    }
    ;
    ve.dm.Surface.prototype.getHtml = function() {
        return this.sourceMode ? this.getDom() : ve.properInnerHtml(this.getDom().body);
    }
    ;
    ve.dm.Surface.prototype.setMultiUser = function(multiUser) {
        this.multiUser = multiUser;
    }
    ;
    ve.dm.Surface.prototype.isMultiUser = function() {
        return this.multiUser;
    }
    ;
    ve.dm.Surface.prototype.createSynchronizer = function(documentId, config) {
        if (this.synchronizer) {
            throw new Error('Synchronizer already set');
        }
        this.setNullSelection();
        this.setMultiUser(true);
        this.synchronizer = new ve.dm.SurfaceSynchronizer(this,documentId,config);
    }
    ;
    ve.dm.Surface.prototype.startHistoryTracking = function() {
        if (this.readOnly) {
            return;
        }
        if (this.historyTrackingInterval === null) {
            this.historyTrackingInterval = setInterval(this.breakpoint.bind(this), 3000);
        }
    }
    ;
    ve.dm.Surface.prototype.stopHistoryTracking = function() {
        if (this.readOnly) {
            return;
        }
        if (this.historyTrackingInterval !== null) {
            clearInterval(this.historyTrackingInterval);
            this.historyTrackingInterval = null;
        }
    }
    ;
    ve.dm.Surface.prototype.resetHistoryTrackingInterval = function() {
        this.stopHistoryTracking();
        this.startHistoryTracking();
    }
    ;
    ve.dm.Surface.prototype.getHistory = function() {
        var appliedUndoStack = this.undoStack.slice(0, this.undoStack.length - this.undoIndex);
        if (this.newTransactions.length > 0) {
            return appliedUndoStack.concat([{
                transactions: this.newTransactions.slice(0)
            }]);
        }
        return appliedUndoStack;
    }
    ;
    ve.dm.Surface.prototype.isStaging = function() {
        return this.stagingStack.length > 0;
    }
    ;
    ve.dm.Surface.prototype.getStaging = function() {
        return this.stagingStack[this.stagingStack.length - 1];
    }
    ;
    ve.dm.Surface.prototype.doesStagingAllowUndo = function() {
        var staging = this.getStaging();
        return staging && staging.allowUndo;
    }
    ;
    ve.dm.Surface.prototype.getStagingTransactions = function() {
        var staging = this.getStaging();
        return staging && staging.transactions;
    }
    ;
    ve.dm.Surface.prototype.pushStaging = function(allowUndo) {
        if (!this.isStaging()) {
            if (this.synchronizer) {
                this.synchronizer.pauseChanges();
            }
            this.breakpoint();
            this.stopHistoryTracking();
            this.emit('history');
        }
        this.stagingStack.push({
            transactions: [],
            selectionBefore: this.isStaging() ? this.getStaging().selectionBefore : this.selectionBefore,
            allowUndo: !!allowUndo
        });
    }
    ;
    ve.dm.Surface.prototype.popStaging = function() {
        var i, transaction, staging, transactions, reverseTransactions = [];
        if (!this.isStaging()) {
            return;
        }
        staging = this.stagingStack.pop();
        transactions = staging.transactions;
        for (i = transactions.length - 1; i >= 0; i--) {
            transaction = transactions[i].reversed();
            reverseTransactions.push(transaction);
        }
        this.changeInternal(reverseTransactions, staging.selectionBefore, true);
        if (!this.isStaging()) {
            if (this.synchronizer) {
                this.synchronizer.resumeChanges();
            }
            this.startHistoryTracking();
            this.emit('history');
        }
        return transactions;
    }
    ;
    ve.dm.Surface.prototype.applyStaging = function() {
        var staging;
        if (!this.isStaging()) {
            return;
        }
        staging = this.stagingStack.pop();
        if (this.isStaging()) {
            ve.batchPush(this.getStagingTransactions(), staging.transactions);
            if (this.getStaging().selectionBefore.isNull()) {
                this.getStaging().selectionBefore = staging.selectionBefore;
            }
        } else {
            this.truncateUndoStack();
            this.newTransactions = staging.transactions;
            this.selectionBefore = staging.selectionBefore;
            this.breakpoint();
        }
        if (!this.isStaging()) {
            if (this.synchronizer) {
                this.synchronizer.resumeChanges();
            }
            this.startHistoryTracking();
            this.emit('history');
        }
    }
    ;
    ve.dm.Surface.prototype.popAllStaging = function() {
        var transactions = [];
        if (!this.isStaging()) {
            return;
        }
        while (this.isStaging()) {
            ve.batchSplice(transactions, 0, 0, this.popStaging());
        }
        return transactions;
    }
    ;
    ve.dm.Surface.prototype.applyAllStaging = function() {
        while (this.isStaging()) {
            this.applyStaging();
        }
    }
    ;
    ve.dm.Surface.prototype.getInsertionAnnotations = function() {
        return this.insertionAnnotations.clone();
    }
    ;
    ve.dm.Surface.prototype.setInsertionAnnotations = function(annotations) {
        if (this.readOnly) {
            return;
        }
        this.insertionAnnotations = annotations !== null ? annotations.clone() : new ve.dm.AnnotationSet(this.getDocument().getStore());
        this.emit('insertionAnnotationsChange', this.insertionAnnotations);
        this.emit('contextChange');
    }
    ;
    ve.dm.Surface.prototype.addInsertionAnnotations = function(annotations) {
        if (this.readOnly) {
            return;
        }
        if (annotations instanceof ve.dm.Annotation) {
            this.insertionAnnotations.push(annotations);
        } else if (annotations instanceof ve.dm.AnnotationSet) {
            this.insertionAnnotations.addSet(annotations);
        } else {
            throw new Error('Invalid annotations');
        }
        this.emit('insertionAnnotationsChange', this.insertionAnnotations);
        this.emit('contextChange');
    }
    ;
    ve.dm.Surface.prototype.removeInsertionAnnotations = function(annotations) {
        if (this.readOnly) {
            return;
        }
        if (annotations instanceof ve.dm.Annotation) {
            this.insertionAnnotations.remove(annotations);
        } else if (annotations instanceof ve.dm.AnnotationSet) {
            this.insertionAnnotations.removeSet(annotations);
        } else {
            throw new Error('Invalid annotations');
        }
        this.emit('insertionAnnotationsChange', this.insertionAnnotations);
        this.emit('contextChange');
    }
    ;
    ve.dm.Surface.prototype.canRedo = function() {
        return this.undoIndex > 0 && !this.readOnly;
    }
    ;
    ve.dm.Surface.prototype.canUndo = function() {
        return this.hasBeenModified() && !this.readOnly && (!this.isStaging() || this.doesStagingAllowUndo()) && !this.undoConflict;
    }
    ;
    ve.dm.Surface.prototype.hasBeenModified = function() {
        return this.undoStack.length - this.undoIndex > 0 || !!this.newTransactions.length;
    }
    ;
    ve.dm.Surface.prototype.getDocument = function() {
        return this.documentModel;
    }
    ;
    ve.dm.Surface.prototype.getAttachedRoot = function() {
        return this.attachedRoot;
    }
    ;
    ve.dm.Surface.prototype.getMetaList = function() {
        return this.metaList;
    }
    ;
    ve.dm.Surface.prototype.getSelection = function() {
        return this.selection;
    }
    ;
    ve.dm.Surface.prototype.getTranslatedSelection = function() {
        return this.translatedSelection || this.selection;
    }
    ;
    ve.dm.Surface.prototype.getFragment = function(selection, noAutoSelect, excludeInsertions) {
        selection = selection || this.selection;
        return this.sourceMode ? new ve.dm.SourceSurfaceFragment(this,selection,noAutoSelect,excludeInsertions) : new ve.dm.SurfaceFragment(this,selection,noAutoSelect,excludeInsertions);
    }
    ;
    ve.dm.Surface.prototype.getLinearFragment = function(range, noAutoSelect, excludeInsertions) {
        return this.getFragment(new ve.dm.LinearSelection(range), noAutoSelect, excludeInsertions);
    }
    ;
    ve.dm.Surface.prototype.truncateUndoStack = function() {
        if (this.undoIndex) {
            this.undoStack = this.undoStack.slice(0, this.undoStack.length - this.undoIndex);
            this.undoIndex = 0;
            this.emit('undoStackChange');
        }
    }
    ;
    ve.dm.Surface.prototype.startQueueingContextChanges = function() {
        if (!this.queueingContextChanges) {
            this.queueingContextChanges = !0;
            this.contextChangeQueued = !1;
        }
    }
    ;
    ve.dm.Surface.prototype.emitContextChange = function() {
        if (this.queueingContextChanges) {
            this.contextChangeQueued = !0;
        } else {
            this.emit('contextChange');
        }
    }
    ;
    ve.dm.Surface.prototype.stopQueueingContextChanges = function() {
        if (this.queueingContextChanges) {
            this.queueingContextChanges = !1;
            if (this.contextChangeQueued) {
                this.contextChangeQueued = !1;
                this.emit('contextChange');
            }
        }
    }
    ;
    ve.dm.Surface.prototype.setLinearSelection = function(range) {
        this.setSelection(new ve.dm.LinearSelection(range));
    }
    ;
    ve.dm.Surface.prototype.setNullSelection = function() {
        this.setSelection(new ve.dm.NullSelection());
    }
    ;
    ve.dm.Surface.prototype.fixupRangeForLinks = function(range) {
        var rangeAnnotations, startLink, endLink, linearData = this.getDocument().data, start = range.start, end = range.end;
        function getLinks(offset) {
            return linearData.getAnnotationsFromOffset(offset).filter(function(ann) {
                return ann.name === 'link';
            });
        }
        if (range.isCollapsed()) {
            return range;
        }
        rangeAnnotations = linearData.getAnnotationsFromRange(range);
        startLink = getLinks(start).diffWith(rangeAnnotations).getHash(0);
        endLink = getLinks(end).diffWith(rangeAnnotations).getHash(0);
        if (startLink === undefined && endLink === undefined) {
            return range;
        }
        if (startLink !== undefined) {
            while (start > 0 && getLinks(start - 1).containsHash(startLink)) {
                start--;
            }
        }
        if (endLink !== undefined) {
            while (end < linearData.getLength() && getLinks(end).containsHash(endLink)) {
                end++;
            }
        }
        if (range.isBackwards()) {
            return new ve.Range(end,start);
        } else {
            return new ve.Range(start,end);
        }
    }
    ;
    ve.dm.Surface.prototype.setSelection = function(selection) {
        var maxOffset, insertionAnnotations, selectedNode, range, selectedAnnotations, rangeFocus, oldRangeFocus, focusRangeMovingBack, oldSelection = this.selection, branchNodes = {}, selectionChange = !1, contextChange = !1, linearData = this.getDocument().data;
        if (selection instanceof ve.dm.LinearSelection && (maxOffset = this.getDocument().getDocumentRange().end) && maxOffset < selection.getRange().end) {
            ve.error('Attempted to set an out of bounds selection: ' + JSON.stringify(selection) + ', adjusting');
            selection = new ve.dm.LinearSelection(new ve.Range(Math.min(maxOffset, selection.getRange().start),maxOffset));
        }
        this.translatedSelection = null;
        if (this.transacting) {
            this.selection = selection;
            return;
        }
        if (!oldSelection.equals(selection)) {
            selectionChange = !0;
            this.selection = selection;
        }
        if (selection instanceof ve.dm.LinearSelection) {
            range = selection.getRange();
            branchNodes.start = this.getDocument().getBranchNodeFromOffset(range.start);
            if (!range.isCollapsed()) {
                branchNodes.end = this.getDocument().getBranchNodeFromOffset(range.end);
            } else {
                branchNodes.end = branchNodes.start;
            }
            selectedNode = this.getSelectedNodeFromSelection(selection);
            if (!this.sourceMode) {
                insertionAnnotations = linearData.getInsertionAnnotationsFromRange(range);
                if (!insertionAnnotations.equalsInOrder(this.insertionAnnotations)) {
                    this.setInsertionAnnotations(insertionAnnotations);
                }
                if (range.isCollapsed()) {
                    selectedAnnotations = linearData.getAnnotationsFromOffset(range.start);
                } else {
                    selectedAnnotations = linearData.getAnnotationsFromRange(range, true);
                }
                if (!selectedAnnotations.compareTo(this.selectedAnnotations)) {
                    this.selectedAnnotations = selectedAnnotations;
                    contextChange = !0;
                }
                if (selectionChange && !range.isCollapsed() && oldSelection instanceof ve.dm.LinearSelection) {
                    rangeFocus = new ve.Range(range.to);
                    oldRangeFocus = new ve.Range(oldSelection.getRange().to);
                    focusRangeMovingBack = rangeFocus.to < oldRangeFocus.to;
                    if (!linearData.getInsertionAnnotationsFromRange(rangeFocus, focusRangeMovingBack).compareTo(linearData.getInsertionAnnotationsFromRange(oldRangeFocus, focusRangeMovingBack))) {
                        contextChange = !0;
                    }
                }
            }
        } else if (selection instanceof ve.dm.TableSelection) {
            selectedNode = selection.getMatrixCells(this.getDocument())[0].node;
            contextChange = !0;
        } else if (selection.isNull()) {
            contextChange = !0;
        }
        if (range && range.isCollapsed() !== this.isCollapsed) {
            this.isCollapsed = range.isCollapsed();
            contextChange = !0;
        }
        if (selectedNode !== this.selectedNode || branchNodes.start !== this.branchNodes.start || branchNodes.end !== this.branchNodes.end) {
            this.branchNodes = branchNodes;
            this.selectedNode = selectedNode;
            contextChange = !0;
        }
        if (selectionChange) {
            this.emit('select', this.selection);
            if (oldSelection.isNull()) {
                this.emit('focus');
            }
            if (selection.isNull()) {
                this.emit('blur');
            }
        }
        if (contextChange) {
            this.emitContextChange();
        }
    }
    ;
    ve.dm.Surface.prototype.selectFirstContentOffset = function() {
        var firstOffset = this.getDocument().data.getNearestContentOffset(this.getAttachedRoot().getOffset(), 1);
        if (firstOffset !== -1) {
            this.setLinearSelection(new ve.Range(firstOffset));
        } else {
            this.setNullSelection();
        }
    }
    ;
    ve.dm.Surface.prototype.selectLastContentOffset = function() {
        var data = this.getDocument().data
          , documentRange = this.getDocument().getDocumentRange()
          , lastOffset = data.getNearestContentOffset(documentRange.end, -1);
        if (lastOffset !== -1) {
            this.setLinearSelection(new ve.Range(lastOffset));
        } else {
            this.setNullSelection();
        }
    }
    ;
    ve.dm.Surface.prototype.change = function(transactions, selection) {
        this.changeInternal(transactions, selection, false);
    }
    ;
    ve.dm.Surface.prototype.changeInternal = function(transactions, selection, skipUndoStack) {
        var i, len, selectionAfter, committed, selectionBefore = this.selection, contextChange = !1;
        this.startQueueingContextChanges();
        if (transactions && !this.readOnly) {
            if (transactions instanceof ve.dm.Transaction) {
                transactions = [transactions];
            }
            this.transacting = !0;
            for (i = 0,
            len = transactions.length; i < len; i++) {
                if (!transactions[i].isNoOp()) {
                    try {
                        committed = !1;
                        this.getDocument().commit(transactions[i], this.isStaging());
                        committed = !0;
                    } finally {
                        if (!committed) {
                            this.stopQueueingContextChanges();
                        }
                    }
                    if (!skipUndoStack) {
                        if (this.isStaging()) {
                            if (!this.getStagingTransactions().length) {
                                this.getStaging().selectionBefore = selectionBefore;
                            }
                            this.getStagingTransactions().push(transactions[i]);
                        } else {
                            this.truncateUndoStack();
                            if (!this.newTransactions.length) {
                                this.selectionBefore = selectionBefore;
                            }
                            this.newTransactions.push(transactions[i]);
                        }
                    }
                    if (transactions[i].hasElementAttributeOperations()) {
                        contextChange = !0;
                    }
                }
            }
            this.transacting = !1;
            this.undoConflict = !1;
            this.emit('history');
        }
        selectionAfter = this.selection;
        if (selection) {
            this.setSelection(selection);
        } else if (transactions) {
            this.setSelection(this.selection);
        }
        if (!selectionBefore.equals(selectionAfter) && selectionAfter.equals(this.selection)) {
            this.emit('select', this.selection);
        }
        if (contextChange) {
            this.emitContextChange();
        }
        this.stopQueueingContextChanges();
    }
    ;
    ve.dm.Surface.prototype.breakpoint = function() {
        var breakpointSet = !1;
        if (this.readOnly) {
            return false;
        }
        this.resetHistoryTrackingInterval();
        if (this.newTransactions.length > 0) {
            this.undoStack.push({
                start: this.getDocument().getCompleteHistoryLength() - this.newTransactions.length,
                transactions: this.newTransactions,
                selection: this.selection,
                selectionBefore: this.selectionBefore
            });
            this.newTransactions = [];
            this.emit('undoStackChange');
            breakpointSet = !0;
        }
        this.selectionBefore = this.selection;
        return breakpointSet;
    }
    ;
    ve.dm.Surface.prototype.undo = function() {
        var i, item, transaction, authorId, history, done, result, selection, transactions = [];
        if (!this.canUndo()) {
            return;
        }
        if (this.isStaging()) {
            this.popAllStaging();
        }
        this.breakpoint();
        this.undoIndex++;
        if (!this.isMultiUser()) {
            item = this.undoStack[this.undoStack.length - this.undoIndex];
            if (item) {
                for (i = item.transactions.length - 1; i >= 0; i--) {
                    transaction = item.transactions[i].reversed();
                    transactions.push(transaction);
                }
                this.changeInternal(transactions, item.selectionBefore, true);
                this.emit('undoStackChange');
            }
        } else {
            while (this.undoIndex <= this.undoStack.length) {
                item = this.undoStack[this.undoStack.length - this.undoIndex];
                authorId = item.transactions[0].authorId;
                if (authorId === null || authorId === this.getAuthorId()) {
                    break;
                }
                item = null;
                this.undoIndex++;
            }
            if (item) {
                history = this.getDocument().getChangeSince(item.start + item.transactions.length);
                done = new ve.dm.Change(item.start,item.transactions,item.transactions.map(function() {
                    return new ve.dm.HashValueStore();
                }),{});
                result = ve.dm.Change.static.rebaseUncommittedChange(history, done.reversed());
                if (result.rejected) {
                    this.undoIndex--;
                    this.undoConflict = !0;
                    this.emit('history');
                } else {
                    selection = item.selectionBefore.translateByChange(result.transposedHistory);
                    this.changeInternal(result.rebased.transactions, selection, true);
                    this.emit('undoStackChange');
                }
            } else {
                this.emit('history');
            }
        }
    }
    ;
    ve.dm.Surface.prototype.redo = function() {
        var item;
        if (!this.canRedo()) {
            return;
        }
        this.breakpoint();
        item = this.undoStack[this.undoStack.length - this.undoIndex];
        if (item) {
            this.undoIndex--;
            this.changeInternal(ve.copy(item.transactions), item.selection, true);
            this.emit('undoStackChange');
        }
    }
    ;
    ve.dm.Surface.prototype.onDocumentTransact = function(tx) {
        this.setSelection(this.getSelection().translateByTransactionWithAuthor(tx, this.authorId));
        this.emit('documentUpdate', tx);
    }
    ;
    ve.dm.Surface.prototype.getSelectedNode = function() {
        return this.selectedNode;
    }
    ;
    ve.dm.Surface.prototype.getSelectedNodeFromSelection = function(selection) {
        var range, startNode, selectedNode = null;
        selection = selection || this.getSelection();
        if (!(selection instanceof ve.dm.LinearSelection)) {
            return null;
        }
        range = selection.getRange();
        if (!range.isCollapsed()) {
            startNode = this.getDocument().documentNode.getNodeFromOffset(range.start + 1);
            if (startNode && startNode.getOuterRange().equalsSelection(range)) {
                selectedNode = startNode;
            }
        }
        return selectedNode;
    }
    ;
    ve.dm.Surface.prototype.onDocumentPreCommit = function(tx) {
        this.translatedSelection = this.selection.translateByTransaction(tx);
    }
    ;
    ve.dm.Surface.prototype.getModifiedRanges = function(includeCollapsed, includeInternalList) {
        var doc = this.getDocument()
          , ranges = []
          , compactRanges = []
          , lastRange = null;
        this.getHistory().forEach(function(stackItem) {
            stackItem.transactions.forEach(function(tx) {
                var newRange = tx.getModifiedRange(doc, includeInternalList);
                if (newRange) {
                    ranges.forEach(function(range, i, arr) {
                        arr[i] = tx.translateRange(range, true);
                    });
                    if (includeCollapsed || !newRange.isCollapsed()) {
                        ranges.push(newRange);
                    }
                }
            });
        });
        ranges.sort(function(a, b) {
            return a.start - b.start;
        }).forEach(function(range) {
            if (includeCollapsed || !range.isCollapsed()) {
                if (lastRange && lastRange.touchesRange(range)) {
                    compactRanges.pop();
                    range = lastRange.expand(range);
                }
                compactRanges.push(range);
                lastRange = range;
            }
        });
        return compactRanges;
    }
    ;
    ve.dm.Surface.prototype.getOffsetFromSourceOffset = function(offset) {
        var lineOffset = 0
          , line = 0
          , lines = this.getDocument().getDocumentNode().getChildren();
        if (offset < 0) {
            throw new Error('Offset out of bounds');
        }
        while (lineOffset < offset + 1) {
            if (!lines[line] || lines[line].isInternal()) {
                throw new Error('Offset out of bounds');
            }
            lineOffset += lines[line].getLength() + 1;
            line++;
        }
        return offset + line;
    }
    ;
    ve.dm.Surface.prototype.getSourceOffsetFromOffset = function(offset) {
        var lineOffset = 0
          , line = 0
          , lines = this.getDocument().getDocumentNode().getChildren();
        if (offset < 0) {
            throw new Error('Offset out of bounds');
        }
        while (lineOffset < offset) {
            if (!lines[line] || lines[line].isInternal()) {
                throw new Error('Offset out of bounds');
            }
            lineOffset += lines[line].getOuterLength();
            line++;
        }
        return offset - line;
    }
    ;
    ve.dm.Surface.prototype.getRangeFromSourceOffsets = function(from, to) {
        var fromOffset = this.getOffsetFromSourceOffset(from);
        return new ve.Range(fromOffset,to === undefined || to === from ? fromOffset : this.getOffsetFromSourceOffset(to));
    }
    ;
    ve.dm.Surface.prototype.getAuthorId = function() {
        return this.authorId;
    }
    ;
    ve.dm.Surface.prototype.setAuthorId = function(authorId) {
        this.authorId = authorId;
    }
    ;
    ve.dm.Surface.prototype.storeChanges = function() {
        var dmDoc, change;
        if (this.autosaveFailed) {
            return;
        }
        dmDoc = this.getDocument();
        change = dmDoc.getChangeSince(this.lastStoredChange);
        if (!change.isEmpty()) {
            if (this.storage.appendToList(this.autosavePrefix + 've-changes', JSON.stringify(change))) {
                this.lastStoredChange = dmDoc.getCompleteHistoryLength();
                this.storage.setObject(this.autosavePrefix + 've-selection', this.getSelection());
            } else {
                this.autosaveFailed = !0;
                this.emit('autosaveFailed');
            }
        }
    }
    ;
    ve.dm.Surface.prototype.setAutosaveDocId = function(docId) {
        this.autosavePrefix = docId + '/';
    }
    ;
    ve.dm.Surface.prototype.startStoringChanges = function() {
        this.on('undoStackChange', this.storeChangesListener);
    }
    ;
    ve.dm.Surface.prototype.stopStoringChanges = function() {
        this.off('undoStackChange', this.storeChangesListener);
    }
    ;
    ve.dm.Surface.prototype.restoreChanges = function() {
        var selection, surface = this, restored = !1, changes = this.storage.getList(this.autosavePrefix + 've-changes');
        try {
            changes.forEach(function(changeString) {
                var data = JSON.parse(changeString)
                  , change = ve.dm.Change.static.unsafeDeserialize(data);
                change.applyTo(surface, true);
                surface.breakpoint();
            });
            restored = !!changes.length;
            try {
                selection = ve.dm.Selection.static.newFromJSON(this.storage.getObject(this.autosavePrefix + 've-selection'));
            } catch (e) {}
            if (selection) {
                setTimeout(function() {
                    surface.setSelection(selection);
                });
            }
        } catch (e) {
            throw new Error('Failed to restore auto-saved session: ' + e);
        }
        this.lastStoredChange = this.getDocument().getCompleteHistoryLength();
        return restored;
    }
    ;
    ve.dm.Surface.prototype.storeDocState = function(state, html) {
        var useLatestHtml = html === undefined;
        this.removeDocStateAndChanges();
        if (state) {
            if (!this.updateDocState(state)) {
                this.stopStoringChanges();
                return false;
            }
        }
        if (!this.storage.set(this.autosavePrefix + 've-dochtml', useLatestHtml ? this.getHtml() : html)) {
            this.storage.remove(this.autosavePrefix + 've-docstate');
            this.stopStoringChanges();
            return false;
        }
        if (useLatestHtml) {
            this.lastStoredChange = this.getDocument().getCompleteHistoryLength();
        }
        return true;
    }
    ;
    ve.dm.Surface.prototype.updateDocState = function(state) {
        return this.storage.set(this.autosavePrefix + 've-docstate', JSON.stringify(state));
    }
    ;
    ve.dm.Surface.prototype.removeDocStateAndChanges = function() {
        this.storage.remove(this.autosavePrefix + 've-docstate');
        this.storage.remove(this.autosavePrefix + 've-dochtml');
        this.storage.remove(this.autosavePrefix + 've-selection');
        this.storage.removeList(this.autosavePrefix + 've-changes');
    }
    ;
    ve.dm.SurfaceFragment = function VeDmSurfaceFragment(surface, selection, noAutoSelect, excludeInsertions) {
        if (!surface) {
            return this;
        }
        this.document = surface.getDocument();
        this.noAutoSelect = !!noAutoSelect;
        this.excludeInsertions = !!excludeInsertions;
        this.surface = surface;
        this.selection = selection || surface.getSelection();
        this.leafNodes = null;
        this.pending = [];
        this.historyPointer = this.document.getCompleteHistoryLength();
    }
    ;
    OO.initClass(ve.dm.SurfaceFragment);
    ve.dm.SurfaceFragment.prototype.getSelectedModels = function(all) {
        var i, len, nodes, selectedNode, annotations;
        if (this.isNull()) {
            return [];
        }
        annotations = this.getAnnotations(all);
        if (all) {
            nodes = this.getCoveredNodes();
            for (i = 0,
            len = nodes.length; i < len; i++) {
                if (nodes[i].range && nodes[i].range.isCollapsed()) {
                    nodes.splice(i, 1);
                    len--;
                    i--;
                } else {
                    nodes[i] = nodes[i].node;
                }
            }
        } else {
            nodes = [];
            selectedNode = this.getSelectedNode();
            if (selectedNode) {
                nodes.push(selectedNode);
            }
        }
        return nodes.concat(!annotations.isEmpty() ? annotations.get() : []);
    }
    ;
    ve.dm.SurfaceFragment.prototype.update = function(selection) {
        var txs;
        if (this.isNull()) {
            return this;
        }
        if (selection && !selection.equals(this.selection)) {
            this.selection = selection;
            this.leafNodes = null;
            this.historyPointer = this.document.getCompleteHistoryLength();
        } else if (this.historyPointer < this.document.getCompleteHistoryLength()) {
            txs = this.document.getCompleteHistorySince(this.historyPointer);
            this.selection = this.selection.translateByTransactions(txs, this.excludeInsertions);
            this.leafNodes = null;
            this.historyPointer += txs.length;
        }
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.change = function(txs, selection) {
        if (!selection && this.isNull()) {
            throw new Error('Cannot change null fragment without selection');
        }
        if (!Array.isArray(txs)) {
            txs = [txs];
        }
        this.surface.change(txs, !this.noAutoSelect && (selection || this.getSelection().translateByTransactions(txs, this.excludeInsertions)));
        if (selection) {
            this.update(selection);
        }
    }
    ;
    ve.dm.SurfaceFragment.prototype.getSurface = function() {
        return this.surface;
    }
    ;
    ve.dm.SurfaceFragment.prototype.getDocument = function() {
        return this.document;
    }
    ;
    ve.dm.SurfaceFragment.prototype.getSelection = function() {
        this.update();
        return this.selection;
    }
    ;
    ve.dm.SurfaceFragment.prototype.isNull = function() {
        return this.selection.isNull();
    }
    ;
    ve.dm.SurfaceFragment.prototype.willAutoSelect = function() {
        return !this.noAutoSelect;
    }
    ;
    ve.dm.SurfaceFragment.prototype.setAutoSelect = function(autoSelect) {
        this.noAutoSelect = !autoSelect;
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.clone = function(selection) {
        return new this.constructor(this.surface,selection || this.getSelection(),this.noAutoSelect,this.excludeInsertions);
    }
    ;
    ve.dm.SurfaceFragment.prototype.willExcludeInsertions = function() {
        return this.excludeInsertions;
    }
    ;
    ve.dm.SurfaceFragment.prototype.setExcludeInsertions = function(excludeInsertions) {
        excludeInsertions = !!excludeInsertions;
        if (this.excludeInsertions !== excludeInsertions) {
            this.update();
            this.excludeInsertions = excludeInsertions;
        }
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.adjustLinearSelection = function(start, end) {
        var newRange, oldRange;
        if (!(this.selection instanceof ve.dm.LinearSelection)) {
            return this.clone();
        }
        oldRange = this.getSelection().getRange();
        newRange = oldRange && new ve.Range(oldRange.start + (start || 0),oldRange.end + (end || 0));
        return this.clone(new ve.dm.LinearSelection(newRange));
    }
    ;
    ve.dm.SurfaceFragment.prototype.truncateLinearSelection = function(limit) {
        var range;
        if (!(this.selection instanceof ve.dm.LinearSelection)) {
            return this.clone();
        }
        range = this.getSelection().getRange();
        return this.clone(new ve.dm.LinearSelection(range.truncate(limit)));
    }
    ;
    ve.dm.SurfaceFragment.prototype.collapseToStart = function() {
        return this.clone(this.getSelection().collapseToStart());
    }
    ;
    ve.dm.SurfaceFragment.prototype.collapseToEnd = function() {
        return this.clone(this.getSelection().collapseToEnd());
    }
    ;
    ve.dm.SurfaceFragment.prototype.trimLinearSelection = function() {
        var oldRange, newRange;
        if (!(this.selection instanceof ve.dm.LinearSelection)) {
            return this.clone();
        }
        oldRange = this.getSelection().getRange();
        newRange = oldRange;
        if (this.getText().trim().length === 0) {
            newRange = new ve.Range(oldRange.start);
        } else {
            newRange = this.document.data.trimOuterSpaceFromRange(oldRange);
        }
        return this.clone(new ve.dm.LinearSelection(newRange));
    }
    ;
    ve.dm.SurfaceFragment.prototype.expandLinearSelection = function(scope, type) {
        var node, nodes, parent, newRange, oldRange;
        if (!(this.selection instanceof ve.dm.LinearSelection)) {
            return this.clone();
        }
        oldRange = this.getSelection().getRange();
        switch (scope || 'parent') {
        case 'word':
            if (!oldRange.isCollapsed()) {
                newRange = ve.Range.static.newCoveringRange([this.document.data.getWordRange(oldRange.start), this.document.data.getWordRange(oldRange.end)], oldRange.isBackwards());
            } else {
                newRange = this.document.data.getWordRange(oldRange.start);
            }
            break;
        case 'annotation':
            newRange = this.document.data.getAnnotatedRangeFromSelection(oldRange, type);
            if (oldRange.start > newRange.start || oldRange.end < newRange.end) {
                if (oldRange.from > oldRange.to) {
                    newRange = newRange.flip();
                }
            } else {
                newRange = oldRange;
            }
            break;
        case 'root':
            newRange = this.getDocument().getDocumentRange();
            break;
        case 'siblings':
            nodes = this.document.selectNodes(oldRange, 'siblings');
            if (nodes.length === 1) {
                newRange = nodes[0].node.getOuterRange();
            } else {
                newRange = new ve.Range(nodes[0].node.getOuterRange().start,nodes[nodes.length - 1].node.getOuterRange().end);
            }
            break;
        case 'closest':
            nodes = this.document.selectNodes(oldRange, 'siblings');
            if (nodes[0].nodeRange.equalsSelection(oldRange) && nodes[0].node instanceof type) {
                newRange = nodes[0].nodeOuterRange;
                break;
            }
            parent = nodes[0].node.getParent();
            while (parent && !(parent instanceof type)) {
                node = parent;
                parent = parent.getParent();
            }
            if (parent) {
                newRange = parent.getOuterRange();
            }
            break;
        case 'parent':
            node = this.document.selectNodes(oldRange, 'siblings')[0].node;
            parent = node.getParent();
            if (parent) {
                newRange = parent.getOuterRange();
            }
            break;
        default:
            throw new Error('Invalid scope argument: ' + scope);
        }
        return this.clone(newRange ? new ve.dm.LinearSelection(newRange) : new ve.dm.NullSelection());
    }
    ;
    ve.dm.SurfaceFragment.prototype.getData = function(deep) {
        var range = this.getSelection().getCoveringRange();
        if (!range) {
            return [];
        }
        return this.document.getData(range, deep);
    }
    ;
    ve.dm.SurfaceFragment.prototype.getText = function(maintainIndices) {
        var range = this.getSelection().getCoveringRange();
        if (!range) {
            return '';
        }
        return this.document.data.getText(maintainIndices, range);
    }
    ;
    ve.dm.SurfaceFragment.prototype.containsOnlyText = function() {
        var range = this.getSelection().getCoveringRange();
        if (!range) {
            return true;
        }
        return this.document.data.isPlainText(range, false, false, false, true);
    }
    ;
    ve.dm.SurfaceFragment.prototype.getAnnotations = function(all) {
        var i, l, ranges, rangeAnnotations, matchingAnnotations, selection = this.getSelection(), annotations = new ve.dm.AnnotationSet(this.getDocument().getStore());
        if (selection.isCollapsed()) {
            return this.surface.getInsertionAnnotations();
        } else {
            ranges = selection.getRanges(this.getDocument());
            for (i = 0,
            l = ranges.length; i < l; i++) {
                rangeAnnotations = this.getDocument().data.getAnnotationsFromRange(ranges[i], all);
                if (!i) {
                    annotations = rangeAnnotations;
                } else if (all) {
                    annotations.addSet(rangeAnnotations);
                } else {
                    matchingAnnotations = rangeAnnotations.getComparableAnnotationsFromSet(annotations);
                    if (matchingAnnotations.isEmpty()) {
                        annotations = matchingAnnotations;
                        break;
                    } else {
                        annotations = annotations.getComparableAnnotationsFromSet(rangeAnnotations);
                        annotations.addSet(matchingAnnotations);
                    }
                }
            }
            return annotations;
        }
    }
    ;
    ve.dm.SurfaceFragment.prototype.hasAnnotations = function() {
        var i, l, ranges = this.getSelection().getRanges(this.getDocument());
        for (i = 0,
        l = ranges.length; i < l; i++) {
            if (this.getDocument().data.hasAnnotationsInRange(ranges[i])) {
                return true;
            }
        }
        return false;
    }
    ;
    ve.dm.SurfaceFragment.prototype.getLeafNodes = function() {
        var range = this.getSelection().getCoveringRange();
        if (!range) {
            return [];
        }
        this.update();
        if (!this.leafNodes) {
            this.leafNodes = this.document.selectNodes(range, 'leaves');
        }
        return this.leafNodes;
    }
    ;
    ve.dm.SurfaceFragment.prototype.getSelectedLeafNodes = function() {
        var i, len, selectedLeafNodes = [], leafNodes = this.getLeafNodes();
        for (i = 0,
        len = leafNodes.length; i < len; i++) {
            if (len === 1 || !leafNodes[i].range || leafNodes[i].range.getLength()) {
                selectedLeafNodes.push(leafNodes[i].node);
            }
        }
        return selectedLeafNodes;
    }
    ;
    ve.dm.SurfaceFragment.prototype.getSelectedNode = function() {
        var surface = this.getSurface();
        this.update();
        return this.selection.equals(surface.getSelection()) ? surface.getSelectedNode() : surface.getSelectedNodeFromSelection(this.selection);
    }
    ;
    ve.dm.SurfaceFragment.prototype.getCoveredNodes = function() {
        var range = this.getSelection().getCoveringRange();
        if (!range) {
            return [];
        }
        return this.document.selectNodes(range, 'covered');
    }
    ;
    ve.dm.SurfaceFragment.prototype.getSiblingNodes = function() {
        var range = this.getSelection().getCoveringRange();
        if (!range) {
            return [];
        }
        return this.document.selectNodes(range, 'siblings');
    }
    ;
    ve.dm.SurfaceFragment.prototype.hasMatchingAncestor = function(type, attributes) {
        var i, len, nodes, cells, all, selection = this.getSelection();
        if (selection instanceof ve.dm.LinearSelection) {
            nodes = this.getSelectedLeafNodes();
            all = !!nodes.length;
            for (i = 0,
            len = nodes.length; i < len; i++) {
                if (!nodes[i].hasMatchingAncestor(type, attributes)) {
                    all = !1;
                    break;
                }
            }
        } else if (selection instanceof ve.dm.TableSelection) {
            cells = selection.getMatrixCells(this.getDocument());
            all = !0;
            for (i = cells.length - 1; i >= 0; i--) {
                if (!cells[i].node.matches(type, attributes)) {
                    all = !1;
                    break;
                }
            }
        }
        return all;
    }
    ;
    ve.dm.SurfaceFragment.prototype.clearPending = function() {
        this.pending = [];
    }
    ;
    ve.dm.SurfaceFragment.prototype.pushPending = function(promise) {
        this.pending.push(promise);
    }
    ;
    ve.dm.SurfaceFragment.prototype.getPending = function() {
        return ve.promiseAll(this.pending);
    }
    ;
    ve.dm.SurfaceFragment.prototype.select = function() {
        this.surface.setSelection(this.getSelection());
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.changeAttributes = function(attr, type) {
        var i, len, result, txs = [], covered = this.getCoveredNodes();
        for (i = 0,
        len = covered.length; i < len; i++) {
            result = covered[i];
            if (!result.node.isWrapped() || (type && result.node.getType() !== type) || (result.range && result.range.isCollapsed())) {
                continue;
            }
            txs.push(ve.dm.TransactionBuilder.static.newFromAttributeChanges(this.document, result.nodeOuterRange.start, attr));
        }
        if (txs.length) {
            this.change(txs);
        }
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.annotateContent = function(method, nameOrAnnotations, data) {
        var annotation, i, ilen, j, jlen, tx, range, annotations = new ve.dm.AnnotationSet(this.getDocument().getStore()), ranges = this.getSelection().getRanges(this.getDocument()), txs = [];
        if (nameOrAnnotations instanceof ve.dm.AnnotationSet) {
            annotations = nameOrAnnotations;
        } else if (nameOrAnnotations instanceof ve.dm.Annotation) {
            annotations.push(nameOrAnnotations);
        } else {
            annotation = ve.dm.annotationFactory.create(nameOrAnnotations, data);
            if (method === 'set') {
                annotations.push(annotation);
            } else if (method === 'clear') {
                for (i = 0,
                ilen = ranges.length; i < ilen; i++) {
                    annotations.addSet(this.document.data.getAnnotationsFromRange(ranges[i], true).getAnnotationsByName(annotation.name));
                }
            }
        }
        for (i = 0,
        ilen = ranges.length; i < ilen; i++) {
            range = ranges[i];
            if (!range.isCollapsed()) {
                for (j = 0,
                jlen = annotations.getLength(); j < jlen; j++) {
                    tx = ve.dm.TransactionBuilder.static.newFromAnnotation(this.document, range, method, annotations.get(j));
                    txs.push(tx);
                }
            } else {
                if (method === 'set') {
                    this.surface.addInsertionAnnotations(annotations);
                } else if (method === 'clear') {
                    this.surface.removeInsertionAnnotations(annotations);
                }
            }
        }
        this.change(txs);
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.insertContent = function(content, annotate) {
        var i, l, lines, annotations, tx, offset, newRange, range = this.getSelection().getCoveringRange(), doc = this.getDocument();
        if (!range) {
            return this;
        }
        if (!range.isCollapsed()) {
            if (annotate) {
                annotations = this.getAnnotations();
            }
            this.removeContent();
        }
        offset = range.start;
        if (typeof content === 'string') {
            lines = content.split(/[\r\n]+/);
            if (lines.length > 1) {
                content = [];
                for (i = 0,
                l = lines.length; i < l; i++) {
                    if (lines[i].length) {
                        content.push({
                            type: 'paragraph'
                        });
                        ve.batchPush(content, lines[i].split(''));
                        content.push({
                            type: '/paragraph'
                        });
                    }
                }
            } else {
                content = content.split('');
            }
        }
        if (content.length) {
            if (annotate && !annotations) {
                annotations = doc.data.getAnnotationsFromOffset(offset === 0 ? 0 : offset - 1);
            }
            if (annotations && annotations.getLength() > 0) {
                ve.dm.Document.static.addAnnotationsToData(content, annotations, true, doc.store);
            }
            tx = ve.dm.TransactionBuilder.static.newFromInsertion(doc, offset, content);
            newRange = tx.getModifiedRange(doc);
            this.change(tx, newRange ? new ve.dm.LinearSelection(newRange) : new ve.dm.NullSelection());
        }
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.insertHtml = function(html, importRules) {
        this.insertDocument(this.getDocument().newFromHtml(html, importRules));
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.insertDocument = function(newDoc, newDocRange, annotate) {
        var tx, newRange, annotations, offset, annotatedData, annotatedDoc, range = this.getSelection().getCoveringRange(), doc = this.getDocument();
        if (!range) {
            return this;
        }
        if (!range.isCollapsed()) {
            if (annotate) {
                annotations = this.getAnnotations();
            }
            this.removeContent();
        }
        offset = range.start;
        if (annotate && !annotations) {
            annotations = doc.data.getAnnotationsFromOffset(offset === 0 ? 0 : offset - 1);
        }
        if (!annotations || annotations.getLength() === 0) {
            annotatedDoc = newDoc;
        } else {
            annotatedData = newDoc.data.slice();
            ve.dm.Document.static.addAnnotationsToData(annotatedData, annotations, true, newDoc.store, true);
            annotatedDoc = newDoc.cloneWithData(annotatedData);
        }
        tx = ve.dm.TransactionBuilder.static.newFromDocumentInsertion(doc, offset, annotatedDoc, newDocRange);
        if (!tx.isNoOp()) {
            newRange = tx.getModifiedRange(doc);
            this.change(tx, newRange ? new ve.dm.LinearSelection(newRange) : new ve.dm.NullSelection());
        }
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.removeContent = function() {
        var range = this.getSelection().getCoveringRange();
        if (!range) {
            return this;
        }
        if (!range.isCollapsed()) {
            this.change(ve.dm.TransactionBuilder.static.newFromRemoval(this.document, range));
        }
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.delete = function(directionAfterDelete) {
        var rangeAfterRemove, tx, startNode, endNode, endNodeData, nodeToDelete, nearestOffset, rangeToRemove = this.getSelection().getCoveringRange();
        if (!rangeToRemove || rangeToRemove.isCollapsed()) {
            return this;
        }
        tx = ve.dm.TransactionBuilder.static.newFromRemoval(this.document, rangeToRemove);
        this.change(tx);
        rangeAfterRemove = tx.translateRange(rangeToRemove);
        if (!rangeAfterRemove.isCollapsed() && (endNode = this.document.getBranchNodeFromOffset(rangeAfterRemove.end, false)) && endNode.getRange().start >= rangeAfterRemove.end) {
            startNode = this.document.getBranchNodeFromOffset(rangeAfterRemove.start, false);
            if (startNode.getRange().isCollapsed()) {
                while (true) {
                    tx = ve.dm.TransactionBuilder.static.newFromRemoval(this.document, startNode.getOuterRange());
                    startNode = startNode.getParent();
                    this.change(tx);
                    if (!(startNode && startNode.children.length === 0 && (startNode.hasSlugAtOffset(startNode.getRange().start) || startNode instanceof ve.dm.DefinitionListNode || startNode instanceof ve.dm.ListNode) && startNode.canHaveChildrenNotContent())) {
                        break;
                    }
                    rangeAfterRemove = tx.translateRange(rangeAfterRemove);
                }
            } else {
                endNodeData = this.document.getData(endNode.getRange());
                nodeToDelete = endNode;
                nodeToDelete.traverseUpstream(function(node) {
                    var parent = node.getParent();
                    if (parent.children.length === 1) {
                        nodeToDelete = parent;
                        return true;
                    } else {
                        return false;
                    }
                });
                tx = ve.dm.TransactionBuilder.static.newFromRemoval(this.document, nodeToDelete.getOuterRange());
                if (!tx.isNoOp()) {
                    this.change(tx);
                    this.change(ve.dm.TransactionBuilder.static.newFromInsertion(this.document, rangeAfterRemove.start, endNodeData));
                }
            }
        }
        nearestOffset = this.document.data.getNearestContentOffset(rangeAfterRemove.start, directionAfterDelete || -1);
        if (nearestOffset > -1) {
            rangeAfterRemove = new ve.Range(nearestOffset);
        } else {
            rangeAfterRemove = new ve.Range(rangeAfterRemove.start);
        }
        this.change([], new ve.dm.LinearSelection(rangeAfterRemove));
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.convertNodes = function(type, attr) {
        var range = this.getSelection().getCoveringRange();
        if (!range) {
            return this;
        }
        this.change(ve.dm.TransactionBuilder.static.newFromContentBranchConversion(this.document, range, type, attr));
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.wrapNodes = function(wrapper) {
        var range = this.getSelection().getCoveringRange();
        if (!range) {
            return this;
        }
        if (!Array.isArray(wrapper)) {
            wrapper = [wrapper];
        }
        this.change(ve.dm.TransactionBuilder.static.newFromWrap(this.document, range, [], [], [], wrapper));
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.unwrapNodes = function(outerDepth, innerDepth) {
        var i, range = this.getSelection().getCoveringRange(), innerUnwrapper = [], outerUnwrapper = [];
        if (!range) {
            return this;
        }
        if (range.getLength() < innerDepth * 2) {
            throw new Error('cannot unwrap by greater depth than maximum theoretical depth of selection');
        }
        for (i = 0; i < innerDepth; i++) {
            innerUnwrapper.push(this.document.data.getData(range.start + i));
        }
        for (i = outerDepth; i > 0; i--) {
            outerUnwrapper.push(this.document.data.getData(range.start - i));
        }
        this.change(ve.dm.TransactionBuilder.static.newFromWrap(this.document, range, outerUnwrapper, [], innerUnwrapper, []));
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.rewrapNodes = function(depth, wrapper) {
        var i, range = this.getSelection().getCoveringRange(), unwrapper = [];
        if (!range) {
            return this;
        }
        if (!Array.isArray(wrapper)) {
            wrapper = [wrapper];
        }
        if (range.getLength() < depth * 2) {
            throw new Error('cannot unwrap by greater depth than maximum theoretical depth of selection');
        }
        for (i = 0; i < depth; i++) {
            unwrapper.push(this.document.data.getData(range.start + i));
        }
        this.change(ve.dm.TransactionBuilder.static.newFromWrap(this.document, range, [], [], unwrapper, wrapper));
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.wrapAllNodes = function(wrapOuter, wrapEach) {
        var range = this.getSelection().getCoveringRange();
        if (!range) {
            return this;
        }
        if (!Array.isArray(wrapOuter)) {
            wrapOuter = [wrapOuter];
        }
        wrapEach = wrapEach || [];
        if (!Array.isArray(wrapEach)) {
            wrapEach = [wrapEach];
        }
        this.change(ve.dm.TransactionBuilder.static.newFromWrap(this.document, range, [], wrapOuter, [], wrapEach));
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.rewrapAllNodes = function(depth, wrapper) {
        var i, innerRange, range = this.getSelection().getCoveringRange(), unwrapper = [];
        if (!range) {
            return this;
        }
        innerRange = new ve.Range(range.start + depth,range.end - depth);
        if (!Array.isArray(wrapper)) {
            wrapper = [wrapper];
        }
        if (range.getLength() < depth * 2) {
            throw new Error('cannot unwrap by greater depth than maximum theoretical depth of selection');
        }
        for (i = 0; i < depth; i++) {
            unwrapper.push(this.document.data.getData(range.start + i));
        }
        this.change(ve.dm.TransactionBuilder.static.newFromWrap(this.document, innerRange, unwrapper, wrapper, [], []));
        return this;
    }
    ;
    ve.dm.SurfaceFragment.prototype.isolateAndUnwrap = function(isolateForType) {
        var nodes, startSplitNode, endSplitNode, startOffset, endOffset, oldExclude, allowedParents, insertions = [], outerDepth = 0, factory = ve.dm.nodeFactory, startSplitRequired = !1, endSplitRequired = !1, startSplitNodes = [], endSplitNodes = [], fragment = this;
        function createSplits(splitNodes, insertBefore) {
            var i, length, adjustment = 0, data = [];
            for (i = 0,
            length = splitNodes.length; i < length; i++) {
                data.unshift({
                    type: '/' + splitNodes[i].type
                });
                data.push(splitNodes[i].getClonedElement());
                if (insertBefore) {
                    adjustment += 2;
                }
            }
            insertions.push({
                offset: insertBefore ? startOffset : endOffset,
                data: data
            });
            startOffset += adjustment;
            endOffset += adjustment;
        }
        if (!(this.selection instanceof ve.dm.LinearSelection)) {
            return this;
        }
        allowedParents = factory.getSuggestedParentNodeTypes(isolateForType);
        nodes = this.getSiblingNodes();
        startSplitNode = nodes[0].node;
        startOffset = startSplitNode.getOuterRange().start;
        if (allowedParents !== null) {
            while (allowedParents.indexOf(startSplitNode.getParent().type) === -1) {
                if (startSplitNode.getParent().indexOf(startSplitNode) > 0) {
                    startSplitRequired = !0;
                }
                startSplitNode = startSplitNode.getParent();
                if (startSplitRequired) {
                    startSplitNodes.unshift(startSplitNode);
                } else {
                    startOffset = startSplitNode.getOuterRange().start;
                }
                outerDepth++;
            }
        }
        endSplitNode = nodes[nodes.length - 1].node;
        endOffset = endSplitNode.getOuterRange().end;
        if (allowedParents !== null) {
            while (allowedParents.indexOf(endSplitNode.getParent().type) === -1) {
                if (endSplitNode.getParent().indexOf(endSplitNode) < endSplitNode.getParent().getChildren().length - 1) {
                    endSplitRequired = !0;
                }
                endSplitNode = endSplitNode.getParent();
                if (endSplitRequired) {
                    endSplitNodes.unshift(endSplitNode);
                } else {
                    endOffset = endSplitNode.getOuterRange().end;
                }
            }
        }
        oldExclude = this.willExcludeInsertions();
        this.setExcludeInsertions(true);
        if (startSplitRequired) {
            createSplits(startSplitNodes, true);
        }
        if (endSplitRequired) {
            createSplits(endSplitNodes, false);
        }
        insertions.forEach(function(insertion) {
            fragment.change(ve.dm.TransactionBuilder.static.newFromInsertion(fragment.getDocument(), insertion.offset, insertion.data));
        });
        this.setExcludeInsertions(oldExclude);
        this.unwrapNodes(outerDepth, 0);
        return this;
    }
    ;
    ve.dm.SourceSurfaceFragment = function VeDmSourceSurfaceFragment() {
        ve.dm.SourceSurfaceFragment.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.SourceSurfaceFragment, ve.dm.SurfaceFragment);
    ve.dm.SourceSurfaceFragment.prototype.annotateContent = function() {
        var tempFragment, tempSurfaceModel, args = arguments, fragment = this, text = this.getText(true);
        this.pushPending(this.convertFromSource(text).then(function(selectionDocument) {
            tempSurfaceModel = new ve.dm.Surface(selectionDocument);
            tempFragment = tempSurfaceModel.getLinearFragment(selectionDocument.getDocumentRange());
            tempFragment.annotateContent.apply(tempFragment, args);
            fragment.clearPending();
            fragment.insertDocument(tempFragment.getDocument());
            return fragment.getPending();
        }));
        return this;
    }
    ;
    ve.dm.SourceSurfaceFragment.prototype.getAnnotations = function() {
        return new ve.dm.AnnotationSet(this.getDocument().getStore());
    }
    ;
    ve.dm.SourceSurfaceFragment.prototype.convertNodes = function() {
        var tempFragment, tempSurfaceModel, args = arguments, fragment = this, text = this.getText(true);
        this.pushPending(this.convertFromSource(text).then(function(selectionDocument) {
            tempSurfaceModel = new ve.dm.Surface(selectionDocument);
            tempFragment = tempSurfaceModel.getLinearFragment(selectionDocument.getDocumentRange());
            tempFragment.convertNodes.apply(tempFragment, args);
            fragment.clearPending();
            fragment.insertDocument(tempFragment.getDocument());
            return fragment.getPending();
        }));
        return this;
    }
    ;
    ve.dm.SourceSurfaceFragment.prototype.insertContent = function(content, annotate) {
        var data;
        if (typeof content !== 'string') {
            data = new ve.dm.ElementLinearData(new ve.dm.HashValueStore(),content);
            if (!data.isPlainText(null, false, ['paragraph'], annotate)) {
                this.insertDocument(new ve.dm.Document(content.concat([{
                    type: 'internalList'
                }, {
                    type: '/internalList'
                }])));
                return this;
            }
        } else {
            content = ve.dm.sourceConverter.getDataFromSourceText(content, true);
        }
        return ve.dm.SourceSurfaceFragment.super.prototype.insertContent.call(this, content);
    }
    ;
    ve.dm.SourceSurfaceFragment.prototype.insertDocument = function(doc, newDocRange, annotate) {
        var data, i, l, range = this.getSelection().getCoveringRange(), fragment = this;
        if (!range) {
            return this;
        }
        if (newDocRange) {
            doc = doc.shallowCloneFromRange(newDocRange);
            newDocRange = doc.originalRange;
        }
        if (doc.data.isPlainText(newDocRange, false, ['paragraph'], annotate)) {
            data = doc.data.getDataSlice(newDocRange);
            for (i = 0,
            l = data.length; i < l; i++) {
                if (Array.isArray(data[i])) {
                    data[i] = data[i][0];
                }
                if (data[i] === '\r') {
                    data.splice(i, 1);
                    i--;
                    l--;
                } else if (data[i] === '\n') {
                    data.splice(i, 1, {
                        type: '/paragraph'
                    }, {
                        type: 'paragraph'
                    });
                    i++;
                    l++;
                } else if (data[i] === '\u00a0') {
                    data[i] = ' ';
                }
            }
            return ve.dm.SourceSurfaceFragment.super.prototype.insertContent.call(this, data);
        }
        this.pushPending(this.convertToSource(doc).then(function(source) {
            fragment.insertContent(source.trim());
        }, function() {
            ve.error('Failed to convert document', arguments);
            return ve.createDeferred().reject().promise();
        }));
        return this;
    }
    ;
    ve.dm.SourceSurfaceFragment.prototype.wrapAllNodes = function(wrapOuter, wrapEach) {
        var i, node, nodes, content, range = this.getSelection().getCoveringRange();
        if (!range) {
            return this;
        }
        function getOpening(element) {
            element.internal = {
                whitespace: ['\n', '\n', '\n', '\n']
            };
            return element;
        }
        function getClosing(element) {
            return {
                type: '/' + element.type
            };
        }
        if (!Array.isArray(wrapOuter)) {
            wrapOuter = [wrapOuter];
        }
        wrapEach = wrapEach || [];
        if (!Array.isArray(wrapEach)) {
            wrapEach = [wrapEach];
        }
        nodes = this.getSelectedLeafNodes();
        content = wrapOuter.map(getOpening);
        for (i = 0; i < nodes.length; i++) {
            node = nodes[i];
            content = content.concat(wrapEach.map(getOpening)).concat(this.getSurface().getLinearFragment(node.getRange()).getText().split('')).concat(wrapEach.reverse().map(getClosing));
        }
        content = content.concat(wrapOuter.reverse().map(getClosing));
        this.insertContent(content);
        return this;
    }
    ;
    ve.dm.SourceSurfaceFragment.prototype.convertToSource = function(doc) {
        if (!doc.data.hasContent()) {
            return ve.createDeferred().resolve('').promise();
        } else {
            return ve.createDeferred().resolve(ve.properInnerHtml(ve.dm.converter.getDomFromModel(doc).body)).promise();
        }
    }
    ;
    ve.dm.SourceSurfaceFragment.prototype.convertFromSource = function(source) {
        var lang = this.getDocument().getLang()
          , dir = this.getDocument().getDir();
        if (!source) {
            return ve.createDeferred().resolve(new ve.dm.Document([{
                type: 'paragraph',
                internal: {
                    generated: 'wrapper'
                }
            }, {
                type: '/paragraph'
            }, {
                type: 'internalList'
            }, {
                type: '/internalList'
            }],null,null,null,null,lang,dir)).promise();
        } else {
            return ve.createDeferred().resolve(ve.dm.converter.getModelFromDom(ve.createDocumentFromHtml(source, {
                lang: lang,
                dir: dir
            }))).promise();
        }
    }
    ;
    ve.dm.DataString = function VeDmDataString(data) {
        this.data = data;
    }
    ;
    OO.inheritClass(ve.dm.DataString, unicodeJS.TextString);
    ve.dm.DataString.prototype.read = function(position) {
        var dataAt = this.data[position];
        if (dataAt !== undefined && dataAt.type === undefined) {
            return typeof dataAt === 'string' ? dataAt : dataAt[0];
        } else {
            return null;
        }
    }
    ;
    ve.dm.Document = function VeDmDocument(data, htmlDocument, parentDocument, internalList, innerWhitespace, lang, dir, originalDocument, sourceMode) {
        var doc, root;
        ve.dm.Document.super.call(this, new ve.dm.DocumentNode());
        doc = parentDocument || this;
        root = this.documentNode;
        this.lang = lang || 'en';
        this.dir = dir || 'ltr';
        this.sourceMode = !!sourceMode;
        this.documentNode.setRoot(root);
        this.documentNode.setDocument(doc);
        this.internalList = internalList ? internalList.clone(this) : new ve.dm.InternalList(this);
        this.innerWhitespace = innerWhitespace ? ve.copy(innerWhitespace) : new Array(2);
        this.parentDocument = parentDocument || null;
        this.originalDocument = originalDocument || null;
        this.nodesByType = {};
        this.origInternalListLength = null;
        this.branchNodeFromOffsetCache = [];
        if (data instanceof ve.dm.ElementLinearData) {
            this.data = data;
        } else if (data instanceof ve.dm.FlatLinearData) {
            this.data = new ve.dm.ElementLinearData(data.getStore(),data.getData());
        } else {
            this.data = new ve.dm.ElementLinearData(new ve.dm.HashValueStore(),Array.isArray(data) ? data : []);
        }
        this.store = this.data.getStore();
        this.completeHistory = new ve.dm.Change();
        this.completeHistory.store = this.store;
        if (this.store.getLength() > 0) {
            this.completeHistory.transactions.push(new ve.dm.Transaction([{
                type: 'retain',
                length: this.data.data.length
            }]));
            this.completeHistory.storeLengthAtTransaction.push(this.store.getLength());
        }
        this.htmlDocument = htmlDocument || ve.createDocumentFromHtml('');
    }
    ;
    OO.inheritClass(ve.dm.Document, ve.Document);
    ve.dm.Document.static.addAnnotationsToData = function(data, annotationSet, replaceComparable, store, prepend) {
        var i, length, allowedAnnotations, existingAnnotations, newAnnotationSet, ignoreChildrenDepth = 0, offset = prepend ? 0 : undefined;
        if (annotationSet.isEmpty()) {
            return;
        }
        if (store) {
            store.merge(annotationSet.getStore());
        } else {
            store = annotationSet.getStore();
        }
        if (!(data instanceof ve.dm.ElementLinearData)) {
            data = new ve.dm.ElementLinearData(store,data);
        }
        for (i = 0,
        length = data.getLength(); i < length; i++) {
            if (data.isElementData(i) && ve.dm.nodeFactory.shouldIgnoreChildren(data.getType(i))) {
                ignoreChildrenDepth += data.isOpenElementData(i) ? 1 : -1;
            }
            if (ignoreChildrenDepth) {
                continue;
            }
            allowedAnnotations = annotationSet.filter(function(ann) {
                return data.canTakeAnnotationAtOffset(i, ann, true);
            });
            existingAnnotations = data.getAnnotationsFromOffset(i, true);
            if (!existingAnnotations.isEmpty()) {
                newAnnotationSet = existingAnnotations;
                if (replaceComparable) {
                    newAnnotationSet = newAnnotationSet.withoutComparableSet(allowedAnnotations);
                }
                newAnnotationSet.addSet(allowedAnnotations, offset);
            } else {
                newAnnotationSet = allowedAnnotations;
            }
            data.setAnnotationsAtOffset(i, newAnnotationSet);
        }
    }
    ;
    ve.dm.Document.static.newBlankDocument = function(paragraphType) {
        var paragraph = {
            type: 'paragraph'
        };
        paragraphType = paragraphType === undefined ? 'empty' : paragraphType;
        if (paragraphType) {
            ve.setProp(paragraph, 'internal', 'generated', paragraphType);
        }
        return new ve.dm.Document([paragraph, {
            type: '/paragraph'
        }, {
            type: 'internalList'
        }, {
            type: '/internalList'
        }]);
    }
    ;
    ve.dm.Document.prototype.getDocumentNode = function() {
        if (!this.documentNode.length && !this.documentNode.getDocument().buildingNodeTree) {
            this.buildNodeTree();
        }
        return this.documentNode;
    }
    ;
    ve.dm.Document.prototype.getDocumentRange = function() {
        return new ve.Range(0,this.getInternalList().getListNode().getOuterRange().start);
    }
    ;
    ve.dm.Document.prototype.buildNodeTree = function() {
        var i, len, node, children, currentStack, parentStack, nodeStack, currentNode, doc, textLength = 0, inTextNode = !1;
        currentStack = [];
        parentStack = [this.documentNode];
        nodeStack = [parentStack, currentStack];
        currentNode = this.documentNode;
        doc = this.documentNode.getDocument();
        for (i = 0,
        len = this.data.getLength(); i < len; i++) {
            if (!this.data.isElementData(i)) {
                if (!inTextNode) {
                    node = new ve.dm.TextNode();
                    currentStack.push(node);
                    currentNode = node;
                    inTextNode = !0;
                }
                textLength++;
            } else {
                if (inTextNode) {
                    currentNode.setLength(textLength);
                    currentNode = parentStack[parentStack.length - 1];
                    inTextNode = !1;
                    textLength = 0;
                }
                if (this.data.isOpenElementData(i)) {
                    node = ve.dm.nodeFactory.createFromElement(this.data.getData(i));
                    currentStack.push(node);
                    if (ve.dm.nodeFactory.canNodeHaveChildren(node.getType())) {
                        parentStack = currentStack;
                        currentStack = [];
                        nodeStack.push(currentStack);
                        currentNode = node;
                    } else {
                        if (!this.data.isCloseElementData(i + 1) || this.data.getType(i + 1) !== this.data.getType(i)) {
                            throw new Error('Opening element for node that cannot have children must be followed by closing element');
                        }
                        i++;
                    }
                } else {
                    if (this.data.getType(i) !== currentNode.getType()) {
                        throw new Error('Expected closing for ' + currentNode.getType() + ' but got closing for ' + this.data.getType(i));
                    }
                    children = nodeStack.pop();
                    currentStack = parentStack;
                    parentStack = nodeStack[nodeStack.length - 2];
                    if (!parentStack) {
                        throw new Error('Unbalanced input passed to document');
                    }
                    ve.batchSplice(currentNode, 0, 0, children);
                    currentNode = parentStack[parentStack.length - 1];
                }
            }
        }
        if (inTextNode) {
            currentNode.setLength(textLength);
        }
        doc.buildingNodeTree = !0;
        if (nodeStack.length > 2) {
            throw new Error('Unbalanced input passed to document');
        }
        ve.batchSplice(this.documentNode, 0, 0, currentStack);
        this.updateNodesByType([this.documentNode], [this.documentNode]);
        doc.buildingNodeTree = !1;
    }
    ;
    ve.dm.Document.prototype.getLength = function() {
        return this.data.getLength();
    }
    ;
    ve.dm.Document.prototype.commit = function(transaction, isStaging) {
        if (transaction.hasBeenApplied()) {
            throw new Error('Cannot commit a transaction that has already been committed');
        }
        this.emit('precommit', transaction);
        this.branchNodeFromOffsetCache = [];
        new ve.dm.TransactionProcessor(this,transaction,isStaging).process();
        this.completeHistory.pushTransaction(transaction, this.store.getLength());
        this.emit('transact', transaction);
    }
    ;
    ve.dm.Document.prototype.getData = function(range, deep) {
        return this.data.getDataSlice(range, deep);
    }
    ;
    ve.dm.Document.prototype.getMetadata = function(range) {
        var data = []
          , documentNode = this.getDocumentNode();
        if (arguments.length > 1) {
            throw new Error('Argument "deep" is no longer supported');
        }
        if (!range) {
            range = new ve.Range(0,documentNode.length);
        }
        documentNode.traverse(function(node) {
            var offset;
            if (node instanceof ve.dm.MetaItem) {
                offset = node.getOffset();
                if (range.start <= offset && offset < range.end) {
                    data[offset - range.start] = node;
                }
            }
        });
        data.length = range.end - range.start;
        return data;
    }
    ;
    ve.dm.Document.prototype.getHtmlDocument = function() {
        return this.htmlDocument;
    }
    ;
    ve.dm.Document.prototype.getOriginalDocument = function() {
        return this.originalDocument;
    }
    ;
    ve.dm.Document.prototype.getStore = function() {
        return this.store;
    }
    ;
    ve.dm.Document.prototype.getInternalList = function() {
        return this.internalList;
    }
    ;
    ve.dm.Document.prototype.getInnerWhitespace = function() {
        return this.innerWhitespace;
    }
    ;
    ve.dm.Document.prototype.shallowCloneFromSelection = function(selection) {
        var i, l, linearData, ranges, tableRange, data = [];
        if (selection instanceof ve.dm.LinearSelection) {
            return this.shallowCloneFromRange(selection.getRange());
        } else if (selection instanceof ve.dm.TableSelection) {
            ranges = selection.getTableSliceRanges(this);
            for (i = 0,
            l = ranges.length; i < l; i++) {
                data = data.concat(this.data.slice(ranges[i].start, ranges[i].end));
            }
            linearData = new ve.dm.ElementLinearData(this.getStore(),data);
            tableRange = new ve.Range(0,data.length);
            ve.batchSplice(linearData.data, linearData.getLength(), 0, this.getData(this.getInternalList().getListNode().getOuterRange(), true));
            return new ve.dm.TableSlice(linearData,this.getHtmlDocument(),undefined,this.getInternalList(),tableRange,this);
        } else {
            return this.shallowCloneFromRange(new ve.Range(0));
        }
    }
    ;
    ve.dm.Document.prototype.shallowCloneFromRange = function(range) {
        var i, first, last, firstNode, lastNode, linearData, slice, originalRange, balancedRange, balancedNodes, needsContext, contextElement, isContent, startNode, endNode, selection, balanceOpenings = [], balanceClosings = [], contextOpenings = [], contextClosings = [];
        if (!range) {
            linearData = this.data.sliceObject();
            originalRange = balancedRange = this.getDocumentRange();
        } else {
            startNode = this.getBranchNodeFromOffset(range.start);
            endNode = this.getBranchNodeFromOffset(range.end);
            selection = this.selectNodes(range, 'siblings');
            while (selection[0] && selection[0].range && selection[0].range.isCollapsed() && !selection[0].node.isWrapped()) {
                selection.shift();
            }
            i = selection.length - 1;
            while (selection[i] && selection[i].range && selection[i].range.isCollapsed() && !selection[i].node.isWrapped()) {
                selection.pop();
                i--;
            }
            if (selection.length === 0 || range.isCollapsed()) {
                linearData = new ve.dm.ElementLinearData(this.getStore(),[{
                    type: 'paragraph',
                    internal: {
                        generated: 'empty'
                    }
                }, {
                    type: 'paragraph'
                }]);
                originalRange = balancedRange = new ve.Range(1);
            } else if (startNode === endNode) {
                balancedNodes = selection;
            } else {
                first = selection[0];
                last = selection[selection.length - 1];
                firstNode = first.node;
                lastNode = last.node;
                while (!firstNode.isWrapped()) {
                    firstNode = firstNode.getParent();
                }
                while (!lastNode.isWrapped()) {
                    lastNode = lastNode.getParent();
                }
                if (first.range) {
                    while (true) {
                        while (!startNode.isWrapped()) {
                            startNode = startNode.getParent();
                        }
                        balanceOpenings.push(startNode.getClonedElement());
                        if (startNode === firstNode) {
                            break;
                        }
                        startNode = startNode.getParent();
                    }
                }
                if (last !== first && last.range) {
                    while (true) {
                        while (!endNode.isWrapped()) {
                            endNode = endNode.getParent();
                        }
                        balanceClosings.push({
                            type: '/' + endNode.getType()
                        });
                        if (endNode === lastNode) {
                            break;
                        }
                        endNode = endNode.getParent();
                    }
                }
                balancedNodes = this.selectNodes(new ve.Range(firstNode.getOuterRange().start,lastNode.getOuterRange().end), 'covered');
            }
            function nodeNeedsContext(node) {
                return node.getParentNodeTypes() !== null || node.isContent();
            }
            if (!balancedRange) {
                needsContext = !1;
                for (i = balancedNodes.length - 1; i >= 0; i--) {
                    if (nodeNeedsContext(balancedNodes[i].node)) {
                        needsContext = !0;
                        break;
                    }
                }
                if (needsContext) {
                    startNode = balancedNodes[0].node;
                    while (startNode.getParent() && nodeNeedsContext(startNode)) {
                        isContent = startNode.isContent();
                        startNode = startNode.getParent();
                        contextElement = startNode.getClonedElement();
                        if (isContent) {
                            ve.setProp(contextElement, 'internal', 'generated', 'wrapper');
                        }
                        contextOpenings.push(contextElement);
                        contextClosings.push({
                            type: '/' + contextElement.type
                        });
                    }
                }
                linearData = new ve.dm.ElementLinearData(this.getStore(),contextOpenings.reverse().concat(balanceOpenings.reverse()).concat(this.data.slice(range.start, range.end)).concat(balanceClosings).concat(contextClosings));
                originalRange = new ve.Range(contextOpenings.length + balanceOpenings.length,contextOpenings.length + balanceOpenings.length + range.getLength());
                balancedRange = new ve.Range(contextOpenings.length,contextOpenings.length + balanceOpenings.length + range.getLength() + balanceClosings.length);
            }
            ve.batchSplice(linearData.data, linearData.getLength(), 0, this.getData(this.getInternalList().getListNode().getOuterRange()));
        }
        slice = new ve.dm.DocumentSlice(linearData,this.getHtmlDocument(),undefined,this.getInternalList(),originalRange,balancedRange,this);
        return slice;
    }
    ;
    ve.dm.Document.prototype.cloneFromRange = function(range, detachedCopy, mode) {
        var listRange = this.getInternalList().getListNode().getOuterRange()
          , data = ve.copy(this.getFullData(range, mode || 'roundTrip'));
        if (range && (range.start > listRange.start || range.end < listRange.end)) {
            data = data.concat(this.getFullData(listRange));
        }
        return this.cloneWithData(data, true, detachedCopy);
    }
    ;
    ve.dm.Document.prototype.cloneWithData = function(data, copyInternalList, detachedCopy) {
        var newDoc;
        if (Array.isArray(data)) {
            data = new ve.dm.ElementLinearData(this.getStore().clone(),data);
        }
        newDoc = new this.constructor(data,this.getHtmlDocument(),undefined,copyInternalList ? this.getInternalList() : undefined,undefined,this.getLang(),this.getDir(),this);
        if (copyInternalList && !detachedCopy) {
            newDoc.origInternalListLength = this.internalList.getItemNodeCount();
        }
        return newDoc;
    }
    ;
    ve.dm.Document.prototype.getFullData = function(range, mode) {
        var i, j, jLen, item, metaItems, metaItem, offset, insertedMetaItems = [], insertions = {}, iLen = range ? range.end : this.data.getLength(), result = [];
        function stripMetaLoadInfo(item) {
            if (!item || !item.internal) {
                return item;
            }
            item = ve.cloneObject(item);
            item.internal = ve.cloneObject(item.internal);
            delete item.internal.changesSinceLoad;
            delete item.internal.metaItems;
            delete item.internal.loadMetaParentHash;
            delete item.internal.loadMetaParentOffset;
            if (Object.keys(item.internal).length === 0) {
                delete item.internal;
            }
            return item;
        }
        for (i = range ? range.start : 0; i < iLen; i++) {
            item = this.data.getData(i);
            if (ve.dm.LinearData.static.isOpenElementData(item) && ve.dm.nodeFactory.isMetaData(item.type) && (mode === 'noMetadata' || mode === 'roundTrip' && insertedMetaItems.indexOf(item) !== -1)) {
                i += 1;
                continue;
            }
            if (mode === 'roundTrip' && !ve.getProp(item, 'internal', 'changesSinceLoad')) {
                metaItems = ve.getProp(item, 'internal', 'metaItems') || [];
                for (j = 0,
                jLen = metaItems.length; j < jLen; j++) {
                    metaItem = metaItems[j];
                    offset = i + metaItem.internal.loadMetaParentOffset;
                    if (!insertions[offset]) {
                        insertions[offset] = [];
                    }
                    delete metaItem.internal.loadBranchNodeHash;
                    delete metaItem.internal.loadBranchNodeOffset;
                    if (Object.keys(metaItem.internal).length === 0) {
                        delete metaItem.internal;
                    }
                    insertions[offset].push(metaItem);
                    insertedMetaItems.push(metaItem);
                }
            } else if (mode === 'roundTrip') {
                metaItems = ve.getProp(item, 'internal', 'metaItems') || [];
                for (j = 0,
                jLen = metaItems.length; j < jLen; j++) {
                    metaItem = metaItems[j];
                    if (ve.dm.nodeFactory.isRemovableMetaData(metaItem.type)) {
                        insertedMetaItems.push(metaItem);
                    }
                }
            }
            result.push(stripMetaLoadInfo(item));
            if (mode === 'roundTrip' && insertions[i]) {
                for (j = 0,
                jLen = insertions[i].length; j < jLen; j++) {
                    metaItem = insertions[i][j];
                    result.push(stripMetaLoadInfo(metaItem));
                    result.push({
                        type: '/' + metaItem.type
                    });
                }
            }
        }
        return result;
    }
    ;
    ve.dm.Document.prototype.getSiblingWordBoundary = function(offset, direction) {
        var dataString = new ve.dm.DataString(this.getData());
        return unicodeJS.wordbreak.moveBreakOffset(direction, dataString, offset, true);
    }
    ;
    ve.dm.Document.prototype.getRelativeOffset = function(offset, direction, unit) {
        var relativeContentOffset, relativeStructuralOffset, newOffset, adjacentDataOffset, isFocusable, data = this.data;
        if (unit === 'word') {
            newOffset = this.getSiblingWordBoundary(offset, direction);
            if (offset === newOffset) {
                newOffset = this.getRelativeOffset(offset, direction, 'character');
            }
            return newOffset;
        } else {
            adjacentDataOffset = offset + (direction > 0 ? 0 : -1);
            if (data.isElementData(adjacentDataOffset) && ve.dm.nodeFactory.isNodeFocusable(data.getType(adjacentDataOffset))) {
                return offset + direction;
            }
            relativeContentOffset = data.getRelativeContentOffset(offset, direction);
            relativeStructuralOffset = data.getRelativeStructuralOffset(offset, direction, true);
            if ((relativeStructuralOffset - offset < 0 ? -1 : 1) !== direction) {
                relativeStructuralOffset = offset;
            } else {
                isFocusable = (relativeStructuralOffset - offset < 0 ? -1 : 1) === direction && data.isElementData(relativeStructuralOffset + direction) && ve.dm.nodeFactory.isNodeFocusable(data.getType(relativeStructuralOffset + direction));
            }
            if (isFocusable || this.hasSlugAtOffset(relativeStructuralOffset)) {
                if (isFocusable) {
                    relativeStructuralOffset += direction;
                }
                if (relativeContentOffset === offset || (relativeContentOffset - offset < 0 ? -1 : 1) !== direction) {
                    return relativeStructuralOffset;
                }
                return direction > 0 ? Math.min(relativeContentOffset, relativeStructuralOffset) : Math.max(relativeContentOffset, relativeStructuralOffset);
            } else {
                return direction > 0 ? Math.max(relativeContentOffset, offset) : Math.min(relativeContentOffset, offset);
            }
        }
    }
    ;
    ve.dm.Document.prototype.getRelativeRange = function(range, direction, unit, expand, limit) {
        var contentOrSlugOffset, focusableNode, newOffset, newRange, to = range.to;
        if (!range.isCollapsed() && !expand) {
            newOffset = direction > 0 ? range.end : range.start;
            if (this.data.isContentOffset(newOffset) || this.hasSlugAtOffset(newOffset)) {
                return new ve.Range(newOffset);
            } else {
                to = newOffset;
            }
        }
        contentOrSlugOffset = this.getRelativeOffset(to, direction, unit);
        focusableNode = this.getNearestFocusableNode(to, direction, contentOrSlugOffset);
        if (focusableNode) {
            newRange = focusableNode.getOuterRange(direction === -1);
        } else {
            newRange = new ve.Range(contentOrSlugOffset);
        }
        if (limit && !limit.containsRange(newRange)) {
            return range;
        }
        if (expand) {
            return new ve.Range(range.from,newRange.to);
        } else {
            return newRange;
        }
    }
    ;
    ve.dm.Document.prototype.getNearestFocusableNode = function(offset, direction, limit) {
        var coveredOffset;
        this.data.getRelativeOffset(offset, direction === 1 ? 0 : -1, function(index, limit) {
            if (index >= Math.max(offset, limit) || index < Math.min(offset, limit)) {
                return true;
            }
            if (this.isOpenElementData(index) && ve.dm.nodeFactory.isNodeFocusable(this.getType(index))) {
                coveredOffset = index + 1;
                return true;
            }
            if (this.isCloseElementData(index) && ve.dm.nodeFactory.isNodeFocusable(this.getType(index))) {
                coveredOffset = index;
                return true;
            }
        }, limit);
        if (coveredOffset) {
            return this.getDocumentNode().getNodeFromOffset(coveredOffset);
        } else {
            return null;
        }
    }
    ;
    ve.dm.Document.prototype.getNearestCursorOffset = function(offset, direction) {
        var contentOffset, structuralOffset, left, right;
        if (direction === 0) {
            left = this.getNearestCursorOffset(offset, -1);
            right = this.getNearestCursorOffset(offset, 1);
            if (right === -1) {
                return left;
            } else if (left === -1) {
                return right;
            }
            return offset - left < right - offset ? left : right;
        }
        direction = direction > 0 ? 1 : -1;
        if (this.data.isContentOffset(offset) || this.hasSlugAtOffset(offset)) {
            return offset;
        }
        contentOffset = this.data.getNearestContentOffset(offset, direction);
        structuralOffset = this.data.getNearestStructuralOffset(offset, direction, true);
        if (structuralOffset === -1 || !this.hasSlugAtOffset(structuralOffset)) {
            return contentOffset;
        } else if (contentOffset === -1) {
            return structuralOffset;
        }
        if (direction === 1) {
            if (contentOffset < offset) {
                return structuralOffset;
            } else {
                return Math.min(contentOffset, structuralOffset);
            }
        } else {
            if (contentOffset > offset) {
                return structuralOffset;
            } else {
                return Math.max(contentOffset, structuralOffset);
            }
        }
    }
    ;
    ve.dm.Document.prototype.getBranchNodeFromOffset = function(offset) {
        if (offset < 0 || offset > this.data.getLength()) {
            throw new Error('ve.dm.Document.getBranchNodeFromOffset(): offset ' + offset + ' is out of bounds');
        }
        if (!this.branchNodeFromOffsetCache[offset]) {
            this.branchNodeFromOffsetCache[offset] = ve.Document.prototype.getBranchNodeFromOffset.call(this, offset);
        }
        return this.branchNodeFromOffsetCache[offset];
    }
    ;
    ve.dm.Document.prototype.hasSlugAtOffset = function(offset) {
        var node;
        try {
            node = this.getBranchNodeFromOffset(offset);
        } catch (e) {}
        return node ? node.hasSlugAtOffset(offset) : !1;
    }
    ;
    ve.dm.Document.prototype.getDataFromNode = function(node) {
        var length = node.getLength()
          , offset = node.getOffset();
        if (offset >= 0) {
            if (node.isWrapped()) {
                offset++;
            }
            return this.data.slice(offset, offset + length);
        }
        return null;
    }
    ;
    ve.dm.Document.prototype.rebuildNodes = function(parent, index, numNodes, offset, newLength) {
        var data = this.data.sliceObject(offset, offset + newLength)
          , documentFragment = new ve.dm.Document(data,this.htmlDocument,this)
          , addedNodes = documentFragment.getDocumentNode().getChildren()
          , removedNodes = ve.batchSplice(parent, index, numNodes, addedNodes);
        this.updateNodesByType(addedNodes, removedNodes);
    }
    ;
    ve.dm.Document.prototype.rebuildTree = function() {
        var documentNode = this.getDocumentNode();
        this.rebuildNodes(documentNode, 0, documentNode.getChildren().length, 0, this.data.getLength());
    }
    ;
    ve.dm.Document.prototype.updateNodesByType = function(addedNodes, removedNodes) {
        var doc = this;
        function remove(node) {
            var type = node.getType()
              , nodes = doc.nodesByType[type] || []
              , index = nodes.indexOf(node);
            if (index !== -1) {
                nodes.splice(index, 1);
                if (!nodes.length) {
                    delete doc.nodesByType[type];
                }
            }
        }
        function add(node) {
            var type = node.getType()
              , nodes = doc.nodesByType[type] = doc.nodesByType[type] || [];
            nodes.push(node);
        }
        function traverse(nodes, action) {
            nodes.forEach(function(node) {
                if (node.hasChildren()) {
                    node.traverse(action);
                }
                action(node);
            });
        }
        traverse(removedNodes, remove);
        traverse(addedNodes, add);
    }
    ;
    ve.dm.Document.prototype.getNodesByType = function(type, sort) {
        var t, nodeType, nodes = [];
        if (!this.documentNode.length && !this.documentNode.getDocument().buildingNodeTree) {
            this.buildNodeTree();
        }
        if (type instanceof Function) {
            for (t in this.nodesByType) {
                nodeType = ve.dm.nodeFactory.lookup(t);
                if (nodeType === type || nodeType.prototype instanceof type) {
                    nodes = nodes.concat(this.getNodesByType(t));
                }
            }
        } else {
            nodes = this.nodesByType[type] || [];
        }
        if (sort) {
            nodes.sort(function(a, b) {
                return a.getOffset() - b.getOffset();
            });
        }
        return nodes;
    }
    ;
    ve.dm.Document.prototype.fixupInsertion = function(data, offset) {
        var newData = [], remove = 0, openingStack = [], closingStack = [], insertedDataOffset = 0, insertedDataLength = data.length, doc = this, parentNode, parentType, inTextNode, isFirstChild, childType, allowedParents, allowedChildren, parentsOK, childrenOK, suggestedParents, suggestedParentsOK, openings, closings, reopenElements, popped, insertion, i, j;
        function writeElement(element, index) {
            var expectedType;
            if (element.type !== undefined) {
                if (element.type.charAt(0) !== '/') {
                    if (openingStack.length === 0 && closingStack.length > 0 && closingStack[closingStack.length - 1].getType() === element.type) {
                        parentNode = closingStack.pop();
                    } else {
                        openingStack.push(element);
                    }
                    parentType = element.type;
                } else {
                    if (openingStack.length > 0) {
                        expectedType = openingStack.pop().type;
                    } else {
                        expectedType = parentNode.getType();
                        closingStack.push(parentNode);
                        parentNode = parentNode.getParent();
                        if (!parentNode) {
                            throw new Error('Inserted data is trying to close the root node ' + '(at index ' + index + ')');
                        }
                        parentType = expectedType;
                        if (element.type !== '/' + expectedType && (!ve.dm.nodeFactory.canNodeContainContent(element.type.slice(1)) || !ve.dm.nodeFactory.canNodeContainContent(expectedType))) {
                            throw new Error('Cannot adopt content from ' + element.type + ' nodes into ' + expectedType + ' nodes (at index ' + index + ')');
                        }
                    }
                }
            }
            newData.push(element);
        }
        function closeElement(childType) {
            var popped;
            closings.push({
                type: '/' + parentType
            });
            if (openingStack.length > 0) {
                popped = openingStack.pop();
                parentType = popped.type;
                reopenElements.push(ve.copy(popped));
            } else {
                if (!parentNode.getParent()) {
                    throw new Error('Cannot insert ' + childType + ' even after closing ' + 'all containing nodes (at index ' + i + ')');
                }
                closingStack.push(parentNode);
                reopenElements.push(parentNode.getClonedElement());
                parentNode = parentNode.getParent();
                parentType = parentNode.getType();
            }
        }
        parentNode = this.getBranchNodeFromOffset(offset);
        parentType = parentNode.getType();
        inTextNode = !1;
        isFirstChild = doc.data.isOpenElementData(offset - 1);
        for (i = 0; i < data.length; i++) {
            if (inTextNode && data[i].type !== undefined) {
                parentType = openingStack.length > 0 ? openingStack[openingStack.length - 1].type : parentNode.getType();
            }
            if (data[i].type === undefined || data[i].type.charAt(0) !== '/') {
                childType = data[i].type || 'text';
                openings = [];
                closings = [];
                reopenElements = [];
                if (ve.dm.nodeFactory.isNodeContent(childType) && !ve.dm.nodeFactory.canNodeContainContent(parentType)) {
                    childType = 'paragraph';
                    openings.unshift(ve.dm.nodeFactory.getDataElement(childType));
                }
                do {
                    allowedParents = ve.dm.nodeFactory.getParentNodeTypes(childType);
                    parentsOK = allowedParents === null || allowedParents.indexOf(parentType) !== -1;
                    if (!parentsOK) {
                        if (allowedParents.length === 0) {
                            throw new Error('Cannot insert ' + childType + ' because it ' + ' cannot have a parent (at index ' + i + ')');
                        }
                        childType = allowedParents[0];
                        openings.unshift(ve.dm.nodeFactory.getDataElement(childType));
                    }
                } while (!parentsOK);suggestedParents = ve.dm.nodeFactory.getSuggestedParentNodeTypes(childType);
                do {
                    suggestedParentsOK = suggestedParents === null || suggestedParents.indexOf(parentType) !== -1;
                    if (!suggestedParentsOK) {
                        closeElement(childType);
                    }
                } while (!suggestedParentsOK);do {
                    allowedChildren = ve.dm.nodeFactory.getChildNodeTypes(parentType);
                    childrenOK = allowedChildren === null || allowedChildren.indexOf(childType) !== -1;
                    childrenOK = childrenOK && !(!ve.dm.nodeFactory.isNodeContent(childType) && ve.dm.nodeFactory.canNodeContainContent(parentType));
                    if (!childrenOK) {
                        if (isFirstChild) {
                            insertion = this.fixupInsertion(data, offset - 1);
                            if (doc.data.isCloseElementData(offset) && !ve.dm.nodeFactory.isNodeInternal(parentType)) {
                                insertion.remove += 2;
                            }
                            return insertion;
                        }
                        closeElement(childType);
                    }
                } while (!childrenOK);for (j = 0; j < closings.length; j++) {
                    if (i === 0) {
                        insertedDataOffset++;
                    } else {
                        insertedDataLength++;
                    }
                    newData.push(closings[j]);
                }
                for (j = 0; j < openings.length; j++) {
                    if (i === 0) {
                        insertedDataOffset++;
                    } else {
                        insertedDataLength++;
                    }
                    writeElement(openings[j], i);
                }
                writeElement(data[i], i);
                if (data[i].type === undefined) {
                    inTextNode = !0;
                    if (openings.length > 0) {
                        parentType = childType;
                    }
                } else {
                    parentType = data[i].type;
                }
            } else {
                writeElement(data[i], i);
                parentType = openingStack.length > 0 ? openingStack[openingStack.length - 1].type : parentNode.getType();
            }
        }
        if (closingStack.length > 0 && doc.data.isCloseElementData(offset)) {
            return this.fixupInsertion(data, offset + 1);
        }
        if (inTextNode) {
            parentType = openingStack.length > 0 ? openingStack[openingStack.length - 1].type : parentNode.getType();
        }
        while (openingStack.length > 0) {
            popped = openingStack[openingStack.length - 1];
            writeElement({
                type: '/' + popped.type
            }, i);
        }
        while (closingStack.length > 0) {
            popped = closingStack[closingStack.length - 1];
            writeElement(popped.getClonedElement(), i);
        }
        return {
            offset: offset,
            data: newData,
            remove: remove,
            insertedDataOffset: insertedDataOffset !== 0 ? insertedDataOffset : undefined,
            insertedDataLength: insertedDataLength !== newData.length ? insertedDataLength : undefined
        };
    }
    ;
    ve.dm.Document.prototype.newFromHtml = function(html, importRules) {
        var htmlDoc = typeof html === 'string' ? ve.createDocumentFromHtml(html) : html
          , doc = ve.dm.converter.getModelFromDom(htmlDoc, {
            targetDoc: this.getHtmlDocument(),
            fromClipboard: !!importRules
        })
          , data = doc.data;
        if (importRules) {
            data.sanitize(importRules.external || {});
            data.sanitize(importRules.all || {});
        }
        data.remapInternalListKeys(this.getInternalList());
        doc.buildNodeTree();
        return doc;
    }
    ;
    ve.dm.Document.prototype.findText = function(query, options) {
        var j, l, qLen, match, offset, dataString, sensitivity, compare, matchText, data = this.data, documentRange = this.getDocumentRange(), ranges = [];
        options = options || {};
        if (query instanceof RegExp) {
            data.forEachRunOfContent(documentRange, function(offset, line) {
                query.lastIndex = 0;
                while ((match = query.exec(line)) !== null) {
                    matchText = match[0];
                    if (matchText.length === 0) {
                        query.lastIndex = match.index + 1;
                        continue;
                    }
                    if (matchText[matchText.length - 1] === '\uFFFC' && data.isOpenElementData(offset + match.index + matchText.length - 1) && data.isCloseElementData(offset + match.index + matchText.length)) {
                        matchText += '\uFFFC';
                        query.lastIndex += 1;
                    }
                    if (matchText[0] === '\uFFFC' && data.isOpenElementData(offset + match.index - 1) && data.isCloseElementData(offset + match.index)) {
                        query.lastIndex = match.index + 1;
                        continue;
                    }
                    ranges.push(new ve.Range(offset + match.index,offset + match.index + matchText.length));
                    if (!options.noOverlaps) {
                        query.lastIndex = match.index + 1;
                    }
                }
            });
        } else {
            qLen = query.length;
            if (ve.supportsIntl) {
                if (options.diacriticInsensitiveString) {
                    sensitivity = options.caseSensitiveString ? 'case' : 'base';
                } else {
                    sensitivity = options.caseSensitiveString ? 'variant' : 'accent';
                }
                compare = new Intl.Collator(this.lang,{
                    sensitivity: sensitivity
                }).compare;
            } else {
                compare = options.caseSensitiveString ? function(a, b) {
                    return a === b ? 0 : 1;
                }
                : function(a, b) {
                    return a.toLowerCase() === b.toLowerCase() ? 0 : 1;
                }
                ;
            }
            for (offset = 0,
            l = documentRange.getLength() - qLen; offset <= l; offset++) {
                j = 0;
                while (compare(data.getCharacterData(offset + j), query[j]) === 0) {
                    j++;
                    if (j === qLen) {
                        ranges.push(new ve.Range(offset,offset + qLen));
                        offset += options.noOverlaps ? qLen - 1 : 0;
                        break;
                    }
                }
            }
        }
        if (options.wholeWord) {
            dataString = new ve.dm.DataString(this.getData());
            ranges = ranges.filter(function(range) {
                return unicodeJS.wordbreak.isBreak(dataString, range.start) && unicodeJS.wordbreak.isBreak(dataString, range.end);
            });
        }
        return ranges;
    }
    ;
    ve.dm.Document.prototype.getCompleteHistoryLength = function() {
        return this.completeHistory.getLength();
    }
    ;
    ve.dm.Document.prototype.getCompleteHistorySince = function(start) {
        return this.completeHistory.transactions.slice(start);
    }
    ;
    ve.dm.Document.prototype.getChangeSince = function(start) {
        var change = this.completeHistory.mostRecent(start);
        change.selections = {};
        return change;
    }
    ;
    ve.dm.Document.prototype.getLang = function() {
        return this.lang;
    }
    ;
    ve.dm.Document.prototype.getDir = function() {
        return this.dir;
    }
    ;
    ve.dm.DocumentSlice = function VeDmDocumentSlice(data, htmlDocument, parentDocument, internalList, originalRange, balancedRange, originalDocument) {
        ve.dm.DocumentSlice.super.call(this, data, htmlDocument, parentDocument, internalList, undefined, undefined, undefined, originalDocument);
        this.originalRange = originalRange;
        this.balancedRange = balancedRange;
    }
    ;
    OO.inheritClass(ve.dm.DocumentSlice, ve.dm.Document);
    ve.dm.DocumentSlice.prototype.getOriginalData = function() {
        return this.getData(this.originalRange);
    }
    ;
    ve.dm.DocumentSlice.prototype.getBalancedData = function() {
        return this.getData(this.balancedRange);
    }
    ;
    ve.dm.TableSlice = function VeDmTableSlice(data, htmlDocument, parentDocument, internalList, tableRange, originalDocument) {
        ve.dm.TableSlice.super.call(this, data, htmlDocument, parentDocument, internalList, tableRange, tableRange, originalDocument);
    }
    ;
    OO.inheritClass(ve.dm.TableSlice, ve.dm.DocumentSlice);
    ve.dm.TableSlice.prototype.getTableNode = function() {
        if (!this.documentNode.length) {
            this.rebuildTree();
        }
        return this.documentNode.children[0];
    }
    ;
    ve.dm.LinearData = function VeDmLinearData(store, data) {
        this.store = store;
        this.data = data || [];
    }
    ;
    OO.initClass(ve.dm.LinearData);
    ve.dm.LinearData.static.getType = function(item) {
        return this.isCloseElementData(item) ? item.type.slice(1) : item.type;
    }
    ;
    ve.dm.LinearData.static.isElementData = function(item) {
        return item !== undefined && typeof item.type === 'string';
    }
    ;
    ve.dm.LinearData.static.isOpenElementData = function(item) {
        return this.isElementData(item) && item.type.charAt(0) !== '/';
    }
    ;
    ve.dm.LinearData.static.isCloseElementData = function(item) {
        return this.isElementData(item) && item.type.charAt(0) === '/';
    }
    ;
    ve.dm.LinearData.prototype.getData = function(offset) {
        return offset === undefined ? this.data : this.data[offset];
    }
    ;
    ve.dm.LinearData.prototype.setData = function(offset, value) {
        this.data[offset] = value;
    }
    ;
    ve.dm.LinearData.prototype.push = function() {
        return Array.prototype.push.apply(this.data, arguments);
    }
    ;
    ve.dm.LinearData.prototype.getLength = function() {
        return this.getData().length;
    }
    ;
    ve.dm.LinearData.prototype.getStore = function() {
        return this.store;
    }
    ;
    ve.dm.LinearData.prototype.slice = function() {
        return Array.prototype.slice.apply(this.data, arguments);
    }
    ;
    ve.dm.LinearData.prototype.sliceObject = function() {
        return new this.constructor(this.getStore(),this.slice.apply(this, arguments));
    }
    ;
    ve.dm.LinearData.prototype.splice = function() {
        return Array.prototype.splice.apply(this.data, arguments);
    }
    ;
    ve.dm.LinearData.prototype.spliceObject = function() {
        return new this.constructor(this.getStore(),this.splice.apply(this, arguments));
    }
    ;
    ve.dm.LinearData.prototype.batchSplice = function(offset, remove, data) {
        return ve.batchSplice(this.getData(), offset, remove, data);
    }
    ;
    ve.dm.LinearData.prototype.batchSpliceObject = function(offset, remove, data) {
        return new this.constructor(this.getStore(),this.batchSplice(offset, remove, data));
    }
    ;
    ve.dm.LinearData.prototype.getDataSlice = function(range, deep) {
        var end, data, start = 0, length = this.getLength();
        if (range !== undefined) {
            start = Math.max(0, Math.min(length, range.start));
            end = Math.max(0, Math.min(length, range.end));
        }
        data = end === undefined ? this.slice(start) : this.slice(start, end);
        return deep ? ve.copy(data) : data;
    }
    ;
    ve.dm.LinearData.prototype.clone = function() {
        return new this.constructor(this.getStore(),ve.copy(this.data));
    }
    ;
    ve.dm.HashValueStore = function VeDmHashValueStore(values) {
        this.hashStore = {};
        this.hashes = [];
        if (values) {
            this.hashAll(values);
        }
    }
    ;
    OO.initClass(ve.dm.HashValueStore);
    ve.dm.HashValueStore.static.deserialize = function(deserializeValue, data) {
        var hash, store = new ve.dm.HashValueStore();
        if (!data) {
            return store;
        }
        store.hashes = data.hashes.slice();
        store.hashStore = {};
        for (hash in data.hashStore) {
            store.hashStore[hash] = deserializeValue(data.hashStore[hash]);
        }
        return store;
    }
    ;
    ve.dm.HashValueStore.prototype.serialize = function(serializeValue) {
        var hash, serialized = {};
        for (hash in this.hashStore) {
            serialized[hash] = serializeValue(this.hashStore[hash]);
        }
        return this.getLength() ? {
            hashes: this.hashes.slice(),
            hashStore: serialized
        } : null;
    }
    ;
    ve.dm.HashValueStore.prototype.getLength = function() {
        return this.hashes.length;
    }
    ;
    ve.dm.HashValueStore.prototype.truncate = function(start) {
        var i, len, removedHashes = this.hashes.splice(start);
        for (i = 0,
        len = removedHashes.length; i < len; i++) {
            delete this.hashStore[removedHashes[i]];
        }
    }
    ;
    ve.dm.HashValueStore.prototype.slice = function(start, end) {
        var i, len, hash, sliced = new this.constructor();
        sliced.hashes = this.hashes.slice(start, end);
        for (i = 0,
        len = sliced.hashes.length; i < len; i++) {
            hash = sliced.hashes[i];
            sliced.hashStore[hash] = this.hashStore[hash];
        }
        return sliced;
    }
    ;
    ve.dm.HashValueStore.prototype.clone = function() {
        return this.slice();
    }
    ;
    ve.dm.HashValueStore.prototype.hash = function(value, stringified) {
        var hash = this.hashOfValue(value, stringified);
        if (!this.hashStore[hash]) {
            if (Array.isArray(value)) {
                this.hashStore[hash] = ve.copy(value);
            } else if (value !== null && typeof value === 'object') {
                this.hashStore[hash] = ve.cloneObject(value);
            } else {
                this.hashStore[hash] = value;
            }
            this.hashes.push(hash);
        }
        return hash;
    }
    ;
    ve.dm.HashValueStore.prototype.replaceHash = function(oldHash, value) {
        var newHash = this.hashOfValue(value);
        if (!Object.prototype.hasOwnProperty.call(this.hashStore, oldHash)) {
            throw new Error('Old hash not found: ' + oldHash);
        }
        delete this.hashStore[oldHash];
        if (this.hashStore[newHash] === undefined) {
            this.hashStore[newHash] = value;
            this.hashes.splice(this.hashes.indexOf(oldHash), 1, newHash);
        }
        return newHash;
    }
    ;
    ve.dm.HashValueStore.prototype.hashOfValue = function(value, stringified) {
        if (typeof stringified !== 'string') {
            stringified = OO.getHash(value);
        }
        return 'h' + SparkMD5.hash(stringified).slice(0, 16);
    }
    ;
    ve.dm.HashValueStore.prototype.hashAll = function(values) {
        var i, length, hashes = [];
        for (i = 0,
        length = values.length; i < length; i++) {
            hashes.push(this.hash(values[i]));
        }
        return hashes;
    }
    ;
    ve.dm.HashValueStore.prototype.value = function(hash) {
        return this.hashStore[hash];
    }
    ;
    ve.dm.HashValueStore.prototype.values = function(hashes) {
        var i, length, values = [];
        for (i = 0,
        length = hashes.length; i < length; i++) {
            values.push(this.value(hashes[i]));
        }
        return values;
    }
    ;
    ve.dm.HashValueStore.prototype.merge = function(other) {
        var i, len, hash;
        if (other === this) {
            return;
        }
        for (i = 0,
        len = other.hashes.length; i < len; i++) {
            hash = other.hashes[i];
            if (!Object.prototype.hasOwnProperty.call(this.hashStore, hash)) {
                this.hashStore[hash] = other.hashStore[hash];
                this.hashes.push(hash);
            }
        }
    }
    ;
    ve.dm.HashValueStore.prototype.difference = function(omit) {
        var i, len, hash, store = new this.constructor();
        if (omit instanceof ve.dm.HashValueStore) {
            omit = omit.hashStore;
        }
        for (i = 0,
        len = this.hashes.length; i < len; i++) {
            hash = this.hashes[i];
            if (!Object.prototype.hasOwnProperty.call(omit, hash)) {
                store.hashes.push(hash);
                store.hashStore[hash] = this.hashStore[hash];
            }
        }
        return store;
    }
    ;
    ve.dm.Converter = function VeDmConverter(modelRegistry, nodeFactory, annotationFactory) {
        this.modelRegistry = modelRegistry;
        this.nodeFactory = nodeFactory;
        this.annotationFactory = annotationFactory;
        this.doc = null;
        this.documentData = null;
        this.store = null;
        this.internalList = null;
        this.mode = null;
        this.fromClipboard = null;
        this.contextStack = null;
    }
    ;
    OO.initClass(ve.dm.Converter);
    ve.dm.Converter.static.computedAttributes = ['href', 'src'];
    ve.dm.Converter.static.whitespaceList = ' \\t\\f\\u200b\\r\\n';
    ve.dm.Converter.static.PARSER_MODE = 0;
    ve.dm.Converter.static.CLIPBOARD_MODE = 1;
    ve.dm.Converter.static.PREVIEW_MODE = 2;
    ve.dm.Converter.static.getDataContentFromText = function(text, annotations) {
        var i, len, characters = text.split('');
        if (!annotations || annotations.isEmpty()) {
            return characters;
        }
        for (i = 0,
        len = characters.length; i < len; i++) {
            characters[i] = [characters[i], annotations.getHashes().slice()];
        }
        return characters;
    }
    ;
    ve.dm.Converter.static.openAndCloseAnnotations = function(currentSet, targetSet, open, close) {
        var i, len, hash, startClosingAt, currentSetOpen, targetSetOpen;
        if (currentSet.getLength()) {
            targetSetOpen = targetSet.clone();
            for (i = 0,
            len = currentSet.getLength(); i < len; i++) {
                hash = currentSet.getHash(i);
                if (targetSetOpen.containsHash(hash) || targetSetOpen.containsComparableForSerialization(currentSet.get(i))) {
                    targetSetOpen.removeHash(hash);
                } else {
                    startClosingAt = i;
                    break;
                }
            }
            if (startClosingAt !== undefined) {
                for (i = currentSet.getLength() - 1; i >= startClosingAt; i--) {
                    close(currentSet.get(i));
                    currentSet.removeAt(i);
                }
            }
        }
        if (targetSet.getLength()) {
            currentSetOpen = currentSet.clone();
            for (i = 0,
            len = targetSet.getLength(); i < len; i++) {
                hash = targetSet.getHash(i);
                if (currentSetOpen.containsHash(hash) || currentSetOpen.containsComparableForSerialization(targetSet.get(i))) {
                    currentSetOpen.removeHash(hash);
                } else {
                    open(targetSet.get(i));
                    currentSet.pushHash(hash);
                }
            }
        }
    }
    ;
    ve.dm.Converter.static.renderHtmlAttributeList = function(originalDomElements, targetDomElements, filter, computed, deep) {
        var i, ilen, j, jlen, attrs, value;
        if (filter === undefined) {
            filter = !0;
        }
        if (filter === false) {
            return;
        }
        for (i = 0,
        ilen = originalDomElements.length; i < ilen; i++) {
            if (!targetDomElements[i]) {
                continue;
            }
            attrs = originalDomElements[i].attributes;
            if (!attrs) {
                continue;
            }
            for (j = 0,
            jlen = attrs.length; j < jlen; j++) {
                if (targetDomElements[i].nodeType === Node.ELEMENT_NODE && !targetDomElements[i].hasAttribute(attrs[j].name) && (filter === true || filter(attrs[j].name))) {
                    if (computed && this.computedAttributes.indexOf(attrs[j].name) !== -1) {
                        value = originalDomElements[i][attrs[j].name];
                    } else {
                        value = attrs[j].value;
                    }
                    targetDomElements[i].setAttribute(attrs[j].name, value);
                }
                if (filter === true || filter(attrs[j].name)) {
                    value = computed && this.computedAttributes.indexOf(attrs[j].name) !== -1 ? originalDomElements[i][attrs[j].name] : attrs[j].value;
                }
            }
            if (deep && !targetDomElements[i].veFromDataElement && originalDomElements[i].children.length > 0) {
                this.renderHtmlAttributeList(originalDomElements[i].children, targetDomElements[i].children, filter, computed, true);
            }
        }
    }
    ;
    ve.dm.Converter.static.moveInlineMetaItems = function(data) {
        var i, item, metaParent, j, pending, ancestors = [], pendingMetaItems = [];
        function closestMetaParent() {
            var i, ancestor;
            for (i = ancestors.length - 1; i >= 0; i--) {
                ancestor = ancestors[i];
                if (ancestor.isMetaParent) {
                    return ancestor;
                }
            }
            return undefined;
        }
        for (i = 0; i < data.length; i++) {
            item = data[i];
            if (Array.isArray(item)) {
                item = item[0];
            }
            if (!item.type) {
                continue;
            }
            if (item.type[0] !== '/') {
                if (ve.getProp(item, 'internal', 'isInlineMeta')) {
                    delete item.internal.isInlineMeta;
                    metaParent = closestMetaParent();
                    if (metaParent) {
                        metaParent.item.internal.metaItems.push(item);
                        pendingMetaItems.push({
                            item: item,
                            closeItem: data[i + 1],
                            metaParent: metaParent,
                            offset: i - metaParent.offset - 1
                        });
                        data.splice(i, 2);
                        i--;
                    } else {
                        i++;
                    }
                } else {
                    ancestors.push({
                        item: item,
                        offset: i,
                        isMetaParent: !!ve.getProp(item, 'internal', 'metaItems')
                    });
                }
            } else {
                metaParent = ancestors.pop();
                if (metaParent.isMetaParent) {
                    for (j = 0; j < pendingMetaItems.length; j++) {
                        pending = pendingMetaItems[j];
                        if (pending.metaParent.item !== metaParent.item) {
                            continue;
                        }
                        pending.item.internal.loadMetaParentHash = metaParent.item.originalDomElementsHash;
                        pending.item.internal.loadMetaParentOffset = pending.offset;
                        pendingMetaItems.splice(j, 1);
                        j--;
                        data.splice(i + 1, 0, pending.item, pending.closeItem);
                        i += 2;
                    }
                }
            }
        }
    }
    ;
    ve.dm.Converter.prototype.isConverting = function() {
        return this.contextStack !== null;
    }
    ;
    ve.dm.Converter.prototype.getStore = function() {
        return this.store;
    }
    ;
    ve.dm.Converter.prototype.getHtmlDocument = function() {
        return this.doc;
    }
    ;
    ve.dm.Converter.prototype.getTargetHtmlDocument = function() {
        return this.targetDoc;
    }
    ;
    ve.dm.Converter.prototype.getMode = function() {
        return this.mode;
    }
    ;
    ve.dm.Converter.prototype.doesModeNeedRendering = function() {
        return this.getMode() !== this.constructor.static.PARSER_MODE;
    }
    ;
    ve.dm.Converter.prototype.isForParser = function() {
        return this.getMode() === this.constructor.static.PARSER_MODE;
    }
    ;
    ve.dm.Converter.prototype.isForClipboard = function() {
        return this.getMode() === this.constructor.static.CLIPBOARD_MODE;
    }
    ;
    ve.dm.Converter.prototype.isForPreview = function() {
        return this.getMode() === this.constructor.static.PREVIEW_MODE;
    }
    ;
    ve.dm.Converter.prototype.isFromClipboard = function() {
        return this.fromClipboard;
    }
    ;
    ve.dm.Converter.prototype.getCurrentContext = function() {
        return this.contextStack === null ? null : this.contextStack[this.contextStack.length - 1];
    }
    ;
    ve.dm.Converter.prototype.getActiveAnnotations = function() {
        var context = this.getCurrentContext();
        return context ? context.annotations : null;
    }
    ;
    ve.dm.Converter.prototype.isExpectingContent = function() {
        var context = this.getCurrentContext();
        return context ? context.expectingContent : null;
    }
    ;
    ve.dm.Converter.prototype.isValidChildNodeType = function(nodeType) {
        var childTypes, context = this.getCurrentContext();
        if (!context) {
            return null;
        }
        childTypes = this.nodeFactory.getChildNodeTypes(context.branchType);
        return (childTypes === null || childTypes.indexOf(nodeType) !== -1);
    }
    ;
    ve.dm.Converter.prototype.isInWrapper = function() {
        var context = this.getCurrentContext();
        return context ? context.inWrapper : null;
    }
    ;
    ve.dm.Converter.prototype.canCloseWrapper = function() {
        var context = this.getCurrentContext();
        return context ? context.canCloseWrapper : null;
    }
    ;
    ve.dm.Converter.prototype.getDomElementsFromDataElement = function(dataElements, doc, childDomElements) {
        var domElements, originalDomElements, key, dataElement = Array.isArray(dataElements) ? dataElements[0] : dataElements, nodeClass = this.modelRegistry.lookup(dataElement.type);
        if (!nodeClass) {
            throw new Error('Attempting to convert unknown data element type ' + dataElement.type);
        }
        if (nodeClass.static.isInternal) {
            return false;
        }
        domElements = nodeClass.static.toDomElements(dataElements, doc, this, childDomElements);
        if (!Array.isArray(domElements) && !(nodeClass.prototype instanceof ve.dm.Annotation)) {
            throw new Error('toDomElements() failed to return an array when converting element of type ' + dataElement.type);
        }
        originalDomElements = this.store.value(dataElement.originalDomElementsHash);
        if (originalDomElements && !ve.isEqualDomElements(domElements, originalDomElements)) {
            this.constructor.static.renderHtmlAttributeList(originalDomElements, domElements, nodeClass.static.preserveHtmlAttributes, false, (!this.nodeFactory.lookup(dataElement.type) || !this.nodeFactory.canNodeHaveChildren(dataElement.type) || this.nodeFactory.doesNodeHandleOwnChildren(dataElement.type)));
        }
        if (dataElement.internal && dataElement.internal.diff) {
            Array.prototype.forEach.call(domElements, function(domElement) {
                for (key in dataElement.internal.diff) {
                    if (domElement.setAttribute) {
                        domElement.setAttribute(key, dataElement.internal.diff[key]);
                    }
                }
            });
        }
        if (this.nodeFactory.lookup(dataElement.type) && this.nodeFactory.canNodeHaveChildren(dataElement.type)) {
            domElements.forEach(function(domElement) {
                domElement.veFromDataElement = !0;
            });
        }
        return domElements;
    }
    ;
    ve.dm.Converter.prototype.createDataElements = function(modelClass, domElements) {
        var serializer, dataElements = modelClass.static.toDataElement(domElements, this);
        if (!dataElements) {
            return null;
        }
        if (!Array.isArray(dataElements)) {
            dataElements = [dataElements];
        }
        if (dataElements.length) {
            if (modelClass.prototype instanceof ve.dm.Annotation) {
                serializer = function(node) {
                    return node.cloneNode(false).outerHTML;
                }
                ;
            } else {
                serializer = ve.getNodeHtml;
            }
            dataElements[0].originalDomElementsHash = this.store.hash(domElements, domElements.map(serializer).join(''));
            if (modelClass.prototype instanceof ve.dm.BranchNode && modelClass.static.childNodeTypes === null) {
                ve.setProp(dataElements[0], 'internal', 'metaItems', []);
                ve.setProp(dataElements[0], 'internal', 'changesSinceLoad', 0);
            }
        }
        return dataElements;
    }
    ;
    ve.dm.Converter.prototype.getDomElementFromDataAnnotation = function(dataAnnotation, doc) {
        var htmlData = dataAnnotation.toHtml()
          , domElement = doc.createElement(htmlData.tag);
        ve.setDomAttributes(domElement, htmlData.attributes);
        return domElement;
    }
    ;
    ve.dm.Converter.prototype.getModelFromDom = function(doc, options, store) {
        var data, linearData, refData, innerWhitespace, internalList = new ve.dm.InternalList();
        store = store || new ve.dm.HashValueStore();
        options = options || {};
        this.doc = doc;
        this.targetDoc = options.targetDoc || doc;
        this.fromClipboard = options.fromClipboard;
        this.store = store;
        this.internalList = internalList;
        this.contextStack = [];
        data = this.getDataFromDomSubtree(doc.body);
        this.constructor.static.moveInlineMetaItems(data);
        linearData = new ve.dm.ElementLinearData(store,data);
        refData = this.internalList.convertToData(this, doc);
        linearData.batchSplice(linearData.getLength(), 0, refData);
        innerWhitespace = this.getInnerWhitespace(linearData);
        this.doc = null;
        this.targetDoc = null;
        this.fromClipboard = null;
        this.store = null;
        this.internalList = null;
        this.contextStack = null;
        return new ve.dm.Document(linearData,doc,undefined,internalList,innerWhitespace,options.lang,options.dir);
    }
    ;
    ve.dm.Converter.prototype.getDataFromDomClean = function(domElement, wrapperElement, annotationSet) {
        var result, contextStack = this.contextStack;
        this.contextStack = [];
        result = this.getDataFromDomSubtree(domElement, wrapperElement, annotationSet);
        this.contextStack = contextStack;
        return result;
    }
    ;
    ve.dm.Converter.prototype.getDataFromDomSubtree = function(domElement, wrapperElement, annotationSet) {
        var i, childNode, childNodes, childDataElements, text, matches, wrappingParagraph, prevElement, childAnnotations, modelName, modelClass, annotation, childIsContent, aboutGroup, emptyParagraph, converter = this, whitespaceList = this.constructor.static.whitespaceList, modelRegistry = this.modelRegistry, data = [], nextWhitespace = '', wrappedWhitespace = '', wrappedWhitespaceIndex, wrappedMetaItems = [], context = {}, prevContext = this.contextStack.length ? this.contextStack[this.contextStack.length - 1] : null;
        function addWhitespace(element, index, whitespace) {
            if (!whitespace) {
                return;
            }
            if (!element.internal) {
                element.internal = {};
            }
            if (!element.internal.whitespace) {
                element.internal.whitespace = [];
            }
            element.internal.whitespace[index] = whitespace;
        }
        function processNextWhitespace(element) {
            if (nextWhitespace !== '') {
                addWhitespace(element, 0, nextWhitespace);
                nextWhitespace = '';
            }
        }
        function outputWrappedMetaItems(whitespaceTreatment) {
            var i, len, toInsert = [], prev = wrappingParagraph;
            for (i = 0,
            len = wrappedMetaItems.length; i < len; i++) {
                if (wrappedMetaItems[i].type && wrappedMetaItems[i].type.charAt(0) !== '/') {
                    if (wrappedMetaItems[i].internal && wrappedMetaItems[i].internal.whitespace) {
                        if (whitespaceTreatment === 'restore') {
                            ve.batchPush(toInsert, converter.constructor.static.getDataContentFromText(wrappedMetaItems[i].internal.whitespace[0], context.annotations));
                            delete wrappedMetaItems[i].internal;
                        } else if (whitespaceTreatment === 'fixup') {
                            addWhitespace(prev, 3, wrappedMetaItems[i].internal.whitespace[0]);
                        }
                    }
                    prev = wrappedMetaItems[i];
                }
                toInsert.push(wrappedMetaItems[i]);
            }
            if (wrappedWhitespace !== '' && whitespaceTreatment === 'restore') {
                ve.batchSplice(data, wrappedWhitespaceIndex, 0, toInsert);
            } else {
                ve.batchPush(data, toInsert);
            }
            wrappedMetaItems = [];
        }
        function startWrapping() {
            wrappingParagraph = {
                type: 'paragraph',
                internal: {
                    generated: 'wrapper',
                    metaItems: []
                }
            };
            data.push(wrappingParagraph);
            context.inWrapper = !0;
            context.canCloseWrapper = !0;
            context.expectingContent = !0;
            processNextWhitespace(wrappingParagraph);
        }
        function stopWrapping() {
            if (wrappedWhitespace !== '') {
                data.splice(wrappedWhitespaceIndex, wrappedWhitespace.length);
                addWhitespace(wrappedMetaItems.length > 0 ? wrappedMetaItems[wrappedMetaItems.length - 2] : wrappingParagraph, 3, wrappedWhitespace);
                nextWhitespace = wrappedWhitespace;
            }
            data.push({
                type: '/paragraph'
            });
            outputWrappedMetaItems('fixup');
            wrappingParagraph = undefined;
            context.inWrapper = !1;
            context.canCloseWrapper = !1;
            context.expectingContent = context.originallyExpectingContent;
        }
        function getAboutGroup(node) {
            var about, aboutGroup = [node];
            if (node.nodeType !== Node.ELEMENT_NODE || node.getAttribute('about') === null) {
                return aboutGroup;
            }
            about = node.getAttribute('about');
            while ((node = node.nextSibling) !== null) {
                if (node.nodeType === Node.ELEMENT_NODE && node.getAttribute('about') === about) {
                    aboutGroup.push(node);
                } else {
                    break;
                }
            }
            return aboutGroup;
        }
        function isAllInstanceOf(data, targetClass) {
            var i, type, itemClass;
            for (i = data.length - 1; i >= 0; i--) {
                type = ve.dm.LinearData.static.getType(data[i]);
                if (type) {
                    itemClass = modelRegistry.lookup(type) || ve.dm.AlienNode;
                    if (!(itemClass === targetClass || itemClass.prototype instanceof targetClass)) {
                        return false;
                    }
                } else {
                    return false;
                }
            }
            return true;
        }
        context.annotations = annotationSet || (prevContext ? prevContext.annotations.clone() : new ve.dm.AnnotationSet(this.store));
        context.branchType = wrapperElement ? wrapperElement.type : (prevContext ? prevContext.branchType : 'document');
        context.branchHasContent = this.nodeFactory.canNodeContainContent(context.branchType);
        context.originallyExpectingContent = context.branchHasContent || !context.annotations.isEmpty();
        context.expectingContent = context.originallyExpectingContent;
        context.inWrapper = prevContext ? prevContext.inWrapper : !1;
        context.canCloseWrapper = !1;
        this.contextStack.push(context);
        if (wrapperElement) {
            data.push(wrapperElement);
        }
        function setInlineMeta(element) {
            ve.setProp(element, 'internal', 'isInlineMeta', true);
        }
        for (i = 0; i < domElement.childNodes.length; i++) {
            childNode = domElement.childNodes[i];
            switch (childNode.nodeType) {
            case Node.ELEMENT_NODE:
            case Node.COMMENT_NODE:
                if (childNode.getAttribute && childNode.getAttribute('data-ve-ignore')) {
                    continue;
                }
                aboutGroup = getAboutGroup(childNode);
                modelName = this.modelRegistry.matchElement(childNode, aboutGroup.length > 1);
                modelClass = this.modelRegistry.lookup(modelName) || ve.dm.AlienNode;
                if (modelClass.prototype instanceof ve.dm.Annotation) {
                    childNodes = [childNode];
                } else {
                    childNodes = modelClass.static.enableAboutGrouping ? aboutGroup : [childNode];
                }
                childDataElements = this.createDataElements(modelClass, childNodes);
                if (!childDataElements) {
                    modelClass = ve.dm.AlienNode;
                    childNodes = modelClass.static.enableAboutGrouping ? aboutGroup : [childNode];
                    childDataElements = this.createDataElements(modelClass, childNodes);
                } else if (childDataElements.length) {
                    modelClass = this.modelRegistry.lookup(childDataElements[0].type);
                } else {
                    continue;
                }
                if (modelClass.prototype instanceof ve.dm.Annotation) {
                    annotation = this.annotationFactory.createFromElement(childDataElements[0], this.store);
                    if (!context.inWrapper && !context.expectingContent) {
                        startWrapping();
                        prevElement = wrappingParagraph;
                    }
                    childAnnotations = context.annotations.clone();
                    childAnnotations.push(annotation);
                    childDataElements = this.getDataFromDomSubtree(childNode, undefined, childAnnotations);
                    if (!childDataElements.length || isAllInstanceOf(childDataElements, ve.dm.AlienMetaItem)) {
                        if (!childDataElements.length || isAllInstanceOf(childDataElements, ve.dm.RemovableAlienMetaItem)) {
                            childDataElements = this.createDataElements(ve.dm.RemovableAlienMetaItem, childNodes);
                        } else {
                            childDataElements = this.createDataElements(ve.dm.AlienMetaItem, childNodes);
                        }
                        childDataElements.push({
                            type: '/' + childDataElements[0].type
                        });
                        if (!context.annotations.isEmpty()) {
                            childDataElements[0].annotations = context.annotations.getHashes().slice();
                        }
                        setInlineMeta(childDataElements[0]);
                    }
                    outputWrappedMetaItems('restore');
                    ve.batchPush(data, childDataElements);
                    wrappedWhitespace = '';
                } else {
                    if (modelClass.prototype instanceof ve.dm.MetaItem) {
                        if (context.expectingContent) {
                            childDataElements.forEach(setInlineMeta);
                        }
                        if (childDataElements.length === 1) {
                            childDataElements.push({
                                type: '/' + childDataElements[0].type
                            });
                        }
                        if (!context.annotations.isEmpty()) {
                            childDataElements[0].annotations = context.annotations.getHashes().slice();
                        }
                        if (context.inWrapper && context.canCloseWrapper) {
                            ve.batchPush(wrappedMetaItems, childDataElements);
                            if (wrappedWhitespace !== '') {
                                data.splice(wrappedWhitespaceIndex, wrappedWhitespace.length);
                                addWhitespace(childDataElements[0], 0, wrappedWhitespace);
                                nextWhitespace = wrappedWhitespace;
                                wrappedWhitespace = '';
                            }
                        } else {
                            outputWrappedMetaItems('restore');
                            ve.batchPush(data, childDataElements);
                            processNextWhitespace(childDataElements[0]);
                            prevElement = childDataElements[0];
                        }
                        i += childNodes.length - 1;
                        break;
                    }
                    childIsContent = this.nodeFactory.canNodeSerializeAsContent(childDataElements[0].type);
                    if (!context.expectingContent && childIsContent) {
                        startWrapping();
                        prevElement = wrappingParagraph;
                    } else if (context.expectingContent && !childIsContent) {
                        if (context.inWrapper && context.canCloseWrapper) {
                            stopWrapping();
                        } else {
                            modelClass = ve.dm.AlienNode;
                            childNodes = modelClass.static.enableAboutGrouping ? aboutGroup : [childNode];
                            childDataElements = this.createDataElements(modelClass, childNodes);
                            childIsContent = this.nodeFactory.canNodeSerializeAsContent(childDataElements[0].type);
                        }
                    }
                    if (context.inWrapper && childIsContent) {
                        outputWrappedMetaItems('restore');
                        wrappedWhitespace = '';
                        nextWhitespace = '';
                    }
                    if (childIsContent && !context.annotations.isEmpty()) {
                        childDataElements[0].annotations = context.annotations.getHashes().slice();
                    }
                    if (childDataElements.length === 1 && childNodes.length === 1 && this.nodeFactory.canNodeHaveChildren(childDataElements[0].type) && !this.nodeFactory.doesNodeHandleOwnChildren(childDataElements[0].type)) {
                        outputWrappedMetaItems('restore');
                        ve.batchPush(data, this.getDataFromDomSubtree(childNode, childDataElements[0], new ve.dm.AnnotationSet(this.store)));
                    } else {
                        if (childDataElements.length === 1) {
                            childDataElements.push({
                                type: '/' + childDataElements[0].type
                            });
                        }
                        outputWrappedMetaItems('restore');
                        ve.batchPush(data, childDataElements);
                    }
                    processNextWhitespace(childDataElements[0]);
                    prevElement = childDataElements[0];
                    i += childNodes.length - 1;
                }
                break;
            case Node.TEXT_NODE:
                text = childNode.data;
                if (text === '') {
                    break;
                }
                if (!context.originallyExpectingContent) {
                    if (text.match(new RegExp('^[' + whitespaceList + ']+$'))) {
                        if (context.inWrapper) {
                            wrappedWhitespace = text;
                            wrappedWhitespaceIndex = data.length;
                            ve.batchPush(data, this.constructor.static.getDataContentFromText(wrappedWhitespace, context.annotations));
                        } else {
                            if (!prevElement) {
                                if (wrapperElement) {
                                    addWhitespace(wrapperElement, 1, text);
                                }
                            } else {
                                addWhitespace(prevElement, 3, text);
                            }
                            nextWhitespace = text;
                            wrappedWhitespace = '';
                            outputWrappedMetaItems('restore');
                        }
                        break;
                    } else {
                        matches = text.match(new RegExp('^([' + whitespaceList + ']*)([\\s\\S]*?)([' + whitespaceList + ']*)$'));
                        if (!context.inWrapper) {
                            startWrapping();
                            if (matches[1] !== '') {
                                if (!prevElement) {
                                    if (wrapperElement) {
                                        addWhitespace(wrapperElement, 1, matches[1]);
                                    }
                                } else {
                                    addWhitespace(prevElement, 3, matches[1]);
                                }
                                addWhitespace(wrappingParagraph, 0, matches[1]);
                            }
                        } else {
                            outputWrappedMetaItems('restore');
                            ve.batchPush(data, this.constructor.static.getDataContentFromText(matches[1], context.annotations));
                        }
                        ve.batchPush(data, this.constructor.static.getDataContentFromText(matches[2], context.annotations));
                        wrappedWhitespace = matches[3];
                        wrappedWhitespaceIndex = data.length;
                        ve.batchPush(data, this.constructor.static.getDataContentFromText(wrappedWhitespace, context.annotations));
                        prevElement = wrappingParagraph;
                        break;
                    }
                }
                if (context.annotations.isEmpty() && i === 0 && wrapperElement && !this.nodeFactory.doesNodeHaveSignificantWhitespace(wrapperElement.type)) {
                    matches = text.match(new RegExp('^[' + whitespaceList + ']+'));
                    if (matches && matches[0] !== '') {
                        addWhitespace(wrapperElement, 1, matches[0]);
                        text = text.slice(matches[0].length);
                    }
                }
                if (context.annotations.isEmpty() && i === domElement.childNodes.length - 1 && wrapperElement && !this.nodeFactory.doesNodeHaveSignificantWhitespace(wrapperElement.type)) {
                    matches = text.match(new RegExp('[' + whitespaceList + ']+$'));
                    if (matches && matches[0] !== '') {
                        addWhitespace(wrapperElement, 2, matches[0]);
                        text = text.slice(0, text.length - matches[0].length);
                    }
                }
                ve.batchPush(data, this.constructor.static.getDataContentFromText(text, context.annotations));
                break;
            }
        }
        if (context.inWrapper && context.canCloseWrapper) {
            stopWrapping();
            context.inWrapper = !0;
        }
        if (context.branchType !== 'paragraph' && wrapperElement && data[data.length - 1] === wrapperElement && !context.inWrapper && !this.nodeFactory.canNodeContainContent(context.branchType) && !this.nodeFactory.isNodeContent(context.branchType) && this.isValidChildNodeType('paragraph')) {
            emptyParagraph = {
                type: 'paragraph',
                internal: {
                    generated: 'empty'
                }
            };
            processNextWhitespace(emptyParagraph);
            data.push(emptyParagraph);
            data.push({
                type: '/paragraph'
            });
        }
        if (wrapperElement) {
            if (nextWhitespace !== '' && data[data.length - 1] !== wrapperElement) {
                addWhitespace(wrapperElement, 2, nextWhitespace);
                nextWhitespace = '';
            }
            data.push({
                type: '/' + wrapperElement.type
            });
        }
        if (context.branchType === 'document' && isAllInstanceOf(data, ve.dm.MetaItem) && !annotationSet) {
            emptyParagraph = {
                type: 'paragraph',
                internal: {
                    generated: 'empty'
                }
            };
            processNextWhitespace(emptyParagraph);
            data.push(emptyParagraph);
            data.push({
                type: '/paragraph'
            });
        }
        this.contextStack.pop();
        return data;
    }
    ;
    ve.dm.Converter.prototype.getInnerWhitespace = function(data) {
        var whitespace, innerWhitespace = new Array(2), stack = 0, last = data.getLength() - 1;
        if (data.isOpenElementData(0)) {
            whitespace = ve.getProp(data.getData(0), 'internal', 'whitespace');
            innerWhitespace[0] = whitespace ? whitespace[0] : undefined;
        }
        if (data.isCloseElementData(last)) {
            stack++;
            while (--last) {
                if (data.isCloseElementData(last)) {
                    stack++;
                } else if (data.isOpenElementData(last)) {
                    stack--;
                    if (stack === 0 && data.getType(last) !== 'internalList') {
                        break;
                    }
                }
            }
            whitespace = ve.getProp(data.getData(last), 'internal', 'whitespace');
            innerWhitespace[1] = whitespace ? whitespace[3] : undefined;
        }
        return innerWhitespace;
    }
    ;
    ve.dm.Converter.prototype.getDomFromModel = function(model, mode) {
        var doc = ve.createDocumentFromHtml('');
        if (typeof mode === 'boolean') {
            mode = mode ? this.constructor.static.CLIPBOARD_MODE : this.constructor.static.PARSER_MODE;
        }
        mode = mode || this.constructor.static.PARSER_MODE;
        this.getDomSubtreeFromModel(model, doc.body, mode);
        return doc;
    }
    ;
    ve.dm.Converter.prototype.getDomFromNode = function(node, mode) {
        if (typeof mode === 'boolean') {
            mode = mode ? this.constructor.static.CLIPBOARD_MODE : this.constructor.static.PARSER_MODE;
        }
        mode = mode || this.constructor.static.PARSER_MODE;
        return this.getDomFromModel(node.getDocument().shallowCloneFromRange(node.isInternal() ? node.getRange() : node.getOuterRange()), mode);
    }
    ;
    ve.dm.Converter.prototype.getDomSubtreeFromModel = function(model, container, mode) {
        if (typeof mode === 'boolean') {
            mode = mode ? this.constructor.static.CLIPBOARD_MODE : this.constructor.static.PARSER_MODE;
        }
        mode = mode || this.constructor.static.PARSER_MODE;
        this.documentData = model.getFullData(undefined, 'roundTrip');
        this.store = model.getStore();
        this.internalList = model.getInternalList();
        this.originalDocInternalList = model.getOriginalDocument() ? model.getOriginalDocument().getInternalList() : this.internalList;
        this.mode = mode;
        this.getDomSubtreeFromData(this.documentData, container, model.getInnerWhitespace());
        this.documentData = null;
        this.store = null;
        this.internalList = null;
        this.originalDocInternalList = null;
        this.mode = null;
    }
    ;
    ve.dm.Converter.prototype.getDomSubtreeFromData = function(data, container, innerWhitespace) {
        var text, i, j, isStart, annotations, dataElement, dataElementOrSlice, oldLastOuterPost, childDomElements, pre, ours, theirs, parentDomElement, lastChild, isContentNode, sibling, previousSiblings, doUnwrap, textNode, type, annotatedDomElementStack, annotatedDomElements, whitespaceList = this.constructor.static.whitespaceList, whitespaceHtmlChars = ve.visibleWhitespaceCharacters, dataLen = data.length, converter = this, doc = container.ownerDocument, domElement = container, annotationStack = new ve.dm.AnnotationSet(this.store);
        function openAnnotation() {
            if (text.length > 0) {
                annotatedDomElements.push(doc.createTextNode(text));
                text = '';
            }
            annotatedDomElements = [];
            annotatedDomElementStack.push(annotatedDomElements);
        }
        function closeAnnotation(annotation) {
            var i, len, annotationElement, annotatedChildDomElements, matches, first, last, leading = '', trailing = '', originalDomElements = annotation.getOriginalDomElements(converter.store), origElementText = originalDomElements[0] && originalDomElements[0].textContent || '';
            if (text.length > 0) {
                annotatedDomElements.push(doc.createTextNode(text));
                text = '';
            }
            annotatedChildDomElements = annotatedDomElementStack.pop();
            annotatedDomElements = annotatedDomElementStack[annotatedDomElementStack.length - 1];
            if (annotation.constructor.static.trimWhitespace) {
                first = annotatedChildDomElements[0];
                while (first && first.nodeType === Node.TEXT_NODE && (matches = first.data.match(new RegExp('^[' + whitespaceList + ']+'))) && !origElementText.match(new RegExp('^[' + whitespaceList + ']'))) {
                    leading += matches[0];
                    first.deleteData(0, matches[0].length);
                    if (first.data.length !== 0) {
                        break;
                    }
                    annotatedChildDomElements.shift();
                    first = annotatedChildDomElements[0];
                }
                last = annotatedChildDomElements[annotatedChildDomElements.length - 1];
                while (last && last.nodeType === Node.TEXT_NODE && (matches = last.data.match(new RegExp('[' + whitespaceList + ']+$'))) && !origElementText.match(new RegExp('[' + whitespaceList + ']$'))) {
                    trailing = matches[0] + trailing;
                    last.deleteData(last.data.length - matches[0].length, matches[0].length);
                    if (last.data.length !== 0) {
                        break;
                    }
                    annotatedChildDomElements.pop();
                    last = annotatedChildDomElements[annotatedChildDomElements.length - 1];
                }
            }
            if (annotatedChildDomElements.length) {
                annotationElement = converter.getDomElementsFromDataElement(annotation.getElement(), doc, annotatedChildDomElements)[0];
            }
            if (leading) {
                annotatedDomElements.push(doc.createTextNode(leading));
            }
            if (annotationElement) {
                for (i = 0,
                len = annotatedChildDomElements.length; i < len; i++) {
                    annotationElement.appendChild(annotatedChildDomElements[i]);
                }
                annotatedDomElements.push(annotationElement);
            } else {
                for (i = 0,
                len = annotatedChildDomElements.length; i < len; i++) {
                    annotatedDomElements.push(annotatedChildDomElements[i]);
                }
            }
            if (trailing) {
                annotatedDomElements.push(doc.createTextNode(trailing));
            }
        }
        function findEndOfNode(i) {
            var j, depth;
            for (j = i + 1,
            depth = 1; j < dataLen && depth > 0; j++) {
                if (data[j].type) {
                    depth += data[j].type.charAt(0) === '/' ? -1 : 1;
                }
            }
            if (depth !== 0) {
                throw new Error('Unbalanced data: ' + depth + ' element(s) left open.');
            }
            return j;
        }
        function getDataElementOrSlice() {
            var dataSlice;
            if (ve.dm.nodeFactory.lookup(data[i].type) && ve.dm.nodeFactory.doesNodeHandleOwnChildren(data[i].type)) {
                dataSlice = data.slice(i, findEndOfNode(i));
            } else {
                dataSlice = data[i];
            }
            return dataSlice;
        }
        function getChar(char) {
            if (converter.isForPreview() && Object.prototype.hasOwnProperty.call(whitespaceHtmlChars, char)) {
                char = whitespaceHtmlChars[char];
            }
            return char;
        }
        for (i = 0; i < dataLen; i++) {
            if (typeof data[i] === 'string') {
                text = '';
                isStart = i > 0 && ve.dm.LinearData.static.isOpenElementData(data[i - 1]) && !ve.dm.nodeFactory.doesNodeHaveSignificantWhitespace(ve.dm.LinearData.static.getType(data[i - 1]));
                while (typeof data[i] === 'string') {
                    if (!(isStart && data[i].match(new RegExp('[' + whitespaceList + ']')) && this.isForParser())) {
                        text += getChar(data[i]);
                        isStart = !1;
                    }
                    i++;
                }
                i--;
                if (text.length > 0) {
                    domElement.appendChild(doc.createTextNode(text));
                }
            } else if (Array.isArray(data[i]) || (data[i].annotations !== undefined && this.nodeFactory.canNodeSerializeAsContent(data[i].type))) {
                text = '';
                annotatedDomElements = [];
                annotatedDomElementStack = [annotatedDomElements];
                while (data[i] !== undefined && (Array.isArray(data[i]) || (data[i].annotations !== undefined && this.nodeFactory.canNodeSerializeAsContent(data[i].type)))) {
                    annotations = new ve.dm.AnnotationSet(this.store,data[i].annotations || data[i][1]);
                    this.constructor.static.openAndCloseAnnotations(annotationStack, annotations, openAnnotation, closeAnnotation);
                    if (data[i].annotations === undefined) {
                        text += getChar(data[i][0]);
                    } else {
                        if (text.length > 0) {
                            annotatedDomElements.push(doc.createTextNode(text));
                            text = '';
                        }
                        dataElementOrSlice = getDataElementOrSlice();
                        childDomElements = this.getDomElementsFromDataElement(dataElementOrSlice, doc);
                        for (j = 0; j < childDomElements.length; j++) {
                            annotatedDomElements.push(childDomElements[j]);
                        }
                        if (Array.isArray(dataElementOrSlice)) {
                            i += dataElementOrSlice.length - 1;
                        } else {
                            i++;
                        }
                    }
                    i++;
                }
                i--;
                if (text.length > 0) {
                    annotatedDomElements.push(doc.createTextNode(text));
                    text = '';
                }
                this.constructor.static.openAndCloseAnnotations(annotationStack, new ve.dm.AnnotationSet(this.store), openAnnotation, closeAnnotation);
                for (j = 0; j < annotatedDomElements.length; j++) {
                    domElement.appendChild(annotatedDomElements[j]);
                }
            } else if (data[i].type !== undefined) {
                dataElement = data[i];
                if (dataElement.type.charAt(0) === '/') {
                    parentDomElement = domElement.parentNode;
                    type = data[i].type.slice(1);
                    isContentNode = this.nodeFactory.isNodeContent(type);
                    oldLastOuterPost = parentDomElement.lastOuterPost;
                    if (!isContentNode && domElement.veInternal && domElement.veInternal.whitespace) {
                        pre = domElement.veInternal.whitespace[1];
                        if (pre) {
                            if (domElement.firstChild && domElement.firstChild.nodeType === Node.TEXT_NODE) {
                                domElement.firstChild.insertData(0, pre);
                            } else {
                                textNode = doc.createTextNode(pre);
                                textNode.veIsWhitespace = !0;
                                domElement.insertBefore(textNode, domElement.firstChild);
                            }
                        }
                        lastChild = domElement.veInternal.childDomElements ? domElement.veInternal.childDomElements[domElement.veInternal.childDomElements.length - 1].lastChild : domElement.lastChild;
                        ours = domElement.veInternal.whitespace[2];
                        if (domElement.lastOuterPost === undefined) {
                            theirs = ours;
                        } else {
                            theirs = domElement.lastOuterPost;
                        }
                        if (ours && ours === theirs) {
                            if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
                                domElement.lastChild.appendData(ours);
                            } else {
                                textNode = doc.createTextNode(ours);
                                textNode.veIsWhitespace = !0;
                                domElement.appendChild(textNode);
                            }
                        }
                        parentDomElement.lastOuterPost = domElement.veInternal.whitespace[3] || '';
                    } else if (!isContentNode) {
                        parentDomElement.lastOuterPost = '';
                    }
                    doUnwrap = !1;
                    if (domElement.veInternal) {
                        switch (domElement.veInternal.generated) {
                        case 'slug':
                            if (domElement.childNodes.length === 0) {
                                doUnwrap = !0;
                            }
                            break;
                        case 'empty':
                            if (domElement.childNodes.length === 0 && (data[i + 1] === undefined || data[i + 1].type.charAt(0) === '/' || (data[i + 1].type && this.nodeFactory.isNodeInternal(data[i + 1].type)))) {
                                doUnwrap = !0;
                            }
                            break;
                        case 'wrapper':
                            doUnwrap = !0;
                            previousSiblings = domElement.parentNode.childNodes;
                            for (j = previousSiblings.length - 2; j >= 0; j--) {
                                sibling = previousSiblings[j];
                                if (sibling.nodeType === Node.TEXT_NODE && !sibling.veIsWhitespace) {
                                    doUnwrap = !1;
                                    break;
                                }
                                if (ve.isBlockElement(sibling)) {
                                    break;
                                }
                            }
                            break;
                        }
                    }
                    if (doUnwrap) {
                        if (domElement.childNodes.length) {
                            while (domElement.firstChild) {
                                parentDomElement.insertBefore(domElement.firstChild, domElement);
                            }
                        } else {
                            parentDomElement.lastOuterPost = oldLastOuterPost || '';
                        }
                        parentDomElement.removeChild(domElement);
                    }
                    delete domElement.veInternal;
                    delete domElement.lastOuterPost;
                    if (!ve.dm.nodeFactory.lookup(type) || !ve.dm.nodeFactory.isNodeInternal(type)) {
                        domElement = parentDomElement;
                    }
                } else {
                    if (this.nodeFactory.isNodeInternal(data[i].type)) {
                        break;
                    }
                    isContentNode = this.nodeFactory.isNodeContent(data[i].type);
                    dataElementOrSlice = getDataElementOrSlice();
                    childDomElements = this.getDomElementsFromDataElement(dataElementOrSlice, doc);
                    if (childDomElements && !childDomElements.length) {
                        i = findEndOfNode(i) - 1;
                        continue;
                    } else if (childDomElements) {
                        childDomElements[0].veInternal = ve.extendObject({
                            childDomElements: childDomElements
                        }, dataElement.internal ? ve.copy(dataElement.internal) : {});
                        for (j = 0; j < childDomElements.length; j++) {
                            domElement.appendChild(childDomElements[j]);
                        }
                        parentDomElement = domElement;
                        domElement = childDomElements[0];
                        if (domElement.veInternal && domElement.veInternal.whitespace) {
                            ours = domElement.veInternal.whitespace[0];
                            theirs = undefined;
                            if (domElement.previousSibling) {
                                theirs = parentDomElement.lastOuterPost;
                            } else if (parentDomElement === container) {
                                theirs = innerWhitespace ? innerWhitespace[0] : ours;
                            } else {
                                if (parentDomElement.veInternal && parentDomElement.veInternal.whitespace) {
                                    theirs = parentDomElement.veInternal.whitespace[1];
                                    parentDomElement.veInternal.whitespace[1] = undefined;
                                }
                            }
                            if (ours && ours === theirs) {
                                textNode = doc.createTextNode(ours);
                                textNode.veIsWhitespace = !0;
                                parentDomElement.insertBefore(textNode, domElement);
                            }
                        } else if (!isContentNode && !domElement.previousSibling && parentDomElement.veInternal && parentDomElement.veInternal.whitespace) {
                            parentDomElement.veInternal.whitespace[1] = undefined;
                        }
                    }
                    if (Array.isArray(dataElementOrSlice)) {
                        i += dataElementOrSlice.length - 2;
                    } else if (childDomElements && childDomElements.length && childDomElements[0].handledOwnChildren) {
                        i = findEndOfNode(i) - 2;
                    }
                }
            }
        }
        if (container.lastOuterPost !== undefined && (!innerWhitespace || container.lastOuterPost === innerWhitespace[1])) {
            if (container.lastChild && container.lastChild.nodeType === Node.TEXT_NODE) {
                container.lastChild.appendData(container.lastOuterPost);
            } else if (container.lastOuterPost.length > 0) {
                container.appendChild(doc.createTextNode(container.lastOuterPost));
            }
            delete container.lastOuterPost;
        }
        ve.normalizeNode(container);
    }
    ;
    ve.dm.converter = new ve.dm.Converter(ve.dm.modelRegistry,ve.dm.nodeFactory,ve.dm.annotationFactory);
    ve.dm.SourceConverter = function VeDmSourceConverter() {}
    ;
    ve.dm.SourceConverter.prototype.getModelFromSourceText = function(sourceText, options) {
        var data = this.getDataFromSourceText(sourceText);
        options = options || {};
        data.push({
            type: 'internalList'
        }, {
            type: '/internalList'
        });
        return new ve.dm.Document(data,undefined,undefined,undefined,undefined,options.lang,options.dir,undefined,true);
    }
    ;
    ve.dm.SourceConverter.prototype.getDataFromSourceText = function(sourceText, inline) {
        var i, l, lines = sourceText.split(/\r\n|\r|\n/), content = [];
        for (i = 0,
        l = lines.length; i < l; i++) {
            if (!(inline && i === 0)) {
                content.push({
                    type: 'paragraph'
                });
            }
            ve.batchPush(content, lines[i].split(''));
            if (!(inline && i === l - 1)) {
                content.push({
                    type: '/paragraph'
                });
            }
        }
        return content;
    }
    ;
    ve.dm.SourceConverter.prototype.getSourceTextFromModel = function(model) {
        return this.getSourceTextFromDataRange(model.data.data);
    }
    ;
    ve.dm.SourceConverter.prototype.getSourceTextFromDataRange = function(data, range) {
        var i, text = '';
        range = range || new ve.Range(0,data.length);
        for (i = range.start; i < range.end; i++) {
            if (data[i].type === '/paragraph' && (!data[i + 1] || data[i + 1].type === 'paragraph')) {
                text += '\n';
            } else if (!data[i].type) {
                text += data[i];
            }
        }
        return text;
    }
    ;
    ve.dm.sourceConverter = new ve.dm.SourceConverter();
    ve.dm.LinearSelection = function VeDmLinearSelection(range) {
        if (ve.dm.Document && arguments[0]instanceof ve.dm.Document) {
            throw new Error('Got obsolete ve.dm.Document argument');
        }
        ve.dm.LinearSelection.super.call(this);
        this.range = range;
    }
    ;
    OO.inheritClass(ve.dm.LinearSelection, ve.dm.Selection);
    ve.dm.LinearSelection.static.name = 'linear';
    ve.dm.LinearSelection.static.newFromHash = function(hash) {
        return new ve.dm.LinearSelection(ve.Range.static.newFromHash(hash.range));
    }
    ;
    ve.dm.LinearSelection.prototype.toJSON = function() {
        return {
            type: this.constructor.static.name,
            range: this.range
        };
    }
    ;
    ve.dm.LinearSelection.prototype.getDescription = function() {
        return 'Linear: ' + this.range.from + ' - ' + this.range.to;
    }
    ;
    ve.dm.LinearSelection.prototype.collapseToStart = function() {
        return new this.constructor(new ve.Range(this.getRange().start));
    }
    ;
    ve.dm.LinearSelection.prototype.collapseToEnd = function() {
        return new this.constructor(new ve.Range(this.getRange().end));
    }
    ;
    ve.dm.LinearSelection.prototype.collapseToFrom = function() {
        return new this.constructor(new ve.Range(this.getRange().from));
    }
    ;
    ve.dm.LinearSelection.prototype.collapseToTo = function() {
        return new this.constructor(new ve.Range(this.getRange().to));
    }
    ;
    ve.dm.LinearSelection.prototype.isCollapsed = function() {
        return this.getRange().isCollapsed();
    }
    ;
    ve.dm.LinearSelection.prototype.translateByTransaction = function(tx, excludeInsertion) {
        return new this.constructor(tx.translateRange(this.getRange(), excludeInsertion));
    }
    ;
    ve.dm.LinearSelection.prototype.translateByTransactionWithAuthor = function(tx, authorId) {
        return new this.constructor(tx.translateRangeWithAuthor(this.getRange(), authorId));
    }
    ;
    ve.dm.LinearSelection.prototype.getRanges = function() {
        return [this.range];
    }
    ;
    ve.dm.LinearSelection.prototype.getCoveringRange = function() {
        return this.range;
    }
    ;
    ve.dm.LinearSelection.prototype.getRange = function() {
        return this.range;
    }
    ;
    ve.dm.LinearSelection.prototype.equals = function(other) {
        return this === other || (!!other && other.constructor === this.constructor && this.getRange().equals(other.getRange()));
    }
    ;
    ve.dm.selectionFactory.register(ve.dm.LinearSelection);
    ve.dm.NullSelection = function VeDmNullSelection() {
        ve.dm.NullSelection.super.call(this);
    }
    ;
    OO.inheritClass(ve.dm.NullSelection, ve.dm.Selection);
    ve.dm.NullSelection.static.name = 'null';
    ve.dm.NullSelection.static.newFromHash = function() {
        return new ve.dm.NullSelection();
    }
    ;
    ve.dm.NullSelection.prototype.toJSON = function() {
        return {
            type: this.constructor.static.name
        };
    }
    ;
    ve.dm.NullSelection.prototype.getDescription = function() {
        return 'Null';
    }
    ;
    ve.dm.NullSelection.prototype.self = function() {
        return this;
    }
    ;
    ve.dm.NullSelection.prototype.collapseToStart = ve.dm.NullSelection.prototype.self;
    ve.dm.NullSelection.prototype.collapseToEnd = ve.dm.NullSelection.prototype.self;
    ve.dm.NullSelection.prototype.collapseToFrom = ve.dm.NullSelection.prototype.self;
    ve.dm.NullSelection.prototype.collapseToTo = ve.dm.NullSelection.prototype.self;
    ve.dm.NullSelection.prototype.isCollapsed = function() {
        return true;
    }
    ;
    ve.dm.NullSelection.prototype.translateByTransaction = ve.dm.NullSelection.prototype.self;
    ve.dm.NullSelection.prototype.translateByTransactionWithAuthor = ve.dm.NullSelection.prototype.self;
    ve.dm.NullSelection.prototype.getRanges = function() {
        return [];
    }
    ;
    ve.dm.NullSelection.prototype.getCoveringRange = function() {
        return null;
    }
    ;
    ve.dm.NullSelection.prototype.equals = function(other) {
        return this === other || (!!other && other.constructor === this.constructor);
    }
    ;
    ve.dm.NullSelection.prototype.isNull = function() {
        return true;
    }
    ;
    ve.dm.selectionFactory.register(ve.dm.NullSelection);
    ve.dm.TableSelection = function VeDmTableSelection(tableRange, fromCol, fromRow, toCol, toRow) {
        if (ve.dm.Document && arguments[0]instanceof ve.dm.Document) {
            throw new Error('Got obsolete ve.dm.Document argument');
        }
        if (arguments.length > 5) {
            throw new Error('Got obsolete argument (probably `expand`)');
        }
        ve.dm.TableSelection.super.call(this);
        this.tableRange = tableRange;
        toCol = toCol === undefined ? fromCol : toCol;
        toRow = toRow === undefined ? fromRow : toRow;
        this.fromCol = fromCol;
        this.fromRow = fromRow;
        this.toCol = toCol;
        this.toRow = toRow;
        this.startCol = fromCol < toCol ? fromCol : toCol;
        this.startRow = fromRow < toRow ? fromRow : toRow;
        this.endCol = fromCol < toCol ? toCol : fromCol;
        this.endRow = fromRow < toRow ? toRow : fromRow;
        this.intendedFromCol = this.fromCol;
        this.intendedFromRow = this.fromRow;
        this.intendedToCol = this.toCol;
        this.intendedToRow = this.toRow;
    }
    ;
    OO.inheritClass(ve.dm.TableSelection, ve.dm.Selection);
    ve.dm.TableSelection.static.name = 'table';
    ve.dm.TableSelection.static.newFromHash = function(hash) {
        return new ve.dm.TableSelection(ve.Range.static.newFromHash(hash.tableRange),hash.fromCol,hash.fromRow,hash.toCol,hash.toRow);
    }
    ;
    ve.dm.TableSelection.static.getTableMatrixCells = function(matrix, selectionOffsets, includePlaceholders) {
        var row, col, cell, cells = [], visited = {};
        for (row = selectionOffsets.startRow; row <= selectionOffsets.endRow; row++) {
            for (col = selectionOffsets.startCol; col <= selectionOffsets.endCol; col++) {
                cell = matrix.getCell(row, col);
                if (!cell) {
                    continue;
                }
                if (!includePlaceholders && cell.isPlaceholder()) {
                    cell = cell.owner;
                }
                if (!visited[cell.key]) {
                    cells.push(cell);
                    visited[cell.key] = !0;
                }
            }
        }
        return cells;
    }
    ;
    ve.dm.TableSelection.prototype.expand = function(doc) {
        var cell, i, matrix = this.getTableNode(doc).getMatrix(), lastCellCount = 0, startCol = Infinity, startRow = Infinity, endCol = -Infinity, endRow = -Infinity, colBackwards = this.fromCol > this.toCol, rowBackwards = this.fromRow > this.toRow, cells = this.getMatrixCells(doc);
        while (cells.length > lastCellCount) {
            for (i = 0; i < cells.length; i++) {
                cell = cells[i];
                startCol = Math.min(startCol, cell.col);
                startRow = Math.min(startRow, cell.row);
                endCol = Math.max(endCol, cell.col + cell.node.getColspan() - 1);
                endRow = Math.max(endRow, cell.row + cell.node.getRowspan() - 1);
            }
            lastCellCount = cells.length;
            cells = this.constructor.static.getTableMatrixCells(matrix, {
                startCol: startCol,
                startRow: startRow,
                endCol: endCol,
                endRow: endRow
            });
        }
        return new this.constructor(this.tableRange,colBackwards ? endCol : startCol,rowBackwards ? endRow : startRow,colBackwards ? startCol : endCol,rowBackwards ? startRow : endRow);
    }
    ;
    ve.dm.TableSelection.prototype.toJSON = function() {
        return {
            type: this.constructor.static.name,
            tableRange: this.tableRange,
            fromCol: this.fromCol,
            fromRow: this.fromRow,
            toCol: this.toCol,
            toRow: this.toRow
        };
    }
    ;
    ve.dm.TableSelection.prototype.getDescription = function() {
        return ('Table: ' + this.tableRange.from + ' - ' + this.tableRange.to + ', ' + 'c' + this.fromCol + ' r' + this.fromRow + ' - ' + 'c' + this.toCol + ' r' + this.toRow);
    }
    ;
    ve.dm.TableSelection.prototype.collapseToStart = function() {
        return new this.constructor(this.tableRange,this.startCol,this.startRow,this.startCol,this.startRow);
    }
    ;
    ve.dm.TableSelection.prototype.collapseToEnd = function() {
        return new this.constructor(this.tableRange,this.endCol,this.endRow,this.endCol,this.endRow);
    }
    ;
    ve.dm.TableSelection.prototype.collapseToFrom = function() {
        return new this.constructor(this.tableRange,this.fromCol,this.fromRow,this.fromCol,this.fromRow);
    }
    ;
    ve.dm.TableSelection.prototype.collapseToTo = function() {
        return new this.constructor(this.tableRange,this.toCol,this.toRow,this.toCol,this.toRow);
    }
    ;
    ve.dm.TableSelection.prototype.getRanges = function(doc) {
        var i, l, ranges = [], cells = this.getMatrixCells(doc);
        for (i = 0,
        l = cells.length; i < l; i++) {
            ranges.push(cells[i].node.getRange());
        }
        return ranges;
    }
    ;
    ve.dm.TableSelection.prototype.getCoveringRange = function() {
        return this.tableRange;
    }
    ;
    ve.dm.TableSelection.prototype.getTableSliceRanges = function(doc) {
        var i, node, ranges = [], matrix = this.getTableNode(doc).getMatrix();
        function pushNode(node) {
            var range = node.getOuterRange();
            ranges[range.start] = new ve.Range(range.start,range.start + 1);
            ranges[range.end - 1] = new ve.Range(range.end - 1,range.end);
        }
        for (i = this.startRow; i <= this.endRow; i++) {
            node = matrix.getRowNode(i);
            pushNode(node);
            while ((node = node.getParent()) && node) {
                pushNode(node);
                if (node instanceof ve.dm.TableNode) {
                    break;
                }
            }
        }
        return ranges.filter(function(r) {
            return r;
        }).concat(this.getOuterRanges(doc)).sort(function(a, b) {
            return a.start - b.start;
        });
    }
    ;
    ve.dm.TableSelection.prototype.getOuterRanges = function(doc) {
        var i, l, ranges = [], cells = this.getMatrixCells(doc);
        for (i = 0,
        l = cells.length; i < l; i++) {
            ranges.push(cells[i].node.getOuterRange());
        }
        return ranges;
    }
    ;
    ve.dm.TableSelection.prototype.getMatrixCells = function(doc, includePlaceholders) {
        return this.constructor.static.getTableMatrixCells(this.getTableNode(doc).getMatrix(), {
            startCol: this.startCol,
            startRow: this.startRow,
            endCol: this.endCol,
            endRow: this.endRow
        }, includePlaceholders);
    }
    ;
    ve.dm.TableSelection.prototype.isEditable = function(doc) {
        return this.getMatrixCells(doc).every(function(cell) {
            return cell.node.isCellEditable();
        });
    }
    ;
    ve.dm.TableSelection.prototype.isCollapsed = function() {
        return false;
    }
    ;
    ve.dm.TableSelection.prototype.translateByTransaction = function(tx) {
        var newRange = tx.translateRange(this.tableRange, true);
        if (newRange.isCollapsed()) {
            return new ve.dm.NullSelection();
        }
        return new this.constructor(newRange,this.fromCol,this.fromRow,this.toCol,this.toRow);
    }
    ;
    ve.dm.TableSelection.prototype.translateByTransactionWithAuthor = function(tx, authorId) {
        var newRange = tx.translateRangeWithAuthor(this.tableRange, authorId);
        if (newRange.isCollapsed()) {
            return new ve.dm.NullSelection();
        }
        return new this.constructor(newRange,this.fromCol,this.fromRow,this.toCol,this.toRow);
    }
    ;
    ve.dm.TableSelection.prototype.isSingleCell = function(doc) {
        return (this.fromRow === this.toRow && this.fromCol === this.toCol) || this.getMatrixCells(doc).length === 1;
    }
    ;
    ve.dm.TableSelection.prototype.isMergeable = function(doc) {
        var r, sectionNode, lastSectionNode, matrix;
        if (!this.isEditable(doc)) {
            return false;
        }
        if (this.getMatrixCells(doc, true).length <= 1) {
            return false;
        }
        matrix = this.getTableNode(doc).getMatrix();
        for (r = this.endRow; r >= this.startRow; r--) {
            sectionNode = matrix.getRowNode(r).findParent(ve.dm.TableSectionNode);
            if (lastSectionNode && sectionNode !== lastSectionNode) {
                return false;
            }
            lastSectionNode = sectionNode;
        }
        return true;
    }
    ;
    ve.dm.TableSelection.prototype.getTableNode = function(doc) {
        return doc.getBranchNodeFromOffset(this.tableRange.start + 1);
    }
    ;
    ve.dm.TableSelection.prototype.newFromAdjustment = function(doc, fromColOffset, fromRowOffset, toColOffset, toRowOffset, wrap) {
        var fromCell, toCell, wrapDir, selection, matrix = this.getTableNode(doc).getMatrix();
        if (toColOffset === undefined) {
            toColOffset = fromColOffset;
        }
        if (toRowOffset === undefined) {
            toRowOffset = fromRowOffset;
        }
        function adjust(mode, cell, offset) {
            var nextCell, col = cell.col, row = cell.row, dir = offset > 0 ? 1 : -1;
            while (offset !== 0) {
                if (mode === 'col') {
                    col += dir;
                    if (col >= matrix.getColCount(row)) {
                        if (wrap && row < matrix.getRowCount() - 1) {
                            col -= matrix.getColCount(row);
                            row++;
                            wrapDir = 1;
                        } else {
                            break;
                        }
                    } else if (col < 0) {
                        if (wrap && row > 0) {
                            row--;
                            col += matrix.getColCount(row);
                            wrapDir = -1;
                        } else {
                            break;
                        }
                    }
                } else {
                    row += dir;
                    if (row >= matrix.getRowCount() || row < 0) {
                        break;
                    }
                }
                nextCell = matrix.getCell(row, col);
                if (!nextCell || nextCell.equals(cell)) {
                    continue;
                }
                offset -= dir;
                cell = nextCell;
            }
            return cell;
        }
        fromCell = matrix.getCell(this.intendedFromRow, this.intendedFromCol);
        if (fromColOffset) {
            fromCell = adjust('col', fromCell, fromColOffset);
        }
        if (fromRowOffset) {
            fromCell = adjust('row', fromCell, fromRowOffset);
        }
        toCell = matrix.getCell(this.intendedToRow, this.intendedToCol);
        if (toColOffset) {
            toCell = adjust('col', toCell, toColOffset);
        }
        if (toRowOffset) {
            toCell = adjust('row', toCell, toRowOffset);
        }
        if (wrapDir > 0) {
            fromCell = toCell;
        } else if (wrapDir < 0) {
            toCell = fromCell;
        }
        selection = new this.constructor(this.tableRange,fromCell.col,fromCell.row,toCell.col,toCell.row);
        selection = selection.expand(doc);
        return selection;
    }
    ;
    ve.dm.TableSelection.prototype.containsCell = function(cell) {
        return cell.node.findParent(ve.dm.TableNode).getOuterRange().equals(this.tableRange) && cell.col >= this.startCol && cell.col <= this.endCol && cell.row >= this.startRow && cell.row <= this.endRow;
    }
    ;
    ve.dm.TableSelection.prototype.equals = function(other) {
        return this === other || (!!other && other.constructor === this.constructor && this.tableRange.equals(other.tableRange) && this.fromCol === other.fromCol && this.fromRow === other.fromRow && this.toCol === other.toCol && this.toRow === other.toRow);
    }
    ;
    ve.dm.TableSelection.prototype.getRowCount = function() {
        return this.endRow - this.startRow + 1;
    }
    ;
    ve.dm.TableSelection.prototype.getColCount = function() {
        return this.endCol - this.startCol + 1;
    }
    ;
    ve.dm.TableSelection.prototype.isFullRow = function(doc) {
        var matrix = this.getTableNode(doc).getMatrix();
        return this.getColCount() === matrix.getMaxColCount();
    }
    ;
    ve.dm.TableSelection.prototype.isFullCol = function(doc) {
        var matrix = this.getTableNode(doc).getMatrix();
        return this.getRowCount() === matrix.getRowCount();
    }
    ;
    ve.dm.selectionFactory.register(ve.dm.TableSelection);
    ve.dm.FlatLinearData = function VeDmFlatLinearData() {
        ve.dm.FlatLinearData.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.FlatLinearData, ve.dm.LinearData);
    ve.dm.FlatLinearData.prototype.getType = function(offset) {
        return ve.dm.LinearData.static.getType(this.getData(offset));
    }
    ;
    ve.dm.FlatLinearData.prototype.isElementData = function(offset) {
        return ve.dm.LinearData.static.isElementData(this.getData(offset));
    }
    ;
    ve.dm.FlatLinearData.prototype.containsElementData = function() {
        var i = this.getLength();
        while (i--) {
            if (this.isElementData(i)) {
                return true;
            }
        }
        return false;
    }
    ;
    ve.dm.FlatLinearData.prototype.isOpenElementData = function(offset) {
        return ve.dm.LinearData.static.isOpenElementData(this.getData(offset));
    }
    ;
    ve.dm.FlatLinearData.prototype.isCloseElementData = function(offset) {
        return ve.dm.LinearData.static.isCloseElementData(this.getData(offset));
    }
    ;
    ve.dm.ElementLinearData = function VeDmElementLinearData() {
        ve.dm.ElementLinearData.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.ElementLinearData, ve.dm.FlatLinearData);
    ve.dm.ElementLinearData.static.startWordRegExp = new RegExp('^(' + unicodeJS.characterclass.patterns.word + ')');
    ve.dm.ElementLinearData.static.endWordRegExp = new RegExp('(' + unicodeJS.characterclass.patterns.word + ')$');
    ve.dm.ElementLinearData.static.compareElementsUnannotated = function(a, b) {
        var aPlain = a
          , bPlain = b;
        if (Array.isArray(a)) {
            aPlain = a[0];
        }
        if (Array.isArray(b)) {
            bPlain = b[0];
        }
        if (typeof aPlain === 'string' && typeof bPlain === 'string') {
            return aPlain === bPlain;
        }
        if (typeof a !== typeof b) {
            return false;
        }
        if (a.type !== b.type) {
            return false;
        }
        if (ve.dm.LinearData.static.isOpenElementData(a)) {
            aPlain = ve.dm.modelRegistry.lookup(a.type).static.getHashObject(a);
            delete aPlain.originalDomElementsHash;
            bPlain = ve.dm.modelRegistry.lookup(b.type).static.getHashObject(b);
            delete bPlain.originalDomElementsHash;
            return ve.compare(aPlain, bPlain);
        } else {
            return true;
        }
    }
    ;
    ve.dm.ElementLinearData.static.compareElements = function(a, b, aStore, bStore) {
        var typeofA, aSet, bSet, aAnnotations, bAnnotations;
        if (a === b) {
            return true;
        }
        typeofA = typeof a;
        if (typeofA !== typeof b) {
            return false;
        }
        if (typeofA === 'string') {
            return false;
        }
        if (!this.compareElementsUnannotated(a, b)) {
            return false;
        }
        if (Array.isArray(a)) {
            aAnnotations = a[1];
        }
        if (Array.isArray(b)) {
            bAnnotations = b[1];
        }
        if (a && a.type) {
            aAnnotations = a.annotations;
        }
        if (b && b.type) {
            bAnnotations = b.annotations;
        }
        aSet = new ve.dm.AnnotationSet(aStore,aAnnotations || []);
        bSet = new ve.dm.AnnotationSet(bStore || aStore,bAnnotations || []);
        return aSet.compareTo(bSet);
    }
    ;
    ve.dm.ElementLinearData.static.getAnnotationHashesFromItem = function(item) {
        if (typeof item === 'string') {
            return [];
        } else if (item.annotations) {
            return item.annotations.slice();
        } else if (item[1]) {
            return item[1].slice();
        } else {
            return [];
        }
    }
    ;
    ve.dm.ElementLinearData.static.replaceAnnotationHashesForItem = function(item, hashes) {
        var character, isElement = ve.dm.LinearData.static.isElementData(item);
        item = ve.copy(item);
        hashes = hashes.slice();
        if (hashes.length > 0) {
            if (isElement) {
                item.annotations = hashes;
            } else {
                character = ve.dm.ElementLinearData.static.getCharacterDataFromItem(item);
                item = [character, hashes];
            }
        } else {
            if (isElement) {
                delete item.annotations;
            } else {
                item = ve.dm.ElementLinearData.static.getCharacterDataFromItem(item);
            }
        }
        return item;
    }
    ;
    ve.dm.ElementLinearData.static.getCharacterDataFromItem = function(item) {
        var data = Array.isArray(item) ? item[0] : item;
        return typeof data === 'string' ? data : '';
    }
    ;
    ve.dm.ElementLinearData.prototype.isContentOffset = function(offset) {
        var left, right, factory;
        if (offset === 0 || offset === this.getLength()) {
            return false;
        }
        left = this.getData(offset - 1);
        right = this.getData(offset);
        factory = ve.dm.nodeFactory;
        return ((left !== undefined && right !== undefined) && ((typeof left === 'string' || typeof right === 'string') || (Array.isArray(left) || Array.isArray(right)) || ((typeof left.type === 'string' && left.type.charAt(0) === '/' && factory.isNodeContent(left.type.slice(1))) || (typeof right.type === 'string' && right.type.charAt(0) !== '/' && factory.isNodeContent(right.type)) || ('/' + left.type === right.type && factory.canNodeContainContent(left.type)))));
    }
    ;
    ve.dm.ElementLinearData.prototype.isStructuralOffset = function(offset, unrestricted) {
        var left, right, factory;
        if (offset === 0 || offset === this.getLength()) {
            return true;
        }
        left = this.getData(offset - 1);
        right = this.getData(offset);
        factory = ve.dm.nodeFactory;
        return ((left !== undefined && right !== undefined && typeof left.type === 'string' && typeof right.type === 'string') && ((left.type.charAt(0) === '/' && (factory.canNodeHaveChildren(left.type.slice(1)) || !factory.isNodeContent(left.type.slice(1))) && (!unrestricted || factory.getParentNodeTypes(left.type.slice(1)) === null)) || (right.type.charAt(0) !== '/' && (factory.canNodeHaveChildren(right.type) || !factory.isNodeContent(right.type)) && (!unrestricted || factory.getParentNodeTypes(right.type) === null)) || ('/' + left.type === right.type && factory.canNodeHaveChildrenNotContent(left.type) && (!unrestricted || factory.getChildNodeTypes(left.type) === null))));
    }
    ;
    ve.dm.ElementLinearData.prototype.isContentData = function() {
        var item, i = this.getLength();
        while (i--) {
            item = this.getData(i);
            if (item.type !== undefined && item.type.charAt(0) !== '/' && !ve.dm.nodeFactory.isNodeContent(item.type)) {
                return false;
            }
        }
        return true;
    }
    ;
    ve.dm.ElementLinearData.prototype.canTakeAnnotationAtOffset = function(offset, annotation, ignoreClose) {
        var type;
        if (this.isElementData(offset)) {
            if (ignoreClose && this.isCloseElementData(offset)) {
                return false;
            }
            type = this.getType(offset);
            return ve.dm.nodeFactory.isNodeContent(type) && ve.dm.nodeFactory.canNodeTakeAnnotation(type, annotation);
        } else {
            return true;
        }
    }
    ;
    ve.dm.ElementLinearData.prototype.getAnnotationHashesFromOffset = function(offset, ignoreClose) {
        var item;
        if (offset < 0 || offset > this.getLength()) {
            throw new Error('offset ' + offset + ' out of bounds');
        }
        if (!ignoreClose && this.isCloseElementData(offset) && !ve.dm.nodeFactory.canNodeHaveChildren(this.getType(offset))) {
            offset = this.getRelativeContentOffset(offset, -1);
            if (offset === -1) {
                return [];
            }
        }
        item = this.getData(offset);
        return this.constructor.static.getAnnotationHashesFromItem(item) || [];
    }
    ;
    ve.dm.ElementLinearData.prototype.getAnnotationsFromOffset = function(offset, ignoreClose) {
        return new ve.dm.AnnotationSet(this.getStore(),this.getAnnotationHashesFromOffset(offset, ignoreClose));
    }
    ;
    ve.dm.ElementLinearData.prototype.setAnnotationsAtOffset = function(offset, annotations) {
        this.setAnnotationHashesAtOffset(offset, this.getStore().hashAll(annotations.get()));
    }
    ;
    ve.dm.ElementLinearData.prototype.setAnnotationHashesAtOffset = function(offset, hashes) {
        var item = this.getData(offset);
        item = this.constructor.static.replaceAnnotationHashesForItem(item, hashes);
        this.setData(offset, item);
    }
    ;
    ve.dm.ElementLinearData.prototype.setAttributeAtOffset = function(offset, key, value) {
        var item = this.getData(offset);
        if (!this.isElementData(offset)) {
            return;
        }
        if (value === undefined) {
            if (item.attributes) {
                delete item.attributes[key];
            }
        } else {
            if (!item.attributes) {
                item.attributes = {};
            }
            item.attributes[key] = value;
        }
    }
    ;
    ve.dm.ElementLinearData.prototype.getCharacterData = function(offset) {
        var item = this.getData(offset);
        return ve.dm.ElementLinearData.static.getCharacterDataFromItem(item);
    }
    ;
    ve.dm.ElementLinearData.prototype.getAnnotatedRangeFromOffset = function(offset, annotation) {
        var start = offset
          , end = offset;
        if (this.getAnnotationsFromOffset(offset).contains(annotation) === false) {
            return null;
        }
        while (start > 0) {
            start--;
            if (this.getAnnotationsFromOffset(start).contains(annotation) === false) {
                start++;
                break;
            }
        }
        while (end < this.getLength()) {
            if (this.getAnnotationsFromOffset(end).contains(annotation) === false) {
                break;
            }
            end++;
        }
        return new ve.Range(start,end);
    }
    ;
    ve.dm.ElementLinearData.prototype.getAnnotatedRangeFromSelection = function(range, annotation) {
        var start = range.start
          , end = range.end;
        while (start > 0) {
            start--;
            if (this.getAnnotationsFromOffset(start).contains(annotation) === false) {
                start++;
                break;
            }
        }
        while (end < this.getLength()) {
            if (this.getAnnotationsFromOffset(end).contains(annotation) === false) {
                break;
            }
            end++;
        }
        return new ve.Range(start,end);
    }
    ;
    ve.dm.ElementLinearData.prototype.getAnnotationsFromRange = function(range, all) {
        var i, left, right, ignoreChildrenDepth = 0;
        for (i = range.start; i < range.end; i++) {
            if (this.isElementData(i)) {
                if (ve.dm.nodeFactory.shouldIgnoreChildren(this.getType(i))) {
                    ignoreChildrenDepth += this.isOpenElementData(i) ? 1 : -1;
                }
                if (!ve.dm.nodeFactory.isNodeContent(this.getType(i))) {
                    continue;
                }
            }
            if (ignoreChildrenDepth > 0) {
                continue;
            }
            if (!left) {
                left = this.getAnnotationsFromOffset(i);
                if (range.getLength() === 0 || range.getLength() === 1) {
                    return left;
                }
                continue;
            }
            right = this.getAnnotationsFromOffset(i);
            if (all && !right.isEmpty()) {
                left.addSet(right);
            } else if (!all) {
                if (right.isEmpty()) {
                    return new ve.dm.AnnotationSet(this.getStore());
                }
                left = left.getComparableAnnotationsFromSet(right);
                if (left.isEmpty()) {
                    break;
                }
            }
        }
        return left || new ve.dm.AnnotationSet(this.getStore());
    }
    ;
    ve.dm.ElementLinearData.prototype.getInsertionAnnotationsFromRange = function(range, startAfterAnnotations) {
        var start, startAnnotations, afterAnnotations;
        if (range.isCollapsed() && !startAfterAnnotations) {
            start = Math.max(0, range.start - 1);
        } else {
            start = range.start;
        }
        if (this.isContentOffset(start)) {
            startAnnotations = this.getAnnotationsFromOffset(start);
        } else {
            startAnnotations = new ve.dm.AnnotationSet(this.getStore());
        }
        if (this.isContentOffset(range.end)) {
            afterAnnotations = this.getAnnotationsFromOffset(range.end);
        } else {
            afterAnnotations = new ve.dm.AnnotationSet(this.getStore());
        }
        return startAnnotations.filter(function(annotation) {
            return annotation.constructor.static.applyToAppendedContent || afterAnnotations.containsComparable(annotation);
        });
    }
    ;
    ve.dm.ElementLinearData.prototype.hasAnnotationsInRange = function(range) {
        var i;
        for (i = range.start; i < range.end; i++) {
            if (this.getAnnotationHashesFromOffset(i, true).length) {
                return true;
            }
        }
        return false;
    }
    ;
    ve.dm.ElementLinearData.prototype.trimOuterSpaceFromRange = function(range) {
        var start = range.start
          , end = range.end;
        while (this.getCharacterData(end - 1).match(/\s/)) {
            end--;
        }
        while (start < end && this.getCharacterData(start).match(/\s/)) {
            start++;
        }
        return range.to < range.end ? new ve.Range(end,start) : new ve.Range(start,end);
    }
    ;
    ve.dm.ElementLinearData.prototype.isPlainText = function(range, ignoreNonContentNodes, ignoredTypes, ignoreCoveringAnnotations, ignoreAllAnnotations) {
        var i, type, annotations;
        range = range || new ve.Range(0,this.getLength());
        if (ignoreCoveringAnnotations) {
            annotations = this.getAnnotationsFromRange(range);
        }
        for (i = range.start; i < range.end; i++) {
            if (typeof this.data[i] === 'string') {
                continue;
            } else if (Array.isArray(this.data[i])) {
                if (ignoreAllAnnotations) {
                    continue;
                }
                if (ignoreCoveringAnnotations && annotations.containsAllOf(this.getAnnotationsFromOffset(i))) {
                    continue;
                }
            } else if (ignoreNonContentNodes || ignoredTypes) {
                type = this.getType(i);
                if (ignoredTypes && ignoredTypes.indexOf(type) !== -1) {
                    continue;
                }
                if (ignoreNonContentNodes && !ve.dm.nodeFactory.isNodeContent(type)) {
                    continue;
                }
            }
            return false;
        }
        return true;
    }
    ;
    ve.dm.ElementLinearData.prototype.forEachRunOfContent = function(range, callback) {
        var i, text = '';
        for (i = range.start; i < range.end; i++) {
            if (!this.isElementData(i)) {
                text += this.getCharacterData(i);
            } else if (ve.dm.nodeFactory.isNodeContent(this.getType(i))) {
                text += '\uFFFC';
            } else {
                if (text) {
                    callback(i - text.length, text);
                }
                text = '';
            }
        }
        if (text) {
            callback(range.end - text.length, text);
        }
    }
    ;
    ve.dm.ElementLinearData.prototype.getText = function(maintainIndices, range) {
        var i, text = '';
        range = range || new ve.Range(0,this.getLength());
        for (i = range.start; i < range.end; i++) {
            if (!this.isElementData(i)) {
                text += this.getCharacterData(i);
            } else if (maintainIndices) {
                text += '\n';
            }
        }
        return text;
    }
    ;
    ve.dm.ElementLinearData.prototype.getSourceText = function(range) {
        return ve.dm.sourceConverter.getSourceTextFromDataRange(this.data, range);
    }
    ;
    ve.dm.ElementLinearData.prototype.getRelativeOffset = function(offset, distance, callback) {
        var i, direction, dataOffset, isOpen, args = Array.prototype.slice.call(arguments, 3), start = offset, steps = 0, turnedAround = !1, ignoreChildrenDepth = 0;
        if (distance === 0) {
            if (callback.apply(this, [offset].concat(args))) {
                return offset;
            } else {
                distance = 1;
            }
        }
        direction = (offset <= 0 ? 1 : (offset >= this.getLength() ? -1 : (distance > 0 ? 1 : -1)));
        distance = Math.abs(distance);
        i = start + direction;
        offset = -1;
        while (i >= 0 && i <= this.getLength()) {
            dataOffset = i + (direction > 0 ? -1 : 0);
            if (this.isElementData(dataOffset) && ve.dm.nodeFactory.shouldIgnoreChildren(this.getType(dataOffset))) {
                isOpen = this.isOpenElementData(dataOffset);
                if ((direction > 0 && isOpen) || (direction < 0 && !isOpen)) {
                    ignoreChildrenDepth++;
                } else {
                    ignoreChildrenDepth--;
                    if (ignoreChildrenDepth < 0) {
                        return -1;
                    }
                }
            }
            if (callback.apply(this, [i].concat(args))) {
                if (!ignoreChildrenDepth) {
                    steps++;
                    offset = i;
                    if (distance === steps) {
                        return offset;
                    }
                }
            } else if (!turnedAround && steps === 0 && ((direction < 0 && i === 0) || (direction > 0 && (i === this.getLength() || this.getType(i - 1) === 'internalList')))) {
                if (callback.apply(this, [start].concat(args))) {
                    return start;
                }
                direction *= -1;
                i = start;
                distance = 1;
                turnedAround = !0;
                ignoreChildrenDepth = 0;
            }
            i += direction;
        }
        return offset;
    }
    ;
    ve.dm.ElementLinearData.prototype.getRelativeContentOffset = function(offset, distance) {
        return this.getRelativeOffset(offset, distance, this.constructor.prototype.isContentOffset);
    }
    ;
    ve.dm.ElementLinearData.prototype.getNearestContentOffset = function(offset, direction) {
        var left, right;
        if (this.isContentOffset(offset)) {
            return offset;
        }
        if (direction === undefined) {
            left = this.getRelativeContentOffset(offset, -1);
            right = this.getRelativeContentOffset(offset, 1);
            return offset - left < right - offset ? left : right;
        } else {
            return this.getRelativeContentOffset(offset, direction > 0 ? 1 : -1);
        }
    }
    ;
    ve.dm.ElementLinearData.prototype.getRelativeStructuralOffset = function(offset, distance, unrestricted) {
        if (distance === 0 && (offset === 0 || offset === this.getLength())) {
            return offset;
        }
        return this.getRelativeOffset(offset, distance, this.constructor.prototype.isStructuralOffset, unrestricted);
    }
    ;
    ve.dm.ElementLinearData.prototype.getNearestStructuralOffset = function(offset, direction, unrestricted) {
        var left, right;
        if (this.isStructuralOffset(offset, unrestricted)) {
            return offset;
        }
        if (!direction) {
            left = this.getRelativeStructuralOffset(offset, -1, unrestricted);
            right = this.getRelativeStructuralOffset(offset, 1, unrestricted);
            return offset - left < right - offset ? left : right;
        } else {
            return this.getRelativeStructuralOffset(offset, direction > 0 ? 1 : -1, unrestricted);
        }
    }
    ;
    ve.dm.ElementLinearData.prototype.getWordRange = function(offset) {
        var range, dataString = new ve.dm.DataString(this.getData());
        offset = this.getNearestContentOffset(offset);
        if (unicodeJS.wordbreak.isBreak(dataString, offset)) {
            if (this.constructor.static.endWordRegExp.exec((dataString.read(offset - 2) || ' ') + (dataString.read(offset - 1) || ' '))) {
                range = new ve.Range(unicodeJS.wordbreak.prevBreakOffset(dataString, offset),offset);
            } else if (this.constructor.static.startWordRegExp.exec((dataString.read(offset) || ' ') + (dataString.read(offset + 1) || ' '))) {
                range = new ve.Range(offset,unicodeJS.wordbreak.nextBreakOffset(dataString, offset));
            } else {
                return new ve.Range(offset);
            }
        } else {
            range = new ve.Range(unicodeJS.wordbreak.prevBreakOffset(dataString, offset),unicodeJS.wordbreak.nextBreakOffset(dataString, offset));
        }
        if (this.getText(false, range).trim().length === 0) {
            return new ve.Range(offset);
        }
        return range;
    }
    ;
    ve.dm.ElementLinearData.prototype.getUsedStoreValues = function(range) {
        var i, hash, hashes, j, store = this.getStore(), valueStore = {};
        range = range || new ve.Range(0,this.data.length);
        for (i = range.start; i < range.end; i++) {
            hashes = this.getAnnotationHashesFromOffset(i, true);
            j = hashes.length;
            while (j--) {
                hash = hashes[j];
                if (!Object.prototype.hasOwnProperty.call(valueStore, hash)) {
                    valueStore[hash] = store.value(hash);
                }
            }
            if (this.data[i].originalDomElementsHash !== undefined) {
                valueStore[this.data[i].originalDomElementsHash] = store.value(this.data[i].originalDomElementsHash);
            }
        }
        return valueStore;
    }
    ;
    ve.dm.ElementLinearData.prototype.remapInternalListIndexes = function(mapping, internalList) {
        var i, ilen, nodeClass;
        for (i = 0,
        ilen = this.data.length; i < ilen; i++) {
            if (this.isOpenElementData(i)) {
                nodeClass = ve.dm.nodeFactory.lookup(this.getType(i));
                nodeClass.static.remapInternalListIndexes(this.data[i], mapping, internalList);
            }
        }
    }
    ;
    ve.dm.ElementLinearData.prototype.remapInternalListKeys = function(internalList) {
        var i, ilen, nodeClass;
        for (i = 0,
        ilen = this.data.length; i < ilen; i++) {
            if (this.isOpenElementData(i)) {
                nodeClass = ve.dm.nodeFactory.lookup(this.getType(i));
                nodeClass.static.remapInternalListKeys(this.data[i], internalList);
            }
        }
    }
    ;
    ve.dm.ElementLinearData.prototype.remapAnnotationHash = function(oldHash, newHash) {
        var i, ilen, spliceAt;
        for (i = 0,
        ilen = this.data.length; i < ilen; i++) {
            if (this.data[i] === undefined || typeof this.data[i] === 'string') {
                continue;
            } else if (Array.isArray(this.data[i])) {
                while ((spliceAt = this.data[i][1].indexOf(oldHash)) !== -1) {
                    if (this.data[i][1].indexOf(newHash) === -1) {
                        this.data[i][1].splice(spliceAt, 1, newHash);
                    } else {
                        this.data[i][1].splice(spliceAt, 1, newHash);
                    }
                }
            }
        }
    }
    ;
    ve.dm.ElementLinearData.prototype.sanitize = function(rules) {
        var i, len, annotations, emptySet, setToRemove, type, oldHash, newHash, canContainContent, contentElement, isOpen, nodeClass, ann, start, elementStack = [], store = this.getStore(), allAnnotations = this.getAnnotationsFromRange(new ve.Range(0,this.getLength()), true);
        if (rules.plainText) {
            emptySet = new ve.dm.AnnotationSet(store);
        } else {
            if (rules.removeOriginalDomElements) {
                for (i = 0,
                len = allAnnotations.getLength(); i < len; i++) {
                    ann = allAnnotations.get(i);
                    if (ann.element.originalDomElementsHash !== undefined) {
                        oldHash = store.hashOfValue(ann);
                        delete allAnnotations.get(i).element.originalDomElementsHash;
                        newHash = store.replaceHash(oldHash, ann);
                        this.remapAnnotationHash(oldHash, newHash);
                        if (allAnnotations.storeHashes.indexOf(newHash) !== -1) {
                            allAnnotations.storeHashes.splice(i, 1);
                            i--;
                            len--;
                        } else {
                            allAnnotations.storeHashes.splice(i, 1, newHash);
                        }
                    }
                }
            }
            setToRemove = allAnnotations.filter(function(annotation) {
                return (rules.blacklist && rules.blacklist[annotation.name]) || (annotation.name === 'textStyle/span' && rules.removeOriginalDomElements);
            });
        }
        for (i = 0,
        len = this.getLength(); i < len; i++) {
            if (this.isElementData(i)) {
                type = this.getType(i);
                canContainContent = ve.dm.nodeFactory.canNodeContainContent(type);
                isOpen = this.isOpenElementData(i);
                if (isOpen) {
                    elementStack.push(this.getData(i));
                } else {
                    elementStack.pop();
                }
                if (rules.conversions && rules.conversions[type]) {
                    type = rules.conversions[type];
                    this.getData(i).type = (!isOpen ? '/' : '') + type;
                }
                if (rules.plainText && type !== 'paragraph' && canContainContent) {
                    type = 'paragraph';
                    this.setData(i, {
                        type: (this.isCloseElementData(i) ? '/' : '') + type
                    });
                }
                if ((rules.blacklist && rules.blacklist[type]) || (rules.plainText && type !== 'paragraph' && type !== 'internalList') || (!rules.allowMetadata && ve.dm.nodeFactory.isMetaData(type))) {
                    this.splice(i, 1);
                    len--;
                    if (isOpen) {
                        ve.deleteProp(this.getData(i), 'internal', 'generated');
                    }
                    i--;
                    continue;
                }
                if (!rules.allowBreaks && type === 'break' && contentElement) {
                    if (this.isOpenElementData(i - 1) && this.isCloseElementData(i + 2)) {
                        this.splice(i, 2);
                        len -= 2;
                    } else {
                        this.splice(i, 2, {
                            type: '/' + contentElement.type
                        }, ve.copy(contentElement));
                    }
                    i--;
                    continue;
                }
                if (!rules.keepEmptyContentBranches && isOpen && this.isCloseElementData(i + 1) && !ve.getProp(this.getData(i), 'internal', 'generated') && canContainContent) {
                    this.splice(i, 2);
                    len -= 2;
                    i--;
                    continue;
                }
                if (!rules.preserveHtmlWhitespace) {
                    ve.deleteProp(this.getData(i), 'internal', 'whitespace');
                }
                if (canContainContent && !isOpen && rules.singleLine) {
                    i++;
                    start = i;
                    while (i < len && !(this.isOpenElementData(i) && this.getType(i) === 'internalList')) {
                        i++;
                    }
                    this.splice(start, i - start);
                    break;
                }
                if (canContainContent) {
                    contentElement = isOpen ? this.getData(i) : null;
                }
            } else {
                if (this.getCharacterData(i) === '\n' && !ve.dm.nodeFactory.doesNodeHaveSignificantWhitespace(elementStack[elementStack.length - 1].type)) {
                    if (this.getCharacterData(i + 1).match(/\s/) || this.getCharacterData(i - 1).match(/\s/)) {
                        this.splice(i, 1);
                        len--;
                        i--;
                        continue;
                    } else {
                        if (typeof this.getData(i) === 'string') {
                            this.data[i] = ' ';
                        } else {
                            this.data[i][0] = ' ';
                        }
                    }
                }
                if (this.getCharacterData(i) === '\u00a0' && !ve.dm.nodeFactory.doesNodeHaveSignificantWhitespace(elementStack[elementStack.length - 1].type)) {
                    if (!(this.getCharacterData(i + 1) === ' ' || this.getCharacterData(i - 1) === ' ')) {
                        if (typeof this.getData(i) === 'string') {
                            this.data[i] = ' ';
                        } else {
                            this.data[i][0] = ' ';
                        }
                    }
                }
            }
            annotations = this.getAnnotationsFromOffset(i, true);
            if (!annotations.isEmpty()) {
                if (rules.plainText) {
                    this.setAnnotationsAtOffset(i, emptySet);
                } else if (setToRemove.getLength()) {
                    annotations.removeSet(setToRemove);
                    this.setAnnotationsAtOffset(i, annotations);
                }
            }
            if (this.isOpenElementData(i)) {
                if (rules.nodeSanitization) {
                    nodeClass = ve.dm.modelRegistry.lookup(this.getType(i));
                    nodeClass.static.sanitize(this.getData(i), rules);
                }
                if (rules.removeOriginalDomElements) {
                    delete this.getData(i).originalDomElementsHash;
                }
            }
        }
    }
    ;
    ve.dm.ElementLinearData.prototype.cloneElements = function(preserveGenerated) {
        var i, len, nodeClass, store = this.getStore();
        for (i = 0,
        len = this.getLength(); i < len; i++) {
            if (this.isOpenElementData(i)) {
                nodeClass = ve.dm.nodeFactory.lookup(this.getType(i));
                if (nodeClass) {
                    this.setData(i, nodeClass.static.cloneElement(this.getData(i), store, preserveGenerated));
                }
            }
        }
    }
    ;
    ve.dm.ElementLinearData.prototype.countNonInternalElements = function(limit) {
        var i, l, type, internalDepth = 0, count = 0;
        for (i = 0,
        l = this.getLength(); i < l; i++) {
            type = this.getType(i);
            if (type && ve.dm.nodeFactory.isNodeInternal(type)) {
                if (this.isOpenElementData(i)) {
                    internalDepth++;
                } else {
                    internalDepth--;
                }
            } else if (!internalDepth) {
                count++;
                if (limit && count >= limit) {
                    return count;
                }
            }
        }
        return count;
    }
    ;
    ve.dm.ElementLinearData.prototype.hasContent = function() {
        return this.countNonInternalElements(3) > 2 || (this.isElementData(0) && !ve.dm.nodeFactory.canNodeContainContent(this.getType(0)) && !ve.dm.nodeFactory.isNodeInternal(this.getType(0)));
    }
    ;
    ve.dm.ElementLinearData.prototype.getCommonAnnotationArrayLength = function(range) {
        var i, annotationHashesForOffset = [];
        for (i = range.start; i < range.end; i++) {
            annotationHashesForOffset.push(this.getAnnotationHashesFromOffset(i));
        }
        return ve.getCommonStartSequenceLength(annotationHashesForOffset);
    }
    ;
    ve.dm.GeneratedContentNode = function VeDmGeneratedContentNode() {}
    ;
    OO.initClass(ve.dm.GeneratedContentNode);
    ve.dm.GeneratedContentNode.static.storeGeneratedContents = function(dataElement, generatedContents, store) {
        var hash = OO.getHash([this.getHashObjectForRendering(dataElement), undefined]);
        return store.hash(generatedContents, hash);
    }
    ;
    ve.dm.GeneratedContentNode.static.getHashObjectForRendering = function(dataElement) {
        return this.getHashObject(dataElement);
    }
    ;
    ve.dm.GeneratedContentNode.prototype.getHashObjectForRendering = function() {
        return this.constructor.static.getHashObjectForRendering(this.element);
    }
    ;
    ve.dm.AlienNode = function VeDmAlienNode() {
        ve.dm.AlienNode.super.apply(this, arguments);
        ve.dm.FocusableNode.call(this);
    }
    ;
    OO.inheritClass(ve.dm.AlienNode, ve.dm.LeafNode);
    OO.mixinClass(ve.dm.AlienNode, ve.dm.FocusableNode);
    ve.dm.AlienNode.static.name = 'alien';
    ve.dm.AlienNode.static.preserveHtmlAttributes = !1;
    ve.dm.AlienNode.static.enableAboutGrouping = !0;
    ve.dm.AlienNode.static.matchRdfaTypes = ['ve:Alien'];
    ve.dm.AlienNode.static.toDataElement = function(domElements, converter) {
        var element, attributes, isInline = this.isHybridInline(domElements, converter), type = isInline ? 'alienInline' : 'alienBlock';
        if (domElements.length === 1 && ['td', 'th'].indexOf(domElements[0].nodeName.toLowerCase()) !== -1) {
            attributes = {};
            ve.dm.TableCellableNode.static.setAttributes(attributes, domElements);
            element = {
                type: 'alienTableCell',
                attributes: attributes
            };
        } else {
            element = {
                type: type
            };
        }
        return element;
    }
    ;
    ve.dm.AlienNode.static.toDomElements = function(dataElement, doc, converter) {
        return ve.copyDomElements(converter.getStore().value(dataElement.originalDomElementsHash) || [], doc);
    }
    ;
    ve.dm.AlienNode.static.isDiffComparable = function(element, other, elementStore, otherStore) {
        var elementOriginalDomElements, otherOriginalDomElements;
        if (element.type === other.type && element.originalDomElementsHash === other.originalDomElementsHash) {
            return true;
        }
        function removeAboutAttributes(element) {
            Array.prototype.forEach.call(element.querySelectorAll('[about]'), function(el) {
                el.removeAttribute('about');
            });
        }
        elementOriginalDomElements = ve.copy(elementStore.value(element.originalDomElementsHash));
        otherOriginalDomElements = ve.copy(otherStore.value(other.originalDomElementsHash));
        elementOriginalDomElements.forEach(removeAboutAttributes);
        otherOriginalDomElements.forEach(removeAboutAttributes);
        return ve.compare(ve.copy(elementOriginalDomElements, ve.convertDomElements), ve.copy(otherOriginalDomElements, ve.convertDomElements));
    }
    ;
    ve.dm.AlienNode.static.getHashObject = function(dataElement) {
        return {
            type: dataElement.type,
            alienDomElementsHash: dataElement.originalDomElementsHash
        };
    }
    ;
    ve.dm.AlienBlockNode = function VeDmAlienBlockNode() {
        ve.dm.AlienBlockNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.AlienBlockNode, ve.dm.AlienNode);
    ve.dm.AlienBlockNode.static.name = 'alienBlock';
    ve.dm.modelRegistry.register(ve.dm.AlienBlockNode);
    ve.dm.AlienInlineNode = function VeDmAlienInlineNode() {
        ve.dm.AlienInlineNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.AlienInlineNode, ve.dm.AlienNode);
    ve.dm.AlienInlineNode.static.name = 'alienInline';
    ve.dm.AlienInlineNode.static.isContent = !0;
    ve.dm.modelRegistry.register(ve.dm.AlienInlineNode);
    ve.dm.AlienTableCellNode = function VeDmAlienTableCellNode() {
        ve.dm.AlienTableCellNode.super.apply(this, arguments);
        ve.dm.TableCellableNode.call(this);
    }
    ;
    OO.inheritClass(ve.dm.AlienTableCellNode, ve.dm.AlienNode);
    OO.mixinClass(ve.dm.AlienTableCellNode, ve.dm.TableCellableNode);
    ve.dm.AlienTableCellNode.static.name = 'alienTableCell';
    ve.dm.modelRegistry.register(ve.dm.AlienTableCellNode);
    ve.dm.ArticleNode = function VeDmArticleNode() {
        ve.dm.ArticleNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.ArticleNode, ve.dm.BranchNode);
    ve.dm.ArticleNode.static.name = 'article';
    ve.dm.ArticleNode.static.isUnwrappable = !1;
    ve.dm.ArticleNode.static.matchTagNames = ['article'];
    ve.dm.ArticleNode.prototype.canHaveSlugBefore = function() {
        return false;
    }
    ;
    ve.dm.ArticleNode.prototype.canHaveSlugAfter = function() {
        return false;
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.ArticleNode);
    ve.dm.BlockquoteNode = function VeDmBlockquoteNode() {
        ve.dm.BlockquoteNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.BlockquoteNode, ve.dm.BranchNode);
    ve.dm.BlockquoteNode.static.name = 'blockquote';
    ve.dm.BlockquoteNode.static.matchTagNames = ['blockquote'];
    ve.dm.modelRegistry.register(ve.dm.BlockquoteNode);
    ve.dm.BreakNode = function VeDmBreakNode() {
        ve.dm.BreakNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.BreakNode, ve.dm.LeafNode);
    ve.dm.BreakNode.static.name = 'break';
    ve.dm.BreakNode.static.isContent = !0;
    ve.dm.BreakNode.static.matchTagNames = ['br'];
    ve.dm.modelRegistry.register(ve.dm.BreakNode);
    ve.dm.CenterNode = function VeDmCenterNode() {
        ve.dm.CenterNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.CenterNode, ve.dm.BranchNode);
    ve.dm.CenterNode.static.name = 'center';
    ve.dm.CenterNode.static.matchTagNames = ['center'];
    ve.dm.modelRegistry.register(ve.dm.CenterNode);
    ve.dm.CommentNode = function VeDmCommentNode(element) {
        ve.dm.CommentNode.super.call(this, element);
        ve.dm.FocusableNode.call(this);
    }
    ;
    OO.inheritClass(ve.dm.CommentNode, ve.dm.LeafNode);
    OO.mixinClass(ve.dm.CommentNode, ve.dm.FocusableNode);
    ve.dm.CommentNode.static.isContent = !0;
    ve.dm.CommentNode.static.preserveHtmlAttributes = !1;
    ve.dm.CommentNode.static.toDataElement = function(domElements, converter) {
        var textarea, text;
        if (domElements[0].nodeType === Node.COMMENT_NODE) {
            textarea = document.createElement('textarea');
            textarea.innerHTML = domElements[0].data;
            text = textarea.textContent;
        } else {
            text = domElements[0].getAttribute('data-ve-comment');
        }
        return {
            type: converter.isValidChildNodeType('comment') && text !== '' ? 'comment' : 'commentMeta',
            attributes: {
                text: text
            }
        };
    }
    ;
    ve.dm.CommentNode.static.toDomElements = function(dataElement, doc, converter) {
        var span, data, modelNode, viewNode, els;
        if (converter.isForClipboard()) {
            span = doc.createElement('span');
            span.setAttribute('rel', 've:Comment');
            span.setAttribute('data-ve-comment', dataElement.attributes.text);
            span.appendChild(doc.createTextNode('\u00a0'));
            return [span];
        } else if (converter.isForPreview()) {
            modelNode = ve.dm.nodeFactory.createFromElement(dataElement);
            modelNode.setDocument(converter.internalList.getDocument());
            viewNode = ve.ce.nodeFactory.createFromModel(modelNode);
            viewNode.updateInvisibleIconSync(true);
            viewNode.$element.attr('title', dataElement.attributes.text);
            els = viewNode.$element.toArray();
            viewNode.destroy();
            return els;
        } else {
            data = dataElement.attributes.text.replace(/[-&>]/g, function(c) {
                return '&#x' + c.charCodeAt(0).toString(16).toUpperCase() + ';';
            });
            return [doc.createComment(data)];
        }
    }
    ;
    ve.dm.CommentNode.static.describeChange = function(key, change) {
        if (key === 'text') {
            return ve.htmlMsg('visualeditor-changedesc-comment', this.wrapText('del', change.from), this.wrapText('ins', change.to));
        }
    }
    ;
    ve.dm.FakeCommentNode = function VeDmFakeCommentNode() {
        ve.dm.FakeCommentNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.FakeCommentNode, ve.dm.CommentNode);
    ve.dm.FakeCommentNode.static.name = 'fakeComment';
    ve.dm.FakeCommentNode.static.matchRdfaTypes = ['ve:Comment'];
    ve.dm.modelRegistry.register(ve.dm.FakeCommentNode);
    ve.dm.RealCommentNode = function VeDmRealCommentNode() {
        ve.dm.RealCommentNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.RealCommentNode, ve.dm.CommentNode);
    ve.dm.RealCommentNode.static.name = 'comment';
    ve.dm.RealCommentNode.static.matchTagNames = ['#comment'];
    ve.dm.modelRegistry.register(ve.dm.RealCommentNode);
    ve.dm.DefinitionListItemNode = function VeDmDefinitionListItemNode() {
        ve.dm.DefinitionListItemNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.DefinitionListItemNode, ve.dm.BranchNode);
    ve.dm.DefinitionListItemNode.static.name = 'definitionListItem';
    ve.dm.DefinitionListItemNode.static.parentNodeTypes = ['definitionList'];
    ve.dm.DefinitionListItemNode.static.defaultAttributes = {
        style: 'term'
    };
    ve.dm.DefinitionListItemNode.static.matchTagNames = ['dt', 'dd'];
    ve.dm.DefinitionListItemNode.static.toDataElement = function(domElements) {
        var style = domElements[0].nodeName.toLowerCase() === 'dt' ? 'term' : 'definition';
        return {
            type: this.name,
            attributes: {
                style: style
            }
        };
    }
    ;
    ve.dm.DefinitionListItemNode.static.toDomElements = function(dataElement, doc) {
        var tag = dataElement.attributes && dataElement.attributes.style === 'term' ? 'dt' : 'dd';
        return [doc.createElement(tag)];
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.DefinitionListItemNode);
    ve.dm.DefinitionListNode = function VeDmDefinitionListNode() {
        ve.dm.DefinitionListNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.DefinitionListNode, ve.dm.BranchNode);
    ve.dm.DefinitionListNode.static.name = 'definitionList';
    ve.dm.DefinitionListNode.static.childNodeTypes = ['definitionListItem'];
    ve.dm.DefinitionListNode.static.matchTagNames = ['dl'];
    ve.dm.DefinitionListNode.static.isDiffedAsList = !0;
    ve.dm.modelRegistry.register(ve.dm.DefinitionListNode);
    ve.dm.DivNode = function VeDmDivNode() {
        ve.dm.DivNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.DivNode, ve.dm.BranchNode);
    ve.dm.DivNode.static.name = 'div';
    ve.dm.DivNode.static.matchTagNames = ['div'];
    ve.dm.modelRegistry.register(ve.dm.DivNode);
    ve.dm.DocumentNode = function VeDmDocumentNode(children) {
        ve.dm.DocumentNode.super.call(this, null, children);
        this.root = this;
    }
    ;
    OO.inheritClass(ve.dm.DocumentNode, ve.dm.BranchNode);
    ve.dm.DocumentNode.static.name = 'document';
    ve.dm.DocumentNode.static.isWrapped = !1;
    ve.dm.DocumentNode.static.parentNodeTypes = [];
    ve.dm.DocumentNode.static.matchTagNames = [];
    ve.dm.DocumentNode.prototype.getElement = ve.dm.DocumentNode.prototype.getAttribute = ve.dm.DocumentNode.prototype.getAttributes = ve.dm.DocumentNode.prototype.getOriginalDomElements = ve.dm.DocumentNode.prototype.getClonedElement = ve.dm.DocumentNode.prototype.getHashObject = function() {
        throw new Error('DocumentNodes do not exist in the linear model');
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.DocumentNode);
    ve.dm.HeadingNode = function VeDmHeadingNode() {
        ve.dm.HeadingNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.HeadingNode, ve.dm.ContentBranchNode);
    ve.dm.HeadingNode.static.name = 'heading';
    ve.dm.HeadingNode.static.defaultAttributes = {
        level: 1
    };
    ve.dm.HeadingNode.static.matchTagNames = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
    ve.dm.HeadingNode.static.toDataElement = function(domElements) {
        var levels = {
            h1: 1,
            h2: 2,
            h3: 3,
            h4: 4,
            h5: 5,
            h6: 6
        }
          , level = levels[domElements[0].nodeName.toLowerCase()];
        return {
            type: this.name,
            attributes: {
                level: level
            }
        };
    }
    ;
    ve.dm.HeadingNode.static.toDomElements = function(dataElement, doc) {
        var level = dataElement.attributes && dataElement.attributes.level || 1;
        return [doc.createElement('h' + level)];
    }
    ;
    ve.dm.HeadingNode.static.describeChange = function(key, change) {
        if (key === 'level') {
            return ve.htmlMsg('visualeditor-changedesc-no-key', this.wrapText('del', ve.msg('visualeditor-formatdropdown-format-heading' + change.from)), this.wrapText('ins', ve.msg('visualeditor-formatdropdown-format-heading' + change.to)));
        }
        return ve.dm.HeadingNode.parent.static.describeChange.apply(this, arguments);
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.HeadingNode);
    ve.dm.HorizontalRuleNode = function VeDmHorizontalRuleNode() {
        ve.dm.HorizontalRuleNode.super.apply(this, arguments);
        ve.dm.FocusableNode.call(this);
    }
    ;
    OO.inheritClass(ve.dm.HorizontalRuleNode, ve.dm.LeafNode);
    OO.mixinClass(ve.dm.HorizontalRuleNode, ve.dm.FocusableNode);
    ve.dm.HorizontalRuleNode.static.name = 'horizontalRule';
    ve.dm.HorizontalRuleNode.static.matchTagNames = ['hr'];
    ve.dm.modelRegistry.register(ve.dm.HorizontalRuleNode);
    ve.dm.InternalItemNode = function VeDmInternalItemNode() {
        ve.dm.InternalItemNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.InternalItemNode, ve.dm.BranchNode);
    ve.dm.InternalItemNode.static.name = 'internalItem';
    ve.dm.InternalItemNode.static.matchTagNames = [];
    ve.dm.InternalItemNode.static.ignoreChildren = !0;
    ve.dm.InternalItemNode.static.isInternal = !0;
    ve.dm.InternalItemNode.static.isDeletable = !1;
    ve.dm.InternalItemNode.static.parentNodeTypes = ['internalList'];
    ve.dm.InternalItemNode.static.describeChanges = function() {
        return [];
    }
    ;
    ve.dm.InternalItemNode.static.getHashObject = function(dataElement) {
        return {
            type: dataElement.type
        };
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.InternalItemNode);
    ve.dm.InternalListNode = function VeDmInternalListNode() {
        ve.dm.InternalListNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.InternalListNode, ve.dm.BranchNode);
    ve.dm.InternalListNode.static.name = 'internalList';
    ve.dm.InternalListNode.static.childNodeTypes = ['internalItem'];
    ve.dm.InternalListNode.static.matchTagNames = [];
    ve.dm.InternalListNode.static.isInternal = !0;
    ve.dm.InternalListNode.static.isDeletable = !1;
    ve.dm.modelRegistry.register(ve.dm.InternalListNode);
    ve.dm.ListItemNode = function VeDmListItemNode() {
        ve.dm.ListItemNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.ListItemNode, ve.dm.BranchNode);
    ve.dm.ListItemNode.static.name = 'listItem';
    ve.dm.ListItemNode.static.parentNodeTypes = ['list'];
    ve.dm.ListItemNode.static.matchTagNames = ['li'];
    ve.dm.modelRegistry.register(ve.dm.ListItemNode);
    ve.dm.ListNode = function VeDmListNode() {
        ve.dm.ListNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.ListNode, ve.dm.BranchNode);
    ve.dm.ListNode.static.name = 'list';
    ve.dm.ListNode.static.childNodeTypes = ['listItem'];
    ve.dm.ListNode.static.defaultAttributes = {
        style: 'bullet'
    };
    ve.dm.ListNode.static.matchTagNames = ['ul', 'ol'];
    ve.dm.ListNode.static.isDiffedAsList = !0;
    ve.dm.ListNode.static.createItem = function() {
        return {
            type: 'listItem'
        };
    }
    ;
    ve.dm.ListNode.static.toDataElement = function(domElements) {
        var style = domElements[0].nodeName.toLowerCase() === 'ol' ? 'number' : 'bullet';
        return {
            type: this.name,
            attributes: {
                style: style
            }
        };
    }
    ;
    ve.dm.ListNode.static.toDomElements = function(dataElement, doc) {
        var tag = dataElement.attributes && dataElement.attributes.style === 'number' ? 'ol' : 'ul';
        return [doc.createElement(tag)];
    }
    ;
    ve.dm.ListNode.static.describeChange = function(key, change) {
        if (key === 'style') {
            return ve.htmlMsg('visualeditor-changedesc-no-key', this.wrapText('del', ve.msg('visualeditor-listbutton-' + change.from + '-tooltip')), this.wrapText('ins', ve.msg('visualeditor-listbutton-' + change.to + '-tooltip')));
        }
        return ve.dm.ListNode.parent.static.describeChange.apply(this, arguments);
    }
    ;
    ve.dm.ListNode.prototype.canHaveSlugAfter = function() {
        return false;
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.ListNode);
    ve.dm.ParagraphNode = function VeDmParagraphNode() {
        ve.dm.ParagraphNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.ParagraphNode, ve.dm.ContentBranchNode);
    ve.dm.ParagraphNode.static.name = 'paragraph';
    ve.dm.ParagraphNode.static.matchTagNames = ['p'];
    ve.dm.modelRegistry.register(ve.dm.ParagraphNode);
    ve.dm.PreformattedNode = function VeDmPreformattedNode() {
        ve.dm.PreformattedNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.PreformattedNode, ve.dm.ContentBranchNode);
    ve.dm.PreformattedNode.static.name = 'preformatted';
    ve.dm.PreformattedNode.static.hasSignificantWhitespace = !0;
    ve.dm.PreformattedNode.static.matchTagNames = ['pre'];
    ve.dm.modelRegistry.register(ve.dm.PreformattedNode);
    ve.dm.SectionNode = function VeDmSectionNode() {
        ve.dm.SectionNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.SectionNode, ve.dm.BranchNode);
    ve.dm.SectionNode.static.name = 'section';
    ve.dm.SectionNode.static.isUnwrappable = !1;
    ve.dm.SectionNode.static.defaultAttributes = {
        style: 'section'
    };
    ve.dm.SectionNode.static.matchTagNames = ['header', 'section', 'footer'];
    ve.dm.SectionNode.static.toDataElement = function(domElements) {
        return {
            type: this.name,
            attributes: {
                style: domElements[0].nodeName.toLowerCase()
            }
        };
    }
    ;
    ve.dm.SectionNode.static.toDomElements = function(dataElement, doc) {
        var style = dataElement.attributes && dataElement.attributes.style || 'section';
        return [doc.createElement(style)];
    }
    ;
    ve.dm.SectionNode.prototype.canHaveSlugBefore = function() {
        return false;
    }
    ;
    ve.dm.SectionNode.prototype.canHaveSlugAfter = function() {
        return false;
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.SectionNode);
    ve.dm.TableCaptionNode = function VeDmTableCaptionNode() {
        ve.dm.TableCaptionNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.TableCaptionNode, ve.dm.BranchNode);
    ve.dm.TableCaptionNode.static.name = 'tableCaption';
    ve.dm.TableCaptionNode.static.parentNodeTypes = ['table'];
    ve.dm.TableCaptionNode.static.matchTagNames = ['caption'];
    ve.dm.modelRegistry.register(ve.dm.TableCaptionNode);
    ve.dm.TableCellNode = function VeDmTableCellNode() {
        ve.dm.TableCellNode.super.apply(this, arguments);
        ve.dm.TableCellableNode.call(this);
    }
    ;
    OO.inheritClass(ve.dm.TableCellNode, ve.dm.BranchNode);
    OO.mixinClass(ve.dm.TableCellNode, ve.dm.TableCellableNode);
    ve.dm.TableCellNode.static.name = 'tableCell';
    ve.dm.TableCellNode.static.isUnwrappable = !1;
    ve.dm.TableCellNode.static.parentNodeTypes = ['tableRow'];
    ve.dm.TableCellNode.static.defaultAttributes = {
        style: 'data'
    };
    ve.dm.TableCellNode.static.matchTagNames = ['td', 'th'];
    ve.dm.TableCellNode.static.isCellEditable = !0;
    ve.dm.TableCellNode.static.preserveHtmlAttributes = function(attribute) {
        return attribute !== 'colspan' && attribute !== 'rowspan';
    }
    ;
    ve.dm.TableCellNode.static.toDataElement = function(domElements) {
        var attributes = {};
        ve.dm.TableCellableNode.static.setAttributes(attributes, domElements);
        return {
            type: this.name,
            attributes: attributes
        };
    }
    ;
    ve.dm.TableCellNode.static.toDomElements = function(dataElement, doc) {
        var tag = dataElement.attributes && dataElement.attributes.style === 'header' ? 'th' : 'td'
          , domElement = doc.createElement(tag)
          , attributes = dataElement.attributes;
        ve.dm.TableCellableNode.static.applyAttributes(attributes, domElement);
        return [domElement];
    }
    ;
    ve.dm.TableCellNode.static.createData = function(options) {
        var opening, content;
        options = options || {};
        opening = {
            type: 'tableCell',
            attributes: {
                style: options.style || 'data',
                rowspan: options.rowspan || 1,
                colspan: options.colspan || 1
            }
        };
        content = options.content || [{
            type: 'paragraph',
            internal: {
                generated: 'wrapper'
            }
        }, {
            type: '/paragraph'
        }];
        return [opening].concat(content).concat([{
            type: '/tableCell'
        }]);
    }
    ;
    ve.dm.TableCellNode.static.describeChange = function(key, change) {
        if (key === 'style') {
            return ve.htmlMsg('visualeditor-changedesc-no-key', this.wrapText('del', ve.msg('visualeditor-table-format-' + change.from)), this.wrapText('ins', ve.msg('visualeditor-table-format-' + change.to)));
        }
        return ve.dm.TableCellNode.parent.static.describeChange.apply(this, arguments);
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.TableCellNode);
    ve.dm.TableNode = function VeDmTableNode() {
        ve.dm.TableNode.super.apply(this, arguments);
        this.matrix = new ve.dm.TableMatrix(this);
        this.connect(this, {
            splice: 'onSplice'
        });
    }
    ;
    OO.inheritClass(ve.dm.TableNode, ve.dm.BranchNode);
    ve.dm.TableNode.static.name = 'table';
    ve.dm.TableNode.static.childNodeTypes = ['tableSection', 'tableCaption'];
    ve.dm.TableNode.static.matchTagNames = ['table'];
    ve.dm.TableNode.prototype.onSplice = function() {
        var i, nodes = Array.prototype.slice.call(arguments, 2);
        this.getMatrix().invalidate();
        for (i = 0; i < nodes.length; i++) {
            nodes[i].connect(this, {
                cellAttributeChange: 'onCellAttributeChange'
            });
        }
    }
    ;
    ve.dm.TableNode.prototype.onCellAttributeChange = function(cell) {
        this.emit('cellAttributeChange', cell);
    }
    ;
    ve.dm.TableNode.prototype.getMatrix = function() {
        return this.matrix;
    }
    ;
    ve.dm.TableNode.prototype.getCaptionNode = function() {
        var i, l;
        for (i = 0,
        l = this.children.length; i < l; i++) {
            if (this.children[i]instanceof ve.dm.TableCaptionNode) {
                return this.children[i];
            }
        }
        return null;
    }
    ;
    ve.dm.TableNode.prototype.getIterator = function() {
        return new ve.dm.TableNodeCellIterator(this);
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.TableNode);
    ve.dm.TableNodeCellIterator = function VeDmTableNodeCellIterator(tableNode) {
        OO.EventEmitter.call(this);
        this.table = tableNode;
        this.sectionIndex = 0;
        this.rowIndex = 0;
        this.cellIndex = 0;
        this.sectionCount = this.table.children.length;
        this.rowCount = 0;
        this.cellCount = 0;
        this.sectionNode = null;
        this.rowNode = null;
        this.cellNode = null;
        this.finished = !1;
    }
    ;
    OO.mixinClass(ve.dm.TableNodeCellIterator, OO.EventEmitter);
    ve.dm.TableNodeCellIterator.prototype.isFinished = function() {
        return this.finished;
    }
    ;
    ve.dm.TableNodeCellIterator.prototype.next = function() {
        if (this.isFinished()) {
            throw new Error('TableNodeCellIterator has no more cells left.');
        }
        this.nextCell(this);
        return this.cellNode;
    }
    ;
    ve.dm.TableNodeCellIterator.prototype.nextSection = function() {
        var sectionNode;
        if (this.sectionIndex >= this.sectionCount) {
            this.finished = !0;
            this.sectionNode = undefined;
            return;
        }
        sectionNode = this.table.children[this.sectionIndex];
        this.sectionIndex++;
        this.rowIndex = 0;
        if (sectionNode instanceof ve.dm.TableSectionNode) {
            this.sectionNode = sectionNode;
            this.rowCount = this.sectionNode.children.length;
            this.emit('newSection', this.sectionNode);
        } else {
            this.nextSection();
            return;
        }
    }
    ;
    ve.dm.TableNodeCellIterator.prototype.nextRow = function() {
        var rowNode;
        if (this.rowIndex >= this.rowCount) {
            this.nextSection();
            if (this.isFinished()) {
                this.rowNode = undefined;
                return;
            }
        }
        rowNode = this.sectionNode.children[this.rowIndex];
        this.rowIndex++;
        this.cellIndex = 0;
        if (rowNode instanceof ve.dm.TableRowNode) {
            this.rowNode = rowNode;
            this.cellCount = this.rowNode.children.length;
            this.emit('newRow', this.rowNode);
        } else {
            this.nextRow();
            return;
        }
    }
    ;
    ve.dm.TableNodeCellIterator.prototype.nextCell = function() {
        var cellNode;
        if (!this.sectionNode) {
            this.nextSection();
        }
        if (!this.rowNode) {
            this.nextRow();
        }
        if (this.cellIndex >= this.cellCount) {
            this.nextRow();
            if (this.isFinished()) {
                this.cellNode = undefined;
                return;
            }
        }
        cellNode = this.rowNode.children[this.cellIndex];
        this.cellNode = cellNode && cellNode.isCellable() ? cellNode : null;
        this.cellIndex++;
    }
    ;
    ve.dm.TableRowNode = function VeDmTableRowNode() {
        ve.dm.TableRowNode.super.apply(this, arguments);
        this.connect(this, {
            splice: 'onSplice'
        });
    }
    ;
    OO.inheritClass(ve.dm.TableRowNode, ve.dm.BranchNode);
    ve.dm.TableRowNode.static.name = 'tableRow';
    ve.dm.TableRowNode.static.childNodeTypes = ['tableCell', 'alienTableCell'];
    ve.dm.TableRowNode.static.parentNodeTypes = ['tableSection'];
    ve.dm.TableRowNode.static.matchTagNames = ['tr'];
    ve.dm.TableRowNode.static.createData = function(options) {
        var i, cellCount, data = [];
        options = options || {};
        cellCount = options.cellCount || 1;
        data.push({
            type: 'tableRow'
        });
        for (i = 0; i < cellCount; i++) {
            data = data.concat(ve.dm.TableCellNode.static.createData({
                style: Array.isArray(options.style) ? options.style[i] : options.style
            }));
        }
        data.push({
            type: '/tableRow'
        });
        return data;
    }
    ;
    ve.dm.TableRowNode.prototype.onSplice = function() {
        var i, nodes = Array.prototype.slice.call(arguments, 2);
        if (this.getRoot()) {
            this.getParent().getParent().getMatrix().invalidate();
        }
        for (i = 0; i < nodes.length; i++) {
            nodes[i].connect(this, {
                attributeChange: ['onCellAttributeChange', nodes[i]]
            });
        }
    }
    ;
    ve.dm.TableRowNode.prototype.onCellAttributeChange = function(cell) {
        this.emit('cellAttributeChange', cell);
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.TableRowNode);
    ve.dm.TableSectionNode = function VeDmTableSectionNode() {
        ve.dm.TableSectionNode.super.apply(this, arguments);
        this.connect(this, {
            splice: 'onSplice'
        });
    }
    ;
    OO.inheritClass(ve.dm.TableSectionNode, ve.dm.BranchNode);
    ve.dm.TableSectionNode.static.name = 'tableSection';
    ve.dm.TableSectionNode.static.childNodeTypes = ['tableRow'];
    ve.dm.TableSectionNode.static.parentNodeTypes = ['table'];
    ve.dm.TableSectionNode.static.defaultAttributes = {
        style: 'body'
    };
    ve.dm.TableSectionNode.static.matchTagNames = ['thead', 'tbody', 'tfoot'];
    ve.dm.TableSectionNode.static.toDataElement = function(domElements) {
        var styles = {
            thead: 'header',
            tbody: 'body',
            tfoot: 'footer'
        }
          , style = styles[domElements[0].nodeName.toLowerCase()] || 'body';
        return {
            type: this.name,
            attributes: {
                style: style
            }
        };
    }
    ;
    ve.dm.TableSectionNode.static.toDomElements = function(dataElement, doc) {
        var tags = {
            header: 'thead',
            body: 'tbody',
            footer: 'tfoot'
        }
          , tag = tags[dataElement.attributes && dataElement.attributes.style || 'body'];
        return [doc.createElement(tag)];
    }
    ;
    ve.dm.TableSectionNode.prototype.onSplice = function() {
        var i, nodes = Array.prototype.slice.call(arguments, 2);
        if (this.getRoot()) {
            this.getParent().getMatrix().invalidate();
        }
        for (i = 0; i < nodes.length; i++) {
            nodes[i].connect(this, {
                cellAttributeChange: 'onCellAttributeChange'
            });
        }
    }
    ;
    ve.dm.TableSectionNode.prototype.onCellAttributeChange = function(cell) {
        this.emit('cellAttributeChange', cell);
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.TableSectionNode);
    ve.dm.TextNode = function VeDmTextNode(length) {
        ve.dm.TextNode.super.call(this);
        this.length = length || 0;
    }
    ;
    OO.inheritClass(ve.dm.TextNode, ve.dm.LeafNode);
    ve.dm.TextNode.static.name = 'text';
    ve.dm.TextNode.static.isWrapped = !1;
    ve.dm.TextNode.static.isContent = !0;
    ve.dm.TextNode.static.matchTagNames = [];
    ve.dm.TextNode.prototype.canHaveSlugBefore = function() {
        return false;
    }
    ;
    ve.dm.TextNode.prototype.canHaveSlugAfter = function() {
        return false;
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.TextNode);
    ve.dm.ImageNode = function VeDmImageNode() {
        ve.dm.FocusableNode.call(this);
        ve.dm.ResizableNode.call(this);
    }
    ;
    OO.mixinClass(ve.dm.ImageNode, ve.dm.FocusableNode);
    OO.mixinClass(ve.dm.ImageNode, ve.dm.ResizableNode);
    ve.dm.ImageNode.static.isDiffComparable = function(element, other) {
        return element.type === other.type && element.attributes.src === other.attributes.src;
    }
    ;
    ve.dm.ImageNode.static.describeChanges = function(attributeChanges, attributes) {
        var key, sizeFrom, sizeTo, change, customKeys = ['width', 'height'], descriptions = [];
        function describeSize(width, height) {
            return width + ve.msg('visualeditor-dimensionswidget-times') + height + ve.msg('visualeditor-dimensionswidget-px');
        }
        if ('width'in attributeChanges || 'height'in attributeChanges) {
            sizeFrom = describeSize('width'in attributeChanges ? attributeChanges.width.from : attributes.width, 'height'in attributeChanges ? attributeChanges.height.from : attributes.height);
            sizeTo = describeSize('width'in attributeChanges ? attributeChanges.width.to : attributes.width, 'height'in attributeChanges ? attributeChanges.height.to : attributes.height);
            descriptions.push(ve.htmlMsg('visualeditor-changedesc-image-size', this.wrapText('del', sizeFrom), this.wrapText('ins', sizeTo)));
        }
        for (key in attributeChanges) {
            if (customKeys.indexOf(key) === -1) {
                change = this.describeChange(key, attributeChanges[key]);
                descriptions.push(change);
            }
        }
        return descriptions;
    }
    ;
    ve.dm.ImageNode.static.describeChange = function(key, change) {
        if (key === 'align') {
            return ve.htmlMsg('visualeditor-changedesc-align', this.wrapText('del', ve.msg('visualeditor-align-desc-' + change.from)), this.wrapText('ins', ve.msg('visualeditor-align-desc-' + change.to)));
        }
        return ve.dm.Node.static.describeChange.apply(this, arguments);
    }
    ;
    ve.dm.ImageNode.prototype.createScalable = function() {
        return new ve.dm.Scalable({
            currentDimensions: {
                width: this.getAttribute('width'),
                height: this.getAttribute('height')
            },
            minDimensions: {
                width: 1,
                height: 1
            }
        });
    }
    ;
    ve.dm.BlockImageNode = function VeDmBlockImageNode() {
        ve.dm.BlockImageNode.super.apply(this, arguments);
        ve.dm.ImageNode.call(this);
        ve.dm.AlignableNode.call(this);
    }
    ;
    OO.inheritClass(ve.dm.BlockImageNode, ve.dm.BranchNode);
    OO.mixinClass(ve.dm.BlockImageNode, ve.dm.ImageNode);
    OO.mixinClass(ve.dm.BlockImageNode, ve.dm.ClassAttributeNode);
    OO.mixinClass(ve.dm.BlockImageNode, ve.dm.AlignableNode);
    ve.dm.BlockImageNode.static.name = 'blockImage';
    ve.dm.BlockImageNode.static.preserveHtmlAttributes = function(attribute) {
        var attributes = ['class', 'src', 'width', 'height'];
        return attributes.indexOf(attribute) === -1;
    }
    ;
    ve.dm.BlockImageNode.static.handlesOwnChildren = !0;
    ve.dm.BlockImageNode.static.ignoreChildren = !0;
    ve.dm.BlockImageNode.static.childNodeTypes = ['imageCaption'];
    ve.dm.BlockImageNode.static.matchTagNames = ['figure'];
    ve.dm.BlockImageNode.static.matchFunction = function(element) {
        return element.children[0] && element.children[0].nodeName === 'IMG';
    }
    ;
    ve.dm.BlockImageNode.static.toDataElement = function(domElements, converter) {
        var dataElement, figure, classAttr, img, caption, attributes, width, height;
        figure = domElements[0];
        classAttr = figure.getAttribute('class');
        img = figure.children[0];
        width = img.getAttribute('width');
        height = img.getAttribute('height');
        caption = figure.children[1];
        attributes = {
            src: img.getAttribute('src'),
            width: width !== null && width !== '' ? +width : null,
            height: height !== null && height !== '' ? +height : null,
            alt: img.getAttribute('alt')
        };
        this.setClassAttributes(attributes, classAttr);
        dataElement = {
            type: this.name,
            attributes: attributes
        };
        if (!caption) {
            return [dataElement, {
                type: 'imageCaption'
            }, {
                type: 'imageCaption'
            }, {
                type: '/' + this.name
            }];
        } else {
            return [dataElement].concat(converter.getDataFromDomClean(caption, {
                type: 'imageCaption'
            })).concat([{
                type: '/' + this.name
            }]);
        }
    }
    ;
    ve.dm.BlockImageNode.static.toDomElements = function(data, doc, converter) {
        var dataElement = data[0]
          , classAttr = this.getClassAttrFromAttributes(dataElement.attributes)
          , figure = doc.createElement('figure')
          , img = doc.createElement('img')
          , wrapper = doc.createElement('div')
          , captionData = data.slice(1, -1);
        ve.setDomAttributes(img, dataElement.attributes, ['alt', 'src', 'width', 'height']);
        figure.appendChild(img);
        if (classAttr) {
            figure.className = classAttr;
        }
        if (captionData.length > 2) {
            converter.getDomSubtreeFromData(data.slice(1, -1), wrapper);
            while (wrapper.firstChild) {
                figure.appendChild(wrapper.firstChild);
            }
        }
        return [figure];
    }
    ;
    ve.dm.BlockImageNode.prototype.getCaptionNode = function() {
        var node = this.children[0];
        return node instanceof ve.dm.BlockImageCaptionNode ? node : null;
    }
    ;
    ve.dm.BlockImageNode.prototype.suppressSlugType = function() {
        return this.getAttribute('align') !== 'center' ? 'float' : null;
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.BlockImageNode);
    ve.dm.BlockImageCaptionNode = function VeDmBlockImageCaptionNode() {
        ve.dm.BlockImageCaptionNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.BlockImageCaptionNode, ve.dm.BranchNode);
    ve.dm.BlockImageCaptionNode.static.name = 'imageCaption';
    ve.dm.BlockImageCaptionNode.static.matchTagNames = [];
    ve.dm.BlockImageCaptionNode.static.parentNodeTypes = ['blockImage'];
    ve.dm.BlockImageCaptionNode.static.toDomElements = function(dataElement, doc) {
        return [doc.createElement('figcaption')];
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.BlockImageCaptionNode);
    ve.dm.InlineImageNode = function VeDmInlineImageNode() {
        ve.dm.InlineImageNode.super.apply(this, arguments);
        ve.dm.ImageNode.call(this);
    }
    ;
    OO.inheritClass(ve.dm.InlineImageNode, ve.dm.LeafNode);
    OO.mixinClass(ve.dm.InlineImageNode, ve.dm.ImageNode);
    ve.dm.InlineImageNode.static.name = 'inlineImage';
    ve.dm.InlineImageNode.static.isContent = !0;
    ve.dm.InlineImageNode.static.matchTagNames = ['img'];
    ve.dm.InlineImageNode.static.toDataElement = function(domElements) {
        var domElement = domElements[0]
          , alt = domElement.getAttribute('alt')
          , width = domElement.getAttribute('width')
          , height = domElement.getAttribute('height');
        return {
            type: this.name,
            attributes: {
                src: domElement.getAttribute('src'),
                alt: alt,
                width: width !== null && width !== '' ? +width : null,
                height: height !== null && height !== '' ? +height : null
            }
        };
    }
    ;
    ve.dm.InlineImageNode.static.toDomElements = function(dataElement, doc) {
        var domElement = doc.createElement('img');
        ve.setDomAttributes(domElement, dataElement.attributes, ['alt', 'src', 'width', 'height']);
        return [domElement];
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.InlineImageNode);
    ve.dm.LinkAnnotation = function VeDmLinkAnnotation() {
        ve.dm.LinkAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.LinkAnnotation, ve.dm.Annotation);
    ve.dm.LinkAnnotation.static.name = 'link';
    ve.dm.LinkAnnotation.static.matchTagNames = ['a'];
    ve.dm.LinkAnnotation.static.toDataElement = function(domElements) {
        if (!domElements[0].hasAttribute('href')) {
            return ve.dm.SpanAnnotation.static.toDataElement.apply(ve.dm.SpanAnnotation.static, arguments);
        }
        return {
            type: this.name,
            attributes: {
                href: domElements[0].getAttribute('href')
            }
        };
    }
    ;
    ve.dm.LinkAnnotation.static.toDomElements = function(dataElement, doc) {
        var domElement = doc.createElement('a');
        domElement.setAttribute('href', this.getHref(dataElement));
        return [domElement];
    }
    ;
    ve.dm.LinkAnnotation.static.describeChange = function(key, change) {
        if (key === 'href') {
            return ve.htmlMsg('visualeditor-changedesc-link-href', this.wrapText('del', change.from), this.wrapText('ins', change.to));
        }
        return ve.dm.LinkAnnotation.parent.static.describeChange.apply(this, arguments);
    }
    ;
    ve.dm.LinkAnnotation.static.getHref = function(dataElement) {
        return dataElement.attributes.href;
    }
    ;
    ve.dm.LinkAnnotation.prototype.getHref = function() {
        return this.constructor.static.getHref(this.element);
    }
    ;
    ve.dm.LinkAnnotation.prototype.getDisplayTitle = function() {
        return this.getHref();
    }
    ;
    ve.dm.LinkAnnotation.prototype.getFragment = function() {
        var href = this.getHref()
          , hash = href.indexOf('#');
        if (hash === -1) {
            return null;
        }
        return href.slice(hash + 1);
    }
    ;
    ve.dm.LinkAnnotation.prototype.getComparableObject = function() {
        return {
            type: this.getType(),
            href: this.getAttribute('href')
        };
    }
    ;
    ve.dm.LinkAnnotation.prototype.getComparableHtmlAttributes = function() {
        var comparableAttributes = ve.dm.LinkAnnotation.super.prototype.getComparableHtmlAttributes.call(this);
        delete comparableAttributes.href;
        return comparableAttributes;
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.LinkAnnotation);
    ve.dm.TextStyleAnnotation = function VeDmTextStyleAnnotation() {
        ve.dm.TextStyleAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.TextStyleAnnotation, ve.dm.Annotation);
    ve.dm.TextStyleAnnotation.static.name = 'textStyle';
    ve.dm.TextStyleAnnotation.static.matchTagNames = [];
    ve.dm.TextStyleAnnotation.static.toDataElement = function(domElements, converter) {
        var nodeName = converter.isFromClipboard() ? this.matchTagNames[0] : domElements[0].nodeName.toLowerCase();
        return {
            type: this.name,
            attributes: {
                nodeName: nodeName
            }
        };
    }
    ;
    ve.dm.TextStyleAnnotation.static.toDomElements = function(dataElement, doc) {
        var nodeName = ve.getProp(dataElement, 'attributes', 'nodeName');
        return [doc.createElement(nodeName || this.matchTagNames[0])];
    }
    ;
    ve.dm.TextStyleAnnotation.prototype.getComparableObject = function() {
        return {
            type: this.getType()
        };
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.TextStyleAnnotation);
    ve.dm.AbbreviationAnnotation = function VeDmAbbreviationAnnotation() {
        ve.dm.AbbreviationAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.AbbreviationAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.AbbreviationAnnotation.static.name = 'textStyle/abbreviation';
    ve.dm.AbbreviationAnnotation.static.matchTagNames = ['abbr'];
    ve.dm.modelRegistry.register(ve.dm.AbbreviationAnnotation);
    ve.dm.BidiAnnotation = function VeDmBidiAnnotation() {
        ve.dm.BidiAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.BidiAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.BidiAnnotation.static.name = 'textStyle/bidi';
    ve.dm.BidiAnnotation.static.matchTagNames = ['bdi'];
    ve.dm.modelRegistry.register(ve.dm.BidiAnnotation);
    ve.dm.BigAnnotation = function VeDmBigAnnotation() {
        ve.dm.BigAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.BigAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.BigAnnotation.static.name = 'textStyle/big';
    ve.dm.BigAnnotation.static.matchTagNames = ['big'];
    ve.dm.BigAnnotation.static.removes = ['textStyle/small'];
    ve.dm.modelRegistry.register(ve.dm.BigAnnotation);
    ve.dm.BoldAnnotation = function VeDmBoldAnnotation() {
        ve.dm.BoldAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.BoldAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.BoldAnnotation.static.name = 'textStyle/bold';
    ve.dm.BoldAnnotation.static.matchTagNames = ['b', 'strong'];
    ve.dm.BoldAnnotation.static.inferFromView = !0;
    ve.dm.modelRegistry.register(ve.dm.BoldAnnotation);
    ve.dm.CodeSampleAnnotation = function VeDmCodeSampleAnnotation() {
        ve.dm.CodeSampleAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.CodeSampleAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.CodeSampleAnnotation.static.name = 'textStyle/codeSample';
    ve.dm.CodeSampleAnnotation.static.matchTagNames = ['samp'];
    ve.dm.modelRegistry.register(ve.dm.CodeSampleAnnotation);
    ve.dm.CodeAnnotation = function VeDmCodeAnnotation() {
        ve.dm.CodeAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.CodeAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.CodeAnnotation.static.name = 'textStyle/code';
    ve.dm.CodeAnnotation.static.matchTagNames = ['code', 'tt'];
    ve.dm.modelRegistry.register(ve.dm.CodeAnnotation);
    ve.dm.DatetimeAnnotation = function VeDmDatetimeAnnotation() {
        ve.dm.DatetimeAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.DatetimeAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.DatetimeAnnotation.static.name = 'textStyle/datetime';
    ve.dm.DatetimeAnnotation.static.matchTagNames = ['time'];
    ve.dm.DatetimeAnnotation.static.toDataElement = function(domElements) {
        var dataElement = ve.dm.DatetimeAnnotation.super.static.toDataElement.apply(this, arguments);
        dataElement.attributes.datetime = domElements[0].getAttribute('datetime');
        return dataElement;
    }
    ;
    ve.dm.DatetimeAnnotation.static.toDomElements = function(dataElement, doc) {
        var domElement = doc.createElement('time');
        if (dataElement.attributes.datetime) {
            domElement.setAttribute('datetime', dataElement.attributes.datetime);
        }
        return [domElement];
    }
    ;
    ve.dm.DatetimeAnnotation.prototype.getComparableObject = function() {
        return {
            type: this.getType(),
            datetime: this.getAttribute('datetime')
        };
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.DatetimeAnnotation);
    ve.dm.DefinitionAnnotation = function VeDmDefinitionAnnotation() {
        ve.dm.DefinitionAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.DefinitionAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.DefinitionAnnotation.static.name = 'textStyle/definition';
    ve.dm.DefinitionAnnotation.static.matchTagNames = ['dfn'];
    ve.dm.modelRegistry.register(ve.dm.DefinitionAnnotation);
    ve.dm.DeleteAnnotation = function VeDmDeleteAnnotation() {
        ve.dm.DeleteAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.DeleteAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.DeleteAnnotation.static.name = 'textStyle/delete';
    ve.dm.DeleteAnnotation.static.matchTagNames = ['del'];
    ve.dm.DeleteAnnotation.static.trimWhitespace = !1;
    ve.dm.modelRegistry.register(ve.dm.DeleteAnnotation);
    ve.dm.FontAnnotation = function VeDmFontAnnotation() {
        ve.dm.FontAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.FontAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.FontAnnotation.static.name = 'textStyle/font';
    ve.dm.FontAnnotation.static.matchTagNames = ['font'];
    ve.dm.modelRegistry.register(ve.dm.FontAnnotation);
    ve.dm.HighlightAnnotation = function VeDmHighlightAnnotation() {
        ve.dm.HighlightAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.HighlightAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.HighlightAnnotation.static.name = 'textStyle/highlight';
    ve.dm.HighlightAnnotation.static.matchTagNames = ['mark'];
    ve.dm.modelRegistry.register(ve.dm.HighlightAnnotation);
    ve.dm.InsertAnnotation = function VeDmInsertAnnotation() {
        ve.dm.InsertAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.InsertAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.InsertAnnotation.static.name = 'textStyle/insert';
    ve.dm.InsertAnnotation.static.matchTagNames = ['ins'];
    ve.dm.InsertAnnotation.static.trimWhitespace = !1;
    ve.dm.modelRegistry.register(ve.dm.InsertAnnotation);
    ve.dm.ItalicAnnotation = function VeDmItalicAnnotation() {
        ve.dm.ItalicAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.ItalicAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.ItalicAnnotation.static.name = 'textStyle/italic';
    ve.dm.ItalicAnnotation.static.matchTagNames = ['i', 'em'];
    ve.dm.ItalicAnnotation.static.inferFromView = !0;
    ve.dm.modelRegistry.register(ve.dm.ItalicAnnotation);
    ve.dm.QuotationAnnotation = function VeDmQuotationAnnotation() {
        ve.dm.QuotationAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.QuotationAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.QuotationAnnotation.static.name = 'textStyle/quotation';
    ve.dm.QuotationAnnotation.static.matchTagNames = ['q'];
    ve.dm.modelRegistry.register(ve.dm.QuotationAnnotation);
    ve.dm.SmallAnnotation = function VeDmSmallAnnotation() {
        ve.dm.SmallAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.SmallAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.SmallAnnotation.static.name = 'textStyle/small';
    ve.dm.SmallAnnotation.static.matchTagNames = ['small'];
    ve.dm.SmallAnnotation.static.removes = ['textStyle/big'];
    ve.dm.modelRegistry.register(ve.dm.SmallAnnotation);
    ve.dm.SpanAnnotation = function VeDmSpanAnnotation() {
        ve.dm.SpanAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.SpanAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.SpanAnnotation.static.name = 'textStyle/span';
    ve.dm.SpanAnnotation.static.matchTagNames = ['span'];
    ve.dm.modelRegistry.register(ve.dm.SpanAnnotation);
    ve.dm.StrikethroughAnnotation = function VeDmStrikethroughAnnotation() {
        ve.dm.StrikethroughAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.StrikethroughAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.StrikethroughAnnotation.static.name = 'textStyle/strikethrough';
    ve.dm.StrikethroughAnnotation.static.matchTagNames = ['s', 'del'];
    ve.dm.modelRegistry.register(ve.dm.StrikethroughAnnotation);
    ve.dm.SubscriptAnnotation = function VeDmSubscriptAnnotation() {
        ve.dm.SubscriptAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.SubscriptAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.SubscriptAnnotation.static.name = 'textStyle/subscript';
    ve.dm.SubscriptAnnotation.static.matchTagNames = ['sub'];
    ve.dm.SubscriptAnnotation.static.removes = ['textStyle/superscript'];
    ve.dm.modelRegistry.register(ve.dm.SubscriptAnnotation);
    ve.dm.SuperscriptAnnotation = function VeDmSuperscriptAnnotation() {
        ve.dm.SuperscriptAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.SuperscriptAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.SuperscriptAnnotation.static.name = 'textStyle/superscript';
    ve.dm.SuperscriptAnnotation.static.matchTagNames = ['sup'];
    ve.dm.SuperscriptAnnotation.static.removes = ['textStyle/subscript'];
    ve.dm.modelRegistry.register(ve.dm.SuperscriptAnnotation);
    ve.dm.UnderlineAnnotation = function VeDmUnderlineAnnotation() {
        ve.dm.UnderlineAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.UnderlineAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.UnderlineAnnotation.static.name = 'textStyle/underline';
    ve.dm.UnderlineAnnotation.static.matchTagNames = ['u'];
    ve.dm.UnderlineAnnotation.static.inferFromView = !0;
    ve.dm.modelRegistry.register(ve.dm.UnderlineAnnotation);
    ve.dm.UserInputAnnotation = function VeDmUserInputAnnotation() {
        ve.dm.UserInputAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.UserInputAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.UserInputAnnotation.static.name = 'textStyle/userInput';
    ve.dm.UserInputAnnotation.static.matchTagNames = ['kbd'];
    ve.dm.modelRegistry.register(ve.dm.UserInputAnnotation);
    ve.dm.VariableAnnotation = function VeDmVariableAnnotation() {
        ve.dm.VariableAnnotation.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.VariableAnnotation, ve.dm.TextStyleAnnotation);
    ve.dm.VariableAnnotation.static.name = 'textStyle/variable';
    ve.dm.VariableAnnotation.static.matchTagNames = ['var'];
    ve.dm.modelRegistry.register(ve.dm.VariableAnnotation);
    ve.dm.AlienMetaItem = function VeDmAlienMetaItem() {
        ve.dm.AlienMetaItem.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.AlienMetaItem, ve.dm.MetaItem);
    ve.dm.AlienMetaItem.static.name = 'alienMeta';
    ve.dm.AlienMetaItem.static.matchTagNames = ['meta', 'link'];
    ve.dm.AlienMetaItem.static.preserveHtmlAttributes = !1;
    ve.dm.AlienMetaItem.static.toDomElements = function(dataElement, doc, converter) {
        return ve.copyDomElements(converter.getStore().value(dataElement.originalDomElementsHash) || [], doc);
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.AlienMetaItem);
    ve.dm.RemovableAlienMetaItem = function VeDmRemovableAlienMetaItem() {
        ve.dm.RemovableAlienMetaItem.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.RemovableAlienMetaItem, ve.dm.AlienMetaItem);
    ve.dm.RemovableAlienMetaItem.static.name = 'removableAlienMeta';
    ve.dm.RemovableAlienMetaItem.static.matchTagNames = [];
    ve.dm.RemovableAlienMetaItem.static.removable = !0;
    ve.dm.modelRegistry.register(ve.dm.RemovableAlienMetaItem);
    ve.dm.CommentMetaItem = function VeDmCommentMetaItem() {
        ve.dm.CommentMetaItem.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.dm.CommentMetaItem, ve.dm.MetaItem);
    ve.dm.CommentMetaItem.static.name = 'commentMeta';
    ve.dm.CommentMetaItem.static.matchTagNames = [];
    ve.dm.CommentMetaItem.static.preserveHtmlAttributes = !1;
    ve.dm.CommentMetaItem.static.toDomElements = function(dataElement, doc) {
        return [doc.createComment(dataElement.attributes.text)];
    }
    ;
    ve.dm.modelRegistry.register(ve.dm.CommentMetaItem);
    ve.ce = {};
    ve.ce.minImgDataUri = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
    ve.ce.getDomText = function(element) {
        var func = function(element) {
            var viewNode, nodeType = element.nodeType, text = '';
            if (nodeType === Node.ELEMENT_NODE || nodeType === Node.DOCUMENT_NODE || nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                if (element.classList.contains('ve-ce-branchNode-blockSlug')) {
                    return '';
                } else if (element.classList.contains('ve-ce-cursorHolder')) {
                    return '';
                } else if (element.classList.contains('ve-ce-leafNode')) {
                    viewNode = $(element).data('view');
                    if (viewNode && element === viewNode.$element[0]) {
                        return new Array(viewNode.getOuterLength() + 1).join('\u2603');
                    }
                    return '';
                } else {
                    for (element = element.firstChild; element; element = element.nextSibling) {
                        text += func(element);
                    }
                }
            } else if (nodeType === Node.TEXT_NODE) {
                return element.data;
            }
            return text;
        };
        return func(element);
    }
    ;
    ve.ce.getDomHash = function(element) {
        var nodeType = element.nodeType
          , nodeName = element.nodeName
          , hash = '';
        if (nodeType === Node.TEXT_NODE || nodeType === Node.CDATA_SECTION_NODE) {
            return '#';
        } else if (nodeType === Node.ELEMENT_NODE || nodeType === Node.DOCUMENT_NODE) {
            if (!(element.classList.contains('ve-ce-branchNode-blockSlug') || element.classList.contains('ve-ce-cursorHolder') || element.classList.contains('ve-ce-nail'))) {
                hash += '<' + nodeName + '>';
                for (element = element.firstChild; element; element = element.nextSibling) {
                    hash += ve.ce.getDomHash(element);
                }
                hash += '</' + nodeName + '>';
            }
            hash = hash.replace(/##+/g, '#');
        }
        return hash;
    }
    ;
    ve.ce.nextCursorOffset = function(node) {
        var nextNode, offset;
        if (node.nextSibling !== null && node.nextSibling.nodeType === Node.TEXT_NODE) {
            nextNode = node.nextSibling;
            offset = 0;
        } else {
            nextNode = node.parentNode;
            offset = 1 + ve.parentIndex(node);
        }
        return {
            node: nextNode,
            offset: offset
        };
    }
    ;
    ve.ce.previousCursorOffset = function(node) {
        var previousNode, offset;
        if (node.previousSibling !== null && node.previousSibling.nodeType === Node.TEXT_NODE) {
            previousNode = node.previousSibling;
            offset = previousNode.data.length;
        } else {
            previousNode = node.parentNode;
            offset = ve.parentIndex(node);
        }
        return {
            node: previousNode,
            offset: offset
        };
    }
    ;
    ve.ce.getOffset = function(domNode, domOffset) {
        var node, view, offset, startNode, maxOffset, lengthSum = 0;
        if (domNode.nodeType === Node.ELEMENT_NODE && domNode.classList.contains('ve-ce-unicorn')) {
            if (domOffset !== 0) {
                throw new Error('Non-zero offset in unicorn');
            }
            return $(domNode).data('modelOffset');
        }
        function traverse(n) {
            while (!n.previousSibling) {
                n = n.parentNode;
                if (!n) {
                    throw new Error('domNode has no ancestor with a .data( \'view\' )');
                }
                if ($(n).data('view')instanceof ve.ce.Node) {
                    return n;
                }
            }
            n = n.previousSibling;
            if ($(n).data('view')instanceof ve.ce.Node) {
                return n;
            }
            while (n.lastChild) {
                n = n.lastChild;
                if ($(n).data('view')instanceof ve.ce.Node) {
                    return n;
                }
            }
            return n;
        }
        if (domNode.nodeType === Node.ELEMENT_NODE) {
            maxOffset = domNode.childNodes.length;
        } else {
            maxOffset = domNode.data.length;
        }
        if (domOffset < 0 || domOffset > maxOffset) {
            throw new Error('domOffset is out of bounds');
        }
        if (domNode.nodeType === Node.ELEMENT_NODE) {
            if (domNode.childNodes.length === 0) {
                startNode = domNode;
                view = $(startNode).data('view');
                if (view instanceof ve.ce.Node) {
                    return view.getOffset() + (view.isWrapped() ? 1 : 0);
                }
                node = startNode;
            } else if (domOffset === domNode.childNodes.length) {
                startNode = domNode.lastChild;
                view = $(startNode).data('view');
                if (view instanceof ve.ce.Node) {
                    return view.getOffset() + view.getOuterLength();
                }
                while (startNode.lastChild) {
                    startNode = startNode.lastChild;
                    view = $(startNode).data('view');
                    if (view instanceof ve.ce.Node) {
                        return view.getOffset() + view.getOuterLength();
                    }
                }
                node = startNode;
            } else {
                startNode = domNode.childNodes[domOffset];
                node = traverse(startNode);
            }
        } else {
            if (!(domNode.parentNode.classList.contains('ve-ce-branchNode-blockSlug') || domNode.parentNode.classList.contains('ve-ce-cursorHolder'))) {
                lengthSum += domOffset;
            }
            startNode = domNode;
            node = traverse(startNode);
        }
        while (true) {
            view = $(node).data('view');
            if (view instanceof ve.ce.Node) {
                break;
            }
            if (node.nodeType === Node.TEXT_NODE && !node.parentNode.classList.contains('ve-ce-branchNode-blockSlug') && !node.parentNode.classList.contains('ve-ce-cursorHolder')) {
                lengthSum += node.data.length;
            }
            node = traverse(node);
        }
        offset = view.getOffset();
        if ($.contains(node, startNode)) {
            if (!view.getModel().isContent()) {
                offset += view.getModel().isWrapped() ? 1 : 0;
            }
            if (view.getModel().canContainContent()) {
                offset += lengthSum;
            }
        } else if (view.parent) {
            offset += view.getOuterLength();
            if (view.isContent()) {
                offset += lengthSum;
            }
        } else {
            throw new Error('Node is not in document');
        }
        return offset;
    }
    ;
    ve.ce.getOffsetOfSlug = function(element) {
        var model, $prev, $element = $(element);
        if ($element.index() === 0) {
            model = $element.parent().data('view').getModel();
            return model.getOffset() + (model.isWrapped() ? 1 : 0);
        } else {
            $prev = $element.prevAll('.ve-ce-leafNode,.ve-ce-branchNode').first();
            if ($prev.length) {
                model = $prev.data('view').getModel();
                return model.getOffset() + model.getOuterLength();
            }
            throw new Error('Incorrect slug location');
        }
    }
    ;
    ve.ce.isAfterAnnotationBoundary = function(node, offset) {
        var previousNode;
        if (node.nodeType === Node.TEXT_NODE) {
            if (offset > 0) {
                return false;
            }
            offset = ve.parentIndex(node);
            node = node.parentNode;
        }
        if (offset === 0) {
            return ve.dm.modelRegistry.isAnnotation(node);
        }
        previousNode = node.childNodes[offset - 1];
        if (previousNode.nodeType === Node.ELEMENT_NODE && (previousNode.classList.contains('ve-ce-nail-post-close') || previousNode.classList.contains('ve-ce-nail-post-open'))) {
            return true;
        }
        return ve.dm.modelRegistry.isAnnotation(previousNode);
    }
    ;
    ve.ce.isShortcutKey = function(e) {
        return !!(e.ctrlKey || e.metaKey);
    }
    ;
    ve.ce.veRangeFromSelection = function(selection) {
        try {
            return new ve.Range(ve.ce.getOffset(selection.anchorNode, selection.anchorOffset),ve.ce.getOffset(selection.focusNode, selection.focusOffset));
        } catch (e) {
            return null;
        }
    }
    ;
    ve.ce.nailedAnnotationAt = function(node) {
        if (node && node.nodeType === Node.TEXT_NODE) {
            node = node.parentNode;
        }
        return $(node).closest('.ve-ce-nailedAnnotation')[0];
    }
    ;
    ve.ce.isAnnotationElement = function(element) {
        return !(ve.isBlockElement(element) || ve.isVoidElement(element) || element.classList.contains('ve-ce-branchNode-slug'));
    }
    ;
    ve.ce.TextStateChunk = function VeCeTextStateChunk(text, elements, type) {
        this.text = text;
        this.elements = elements;
        this.type = type;
    }
    ;
    OO.initClass(ve.ce.TextStateChunk);
    ve.ce.TextStateChunk.static.compareElements = function(element1, element2) {
        return element1 === element2 || (element1.nodeName === element2.nodeName && element1.getAttribute('class') === element2.getAttribute('class') && element1.getAttribute('typeof') === element2.getAttribute('typeof') && element1.getAttribute('property') === element2.getAttribute('property') && element1.getAttribute('href') === element2.getAttribute('href'));
    }
    ;
    ve.ce.TextStateChunk.prototype.hasEqualElements = function(other) {
        var i, len;
        if (this.elements === other.elements) {
            return true;
        }
        if (this.elements.length !== other.elements.length) {
            return false;
        }
        for (i = 0,
        len = this.elements.length; i < len; i++) {
            if (!this.constructor.static.compareElements(this.elements[i], other.elements[i])) {
                return false;
            }
        }
        return true;
    }
    ;
    ve.ce.TextStateChunk.prototype.isEqual = function(other) {
        return this.text === other.text && this.type === other.type && this.hasEqualElements(other);
    }
    ;
    ve.ce.TextState = function VeCeTextState(element) {
        this.chunks = this.constructor.static.getChunks(element);
    }
    ;
    OO.initClass(ve.ce.TextState);
    ve.ce.TextState.static.getChunks = function(element) {
        var view, node = element, elementListStack = [[]], stackTop = 0, annotationStack = [], chunks = [];
        function add(text, type) {
            if (!chunks.length || chunks[chunks.length - 1].elements !== elementListStack[stackTop] || chunks[chunks.length - 1].type !== type) {
                chunks.push(new ve.ce.TextStateChunk(text,elementListStack[stackTop],type || 'text'));
            } else {
                chunks[chunks.length - 1].text += text;
            }
        }
        while (true) {
            if (node.nodeType === Node.TEXT_NODE) {
                add(node.data.replace(/\u00A0/g, ' '));
            } else if (node.nodeType !== Node.ELEMENT_NODE || node.classList.contains('ve-ce-branchNode-blockSlug') || node.classList.contains('ve-ce-cursorHolder')) {} else if ((view = $(node).data('view')) && view instanceof ve.ce.LeafNode) {
                if (node === view.$element[0]) {
                    add(ve.repeatString('\u2603', view.getOuterLength()));
                }
            } else if (node.classList.contains('ve-ce-unicorn')) {
                add('', 'unicorn');
            } else if (node.firstChild) {
                if (ve.ce.isAnnotationElement(node)) {
                    elementListStack.push(elementListStack[stackTop].concat(node));
                    annotationStack.push(node);
                    stackTop++;
                }
                node = node.firstChild;
                continue;
            }
            while (true) {
                if (node === element) {
                    break;
                }
                if (node === annotationStack[annotationStack.length - 1]) {
                    annotationStack.pop();
                    elementListStack.pop();
                    stackTop--;
                }
                if (node.nextSibling) {
                    break;
                }
                node = node.parentNode;
            }
            if (node === element) {
                break;
            }
            node = node.nextSibling;
        }
        return chunks;
    }
    ;
    ve.ce.TextState.prototype.isEqual = function(other) {
        var i, len;
        if (other === this) {
            return true;
        }
        if (!other || this.chunks.length !== other.chunks.length) {
            return false;
        }
        for (i = 0,
        len = this.chunks.length; i < len; i++) {
            if (!(this.chunks[i].isEqual(other.chunks[i]))) {
                return false;
            }
        }
        return true;
    }
    ;
    ve.ce.TextState.prototype.getChangeTransaction = function(prev, modelDoc, modelOffset, unicornAnnotations) {
        var change, i, iLen, textStart, textEnd, changeOffset, removed, removeRange, annotations, missing, oldChunk, newChunk, j, jStart, jEnd, leastMissing, matchStartOffset, matchOffset, bestOffset, jLen, oldAnnotations, element, modelClass, ann, oldAnn, data, view, oldChunks = prev.chunks, newChunks = this.chunks, modelData = modelDoc.data, newData = [];
        function countMissing(newArray, oldArray, equals) {
            var i, iLen, j, jLen, count = 0;
            for (i = 0,
            iLen = newArray.length; i < iLen; i++) {
                for (j = 0,
                jLen = oldArray.length; j < jLen; j++) {
                    if (equals(newArray[i], oldArray[j])) {
                        break;
                    }
                }
                if (j === jLen) {
                    count++;
                }
            }
            return count;
        }
        change = ve.countEdgeMatches(oldChunks, newChunks, function(a, b) {
            return a.isEqual(b);
        });
        if (change === null) {
            return null;
        }
        textStart = 0;
        textEnd = 0;
        if (change.start + change.end < Math.min(oldChunks.length, newChunks.length)) {
            if (oldChunks[change.start].hasEqualElements(newChunks[change.start])) {
                oldChunk = oldChunks[change.start];
                newChunk = newChunks[change.start];
                iLen = Math.min(oldChunk.text.length, newChunk.text.length);
                for (i = 0; i < iLen; i++) {
                    if (oldChunk.text[i] !== newChunk.text[i]) {
                        break;
                    }
                }
                textStart = i;
            }
            if (oldChunks[oldChunks.length - 1 - change.end].hasEqualElements(newChunks[newChunks.length - 1 - change.end])) {
                oldChunk = oldChunks[oldChunks.length - 1 - change.end];
                newChunk = newChunks[newChunks.length - 1 - change.end];
                iLen = Math.min(oldChunk.text.length - (change.start + change.end === oldChunks.length - 1 ? textStart : 0), newChunk.text.length - (change.start + change.end === newChunks.length - 1 ? textStart : 0));
                for (i = 0; i < iLen; i++) {
                    if (newChunk.text[newChunk.text.length - 1 - i] !== oldChunk.text[oldChunk.text.length - 1 - i]) {
                        break;
                    }
                }
                textEnd = i;
            }
        }
        changeOffset = modelOffset + 1;
        for (i = 0,
        iLen = change.start; i < iLen; i++) {
            changeOffset += oldChunks[i].text.length;
        }
        removed = 0;
        for (i = change.start,
        iLen = oldChunks.length - change.end; i < iLen; i++) {
            removed += oldChunks[i].text.length;
        }
        removeRange = new ve.Range(changeOffset + textStart,changeOffset + removed - textEnd);
        for (i = change.start,
        iLen = newChunks.length - change.end; i < iLen; i++) {
            newChunk = newChunks[i];
            if (newChunk.type === 'unicorn') {
                continue;
            }
            data = newChunk.text.split('');
            if (i === change.start) {
                data = data.slice(textStart);
            }
            if (i === iLen - 1) {
                data = data.slice(0, data.length - textEnd);
            }
            if (data.length === 0) {
                continue;
            }
            annotations = null;
            missing = null;
            if (change.start === 0) {
                jStart = 0;
                matchStartOffset = changeOffset;
            } else {
                jStart = change.start - 1;
                matchStartOffset = changeOffset - oldChunks[jStart].text.length;
            }
            if (change.end === 0) {
                jEnd = oldChunks.length;
            } else {
                jEnd = oldChunks.length - change.end + 1;
            }
            matchOffset = matchStartOffset;
            for (j = jStart; j < jEnd; j++) {
                oldChunk = oldChunks[j];
                if (!oldChunk.hasEqualElements(newChunk)) {
                    matchOffset += oldChunk.text.length;
                    continue;
                }
                if (oldChunk.type === 'unicorn') {
                    if (!unicornAnnotations) {
                        throw new Error('No unicorn annotations');
                    }
                    annotations = unicornAnnotations;
                    break;
                }
                annotations = modelData.getInsertionAnnotationsFromRange(new ve.Range(matchOffset), true);
                break;
            }
            if (annotations === null) {
                leastMissing = newChunk.elements.length;
                bestOffset = null;
                matchOffset = matchStartOffset;
                for (j = jStart; j < jEnd; j++) {
                    oldChunk = oldChunks[j];
                    missing = countMissing(newChunk.elements, oldChunk.elements, ve.ce.TextStateChunk.static.compareElements);
                    if (missing < leastMissing) {
                        leastMissing = missing;
                        bestOffset = matchOffset;
                        if (missing === 0) {
                            break;
                        }
                    }
                    matchOffset += oldChunk.text.length;
                }
                if (bestOffset === null) {
                    oldAnnotations = new ve.dm.AnnotationSet(modelData.getStore());
                } else {
                    oldAnnotations = modelData.getInsertionAnnotationsFromRange(new ve.Range(bestOffset), true);
                }
                annotations = new ve.dm.AnnotationSet(modelData.getStore());
                for (j = 0,
                jLen = newChunk.elements.length; j < jLen; j++) {
                    element = newChunk.elements[j];
                    view = $(element).data('view');
                    if (view) {
                        ann = view.getModel();
                    } else {
                        modelClass = ve.dm.modelRegistry.lookup(ve.dm.modelRegistry.matchElement(element));
                        if (!(modelClass && modelClass.prototype instanceof ve.dm.Annotation)) {
                            continue;
                        }
                        ann = ve.dm.annotationFactory.createFromElement(modelClass.static.toDataElement([element], ve.dm.converter));
                        oldAnn = oldAnnotations.getComparable(ann);
                        if (oldAnn) {
                            ann = oldAnn;
                        } else if (!ann.constructor.static.inferFromView) {
                            continue;
                        }
                    }
                    annotations.add(ann, annotations.getLength());
                }
            }
            ve.dm.Document.static.addAnnotationsToData(data, annotations);
            ve.batchPush(newData, data);
        }
        return ve.dm.TransactionBuilder.static.newFromReplacement(modelDoc, removeRange, newData);
    }
    ;
    ve.ce.RangeState = function VeCeRangeState(old, root, selectionOnly) {
        this.branchNodeChanged = !1;
        this.selectionChanged = !1;
        this.contentChanged = !1;
        this.veRange = null;
        this.node = null;
        this.text = null;
        this.hash = null;
        this.textState = null;
        this.focusIsAfterAnnotationBoundary = null;
        this.saveState(old, root, selectionOnly);
    }
    ;
    OO.initClass(ve.ce.RangeState);
    ve.ce.RangeState.prototype.saveState = function(old, root, selectionOnly) {
        var $node, selection, focusNodeChanged, oldSelection = old ? old.misleadingSelection : ve.SelectionState.static.newNullSelection(), nativeSelection = root.getElementDocument().getSelection();
        if (nativeSelection.rangeCount && OO.ui.contains(root.$element[0], nativeSelection.focusNode, true)) {
            selection = new ve.SelectionState(nativeSelection);
        } else {
            selection = ve.SelectionState.static.newNullSelection();
        }
        if (selection.equalsSelection(oldSelection)) {
            this.selectionChanged = !1;
            this.veRange = old && old.veRange;
        } else {
            this.selectionChanged = !0;
            this.veRange = ve.ce.veRangeFromSelection(selection);
        }
        focusNodeChanged = oldSelection.focusNode !== selection.focusNode;
        if (!focusNodeChanged) {
            this.node = old && old.node;
        } else {
            $node = $(selection.focusNode).closest('.ve-ce-branchNode');
            if ($node.length === 0) {
                this.node = null;
            } else {
                this.node = $node.data('view');
                if (this.node && this.node.root !== root.root) {
                    this.node = null;
                    this.veRange = null;
                }
            }
        }
        this.branchNodeChanged = (old && old.node) !== this.node;
        if (!this.node) {
            this.text = null;
            this.hash = null;
            this.textState = null;
        } else if (selectionOnly && !focusNodeChanged) {
            this.text = old.text;
            this.hash = old.hash;
            this.textState = old.textState;
        } else {
            this.text = ve.ce.getDomText(this.node.$element[0]);
            this.hash = ve.ce.getDomHash(this.node.$element[0]);
            this.textState = new ve.ce.TextState(this.node.$element[0]);
        }
        this.contentChanged = !selectionOnly && !this.branchNodeChanged && ((old && old.hash) !== this.hash || (old && old.text) !== this.text || (!this.textState && old && old.textState) || (!!this.textState && !this.textState.isEqual(old && old.textState)));
        if (old && !this.selectionChanged && !this.contentChanged) {
            this.focusIsAfterAnnotationBoundary = old.focusIsAfterAnnotationBoundary;
        } else {
            this.focusIsAfterAnnotationBoundary = selection.focusNode && ve.ce.isAfterAnnotationBoundary(selection.focusNode, selection.focusOffset);
        }
        this.misleadingSelection = selection;
    }
    ;
    ve.ce.AnnotationFactory = function VeCeAnnotationFactory() {
        OO.Factory.call(this);
    }
    ;
    OO.inheritClass(ve.ce.AnnotationFactory, OO.Factory);
    ve.ce.AnnotationFactory.prototype.getDescription = function(annotation) {
        var type = annotation.constructor.static.name;
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.getDescription(annotation);
        }
        throw new Error('Unknown annotation type: ' + type);
    }
    ;
    ve.ce.AnnotationFactory.prototype.canAnnotationBeActive = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.canBeActive;
        }
        throw new Error('Unknown annotation type: ' + type);
    }
    ;
    ve.ce.annotationFactory = new ve.ce.AnnotationFactory();
    ve.ce.NodeFactory = function VeCeNodeFactory() {
        OO.Factory.call(this);
    }
    ;
    OO.inheritClass(ve.ce.NodeFactory, OO.Factory);
    ve.ce.NodeFactory.prototype.getDescription = function(node) {
        var type = node.constructor.static.name;
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.getDescription(node);
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.ce.NodeFactory.prototype.splitNodeOnEnter = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.splitOnEnter;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.ce.NodeFactory.prototype.getNodePrimaryCommandName = function(type) {
        if (Object.prototype.hasOwnProperty.call(this.registry, type)) {
            return this.registry[type].static.primaryCommandName;
        }
        throw new Error('Unknown node type: ' + type);
    }
    ;
    ve.ce.NodeFactory.prototype.createFromModel = function(model) {
        var type = model.getType();
        if (ve.dm.nodeFactory.isMetaData(type)) {
            type = 'meta';
        }
        return this.create(type, model);
    }
    ;
    ve.ce.nodeFactory = new ve.ce.NodeFactory();
    ve.ce.Document = function VeCeDocument(model, surface) {
        ve.ce.Document.super.call(this, new ve.ce.DocumentNode(model.getDocumentNode(),surface));
        this.lang = null;
        this.dir = null;
        this.setLang(model.getLang());
        this.setDir(model.getDir());
        this.model = model;
    }
    ;
    OO.inheritClass(ve.ce.Document, ve.Document);
    ve.ce.Document.prototype.setLang = function(lang) {
        this.getDocumentNode().$element.prop('lang', lang);
        this.lang = lang;
        this.emit('langChange');
    }
    ;
    ve.ce.Document.prototype.setDir = function(dir) {
        this.getDocumentNode().$element.prop('dir', dir);
        this.dir = dir;
        this.emit('langChange');
    }
    ;
    ve.ce.Document.prototype.getLang = function() {
        return this.lang;
    }
    ;
    ve.ce.Document.prototype.getDir = function() {
        return this.dir;
    }
    ;
    ve.ce.Document.prototype.getSlugAtOffset = function(offset) {
        var node = this.getBranchNodeFromOffset(offset);
        return node ? node.getSlugAtOffset(offset) : null;
    }
    ;
    ve.ce.Document.prototype.getNodeAndOffset = function(offset) {
        var branchNode, count, i, ceChild, position, step, node, model, steps, found, prevNode, $viewNodes, countedNodes = [];
        if (!this.model.getDocumentRange().containsRange(new ve.Range(offset))) {
            throw new Error('Offset is out of bounds');
        }
        branchNode = this.getBranchNodeFromOffset(offset);
        count = branchNode.getOffset() + ((branchNode.isWrapped()) ? 1 : 0);
        if (!(branchNode instanceof ve.ce.ContentBranchNode)) {
            for (i = 0; ; i++) {
                ceChild = branchNode.children[i];
                if (count === offset) {
                    break;
                }
                if (!ceChild) {
                    throw new Error('Offset lies beyond branchNode');
                }
                count += ceChild.getOuterLength();
                if (count > offset) {
                    if (ceChild.getOuterLength() !== 2) {
                        throw new Error('Offset lies inside child of strange size');
                    }
                    node = ceChild.$element[0];
                    if (node) {
                        return {
                            node: node,
                            offset: 0
                        };
                    }
                    break;
                }
            }
            node = branchNode.$element[0];
            while (ceChild && !ceChild.$element[0]) {
                i++;
                ceChild = branchNode.children[i];
            }
            if (!ceChild || !ceChild.$element[0]) {
                return {
                    node: node,
                    offset: node.childNodes.length
                };
            }
            return {
                node: node,
                offset: Array.prototype.indexOf.call(node.childNodes, ceChild.$element[0])
            };
        }
        position = {
            node: branchNode.$element[0],
            offset: 0
        };
        function noDescend() {
            return this.classList.contains('ve-ce-branchNode-blockSlug') || ve.rejectsCursor(this);
        }
        while (true) {
            if (count === offset) {
                break;
            }
            position = ve.adjacentDomPosition(position, 1, {
                noDescend: noDescend,
                stop: function() {
                    return true;
                }
            });
            step = position.steps[0];
            node = step.node;
            if (node.nodeType === Node.TEXT_NODE) {
                if (step.type === 'leave') {
                    continue;
                }
                if (offset <= count + node.data.length) {
                    position = {
                        node: node,
                        offset: offset - count
                    };
                    break;
                } else {
                    count += node.data.length;
                    position = {
                        node: node,
                        offset: node.data.length
                    };
                    continue;
                }
            }
            if (!(node.classList.contains('ve-ce-branchNode') || node.classList.contains('ve-ce-leafNode'))) {
                continue;
            }
            if (step.type === 'leave') {
                count++;
                continue;
            }
            model = $.data(node, 'view').model;
            if (countedNodes.indexOf(model) !== -1) {
                position = {
                    node: node.parentNode,
                    offset: ve.parentIndex(node) + 1
                };
                continue;
            }
            countedNodes.push(model);
            if (offset >= count + model.getOuterLength()) {
                position = {
                    node: node.parentNode,
                    offset: ve.parentIndex(node) + 1
                };
                count += model.getOuterLength();
            } else if (step.type === 'cross') {
                if (offset === count + 1) {
                    position = {
                        node: node,
                        offset: 0
                    };
                    break;
                }
                count += 2;
            } else {
                count += 1;
            }
        }
        prevNode = position.node.childNodes[position.offset - 1];
        if (prevNode && prevNode.nodeType === Node.ELEMENT_NODE && (prevNode.classList.contains('ve-ce-branchNode') || prevNode.classList.contains('ve-ce-leafNode'))) {
            $viewNodes = $.data(prevNode, 'view').$element;
            if ($viewNodes.length > 1) {
                position.node = $viewNodes.get(-1).parentNode;
                position.offset = 1 + ve.parentIndex($viewNodes.get(-1));
            }
        }
        found = {};
        function stop(step) {
            var model;
            if (step.node.nodeType === Node.TEXT_NODE) {
                return step.type === 'internal';
            }
            if (step.node.classList.contains('ve-ce-branchNode') || step.node.classList.contains('ve-ce-leafNode')) {
                model = $.data(step.node, 'view').model;
                if (countedNodes.indexOf(model) !== -1) {
                    return false;
                }
                countedNodes.push(model);
                return true;
            }
            return false;
        }
        steps = ve.adjacentDomPosition(position, 1, {
            stop: stop,
            noDescend: noDescend
        }).steps;
        steps.slice(0, -1).forEach(function(step) {
            var hasClass = function(className) {
                return step.node.nodeType === Node.ELEMENT_NODE && step.node.classList.contains(className);
            };
            found.preUnicorn = found.preUnicorn || (hasClass('ve-ce-pre-unicorn') && step);
            found.postUnicorn = found.postUnicorn || (hasClass('ve-ce-post-unicorn') && step);
            found.preOpenNail = found.preOpenNail || (hasClass('ve-ce-nail-pre-open') && step);
            found.postOpenNail = found.postOpenNail || (hasClass('ve-ce-nail-post-open') && step);
            found.preCloseNail = found.preCloseNail || (hasClass('ve-ce-nail-pre-close') && step);
            found.postCloseNail = found.postCloseNail || (hasClass('ve-ce-nail-post-close') && step);
            found.focusableNode = found.focusableNode || (hasClass('ve-ce-focusableNode') && step);
            found.text = found.text || (step.node.nodeType === Node.TEXT_NODE && step);
        });
        if (found.preUnicorn) {
            return ve.ce.nextCursorOffset(found.preUnicorn.node);
        }
        if (found.postUnicorn) {
            return ve.ce.previousCursorOffset(found.postUnicorn.node);
        }
        if (found.preOpenNail) {
            return ve.ce.previousCursorOffset(found.preOpenNail.node);
        }
        if (found.postCloseNail) {
            return ve.ce.nextCursorOffset(found.postCloseNail.node);
        }
        if (found.text) {
            if (position.node.nodeType === Node.TEXT_NODE) {
                return position;
            }
            return {
                node: found.text.node,
                offset: 0
            };
        }
        return position;
    }
    ;
    ve.ce.Document.prototype.getDirectionalityFromRange = function(range) {
        var effectiveNode, selectedNodes = this.selectNodes(range, 'covered');
        if (selectedNodes.length > 1) {
            effectiveNode = this.selectNodes(range, 'siblings')[0].node.getParent();
        } else {
            effectiveNode = selectedNodes[0].node;
            while (effectiveNode.isContent()) {
                effectiveNode = effectiveNode.parent;
            }
        }
        return effectiveNode.$element.css('direction');
    }
    ;
    ve.ce.View = function VeCeView(model, config) {
        this.model = model;
        ve.ce.View.super.call(this, config);
        OO.EventEmitter.call(this);
        this.live = !1;
        this.connect(this, {
            setup: 'onSetup',
            teardown: 'onTeardown'
        });
        this.initialize();
    }
    ;
    OO.inheritClass(ve.ce.View, OO.ui.Element);
    OO.mixinClass(ve.ce.View, OO.EventEmitter);
    ve.ce.View.static.renderHtmlAttributes = function(attribute) {
        var attributes = ['abbr', 'about', 'align', 'alt', 'axis', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'char', 'charoff', 'cite', 'class', 'clear', 'color', 'colspan', 'datatype', 'datetime', 'dir', 'face', 'frame', 'headers', 'height', 'href', 'id', 'itemid', 'itemprop', 'itemref', 'itemscope', 'itemtype', 'lang', 'noshade', 'nowrap', 'property', 'rbspan', 'rel', 'resource', 'rev', 'rowspan', 'rules', 'scope', 'size', 'span', 'src', 'start', 'style', 'summary', 'title', 'type', 'typeof', 'valign', 'value', 'width'];
        return attributes.indexOf(attribute) !== -1;
    }
    ;
    ve.ce.View.prototype.getModelHtmlDocument = function() {
        return null;
    }
    ;
    ve.ce.View.prototype.initialize = function() {
        if (this.model.element && this.model.element.originalDomElementsHash !== undefined) {
            ve.dm.Converter.static.renderHtmlAttributeList(this.model.getOriginalDomElements(this.model.getStore()), this.$element, this.constructor.static.renderHtmlAttributes, true, !(this.model instanceof ve.dm.Node) || !this.model.canHaveChildren() || this.model.handlesOwnChildren());
        }
    }
    ;
    ve.ce.View.prototype.onSetup = function() {
        this.$element.data('view', this);
    }
    ;
    ve.ce.View.prototype.onTeardown = function() {
        this.$element.removeData('view');
    }
    ;
    ve.ce.View.prototype.getModel = function() {
        return this.model;
    }
    ;
    ve.ce.View.prototype.isLive = function() {
        return this.live;
    }
    ;
    ve.ce.View.prototype.setLive = function(live) {
        this.live = live;
        if (this.live) {
            this.emit('setup');
        } else {
            this.emit('teardown');
        }
    }
    ;
    ve.ce.View.prototype.isInContentEditable = function() {
        return ve.isContentEditable(this.$element[0].parentNode);
    }
    ;
    ve.ce.View.prototype.getResolvedAttribute = function(key) {
        var plainValue = this.model.getAttribute(key)
          , doc = this.getModelHtmlDocument();
        return doc && typeof plainValue === 'string' ? ve.resolveUrl(plainValue, doc) : plainValue;
    }
    ;
    ve.ce.View.prototype.destroy = function() {
        this.disconnect(this);
        this.model.disconnect(this);
        this.model = null;
    }
    ;
    ve.ce.Annotation = function VeCeAnnotation(model, parentNode, config) {
        ve.ce.Annotation.super.call(this, model, config);
        this.parentNode = parentNode || null;
        this.$element.data('view', this).addClass('ve-ce-annotation');
    }
    ;
    OO.inheritClass(ve.ce.Annotation, ve.ce.View);
    ve.ce.Annotation.static.tagName = 'span';
    ve.ce.Annotation.static.canBeActive = !1;
    ve.ce.Annotation.static.getDescription = function() {
        return '';
    }
    ;
    ve.ce.Annotation.prototype.getParentNode = function() {
        return this.parentNode;
    }
    ;
    ve.ce.Annotation.prototype.getModelHtmlDocument = function() {
        return this.parentNode && this.parentNode.getModelHtmlDocument();
    }
    ;
    ve.ce.Annotation.prototype.appendChild = function(childNode) {
        this.$element[0].appendChild(childNode);
    }
    ;
    ve.ce.Annotation.prototype.getContentContainer = function() {
        return this.$element[0];
    }
    ;
    ve.ce.Annotation.prototype.attachContents = function() {}
    ;
    ve.ce.Annotation.prototype.appendTo = function(node) {
        node.appendChild(this.$element[0]);
    }
    ;
    ve.ce.Annotation.prototype.canBeActive = function() {
        return this.constructor.static.canBeActive;
    }
    ;
    ve.ce.Annotation.prototype.destroy = function() {
        this.parentNode = null;
        ve.ce.Annotation.super.prototype.destroy.call(this);
    }
    ;
    ve.ce.Node = function VeCeNode() {
        ve.ce.Node.super.apply(this, arguments);
        ve.Node.call(this);
    }
    ;
    OO.inheritClass(ve.ce.Node, ve.ce.View);
    OO.mixinClass(ve.ce.Node, ve.Node);
    ve.ce.Node.static.splitOnEnter = !1;
    ve.ce.Node.static.removeEmptyLastChildOnEnter = !1;
    ve.ce.Node.static.isMultiline = null;
    ve.ce.Node.static.trapsCursor = !1;
    ve.ce.Node.static.primaryCommandName = null;
    ve.ce.Node.static.getDescription = function() {
        return '';
    }
    ;
    ve.ce.Node.prototype.getChildNodeTypes = function() {
        return this.model.getChildNodeTypes();
    }
    ;
    ve.ce.Node.prototype.getParentNodeTypes = function() {
        return this.model.getParentNodeTypes();
    }
    ;
    ve.ce.Node.prototype.getSuggestedParentNodeTypes = function() {
        return this.model.getSuggestedParentNodeTypes();
    }
    ;
    ve.ce.Node.prototype.canHaveChildren = function() {
        return this.model.canHaveChildren();
    }
    ;
    ve.ce.Node.prototype.canHaveChildrenNotContent = function() {
        return this.model.canHaveChildrenNotContent();
    }
    ;
    ve.ce.Node.prototype.isInternal = function() {
        return this.model.isInternal();
    }
    ;
    ve.ce.Node.prototype.isMetaData = function() {
        return this.model.isMetaData();
    }
    ;
    ve.ce.Node.prototype.isWrapped = function() {
        return this.model.isWrapped();
    }
    ;
    ve.ce.Node.prototype.isUnwrappable = function() {
        return this.model.isUnwrappable();
    }
    ;
    ve.ce.Node.prototype.canContainContent = function() {
        return this.model.canContainContent();
    }
    ;
    ve.ce.Node.prototype.isContent = function() {
        return this.model.isContent();
    }
    ;
    ve.ce.Node.prototype.isFocusable = function() {
        return this.model.isFocusable();
    }
    ;
    ve.ce.Node.prototype.isAlignable = function() {
        return this.model.isAlignable();
    }
    ;
    ve.ce.Node.prototype.isCellable = function() {
        return this.model.isCellable();
    }
    ;
    ve.ce.Node.prototype.isCellEditable = function() {
        return this.model.isCellEditable();
    }
    ;
    ve.ce.Node.prototype.hasSignificantWhitespace = function() {
        return this.model.hasSignificantWhitespace();
    }
    ;
    ve.ce.Node.prototype.handlesOwnChildren = function() {
        return this.model.handlesOwnChildren();
    }
    ;
    ve.ce.Node.prototype.shouldIgnoreChildren = function() {
        return this.model.shouldIgnoreChildren();
    }
    ;
    ve.ce.Node.prototype.getLength = function() {
        return this.model.getLength();
    }
    ;
    ve.ce.Node.prototype.getOuterLength = function() {
        return this.model.getOuterLength();
    }
    ;
    ve.ce.Node.prototype.getOffset = function() {
        return this.model.getOffset();
    }
    ;
    ve.ce.Node.prototype.splitOnEnter = function() {
        return this.constructor.static.splitOnEnter;
    }
    ;
    ve.ce.Node.prototype.removeEmptyLastChildOnEnter = function() {
        return this.constructor.static.removeEmptyLastChildOnEnter;
    }
    ;
    ve.ce.Node.prototype.isMultiline = function() {
        var booleanNode = this.traverseUpstream(function(node) {
            return node.constructor.static.isMultiline === null;
        });
        if (booleanNode) {
            return booleanNode.constructor.static.isMultiline;
        } else {
            return !this.root || this.getRoot().getSurface().getSurface().isMultiline();
        }
    }
    ;
    ve.ce.Node.prototype.trapsCursor = function() {
        return this.constructor.static.trapsCursor;
    }
    ;
    ve.ce.Node.prototype.destroy = function() {
        this.parent = null;
        this.root = null;
        this.doc = null;
        ve.ce.Node.super.prototype.destroy.call(this);
    }
    ;
    ve.ce.Node.prototype.getModelHtmlDocument = function() {
        return this.model.getDocument() && this.model.getDocument().getHtmlDocument();
    }
    ;
    ve.ce.BranchNode = function VeCeBranchNode(model) {
        ve.BranchNode.call(this);
        ve.ce.BranchNode.super.apply(this, arguments);
        this.tagName = this.$element.get(0).nodeName.toLowerCase();
        this.slugNodes = [];
        this.model.connect(this, {
            splice: 'onSplice'
        });
        this.onSplice.apply(this, [0, 0].concat(model.getChildren()));
    }
    ;
    OO.inheritClass(ve.ce.BranchNode, ve.ce.Node);
    OO.mixinClass(ve.ce.BranchNode, ve.BranchNode);
    ve.ce.BranchNode.inlineSlugTemplate = (function() {
        var profile = $.client.profile()
          , $img = $('<img>').attr({
            role: 'none',
            alt: ''
        }).addClass('ve-ce-chimera ve-ce-chimera-' + profile.layout)
          , $span = $('<span>').addClass('ve-ce-branchNode-slug ve-ce-branchNode-inlineSlug').append($img);
        if (profile.layout === 'gecko') {
            $img.prop('src', ve.ce.minImgDataUri);
        }
        return $span.get(0);
    }());
    ve.ce.BranchNode.inputDebugInlineSlugTemplate = $('<span>').addClass('ve-ce-branchNode-slug ve-ce-branchNode-inlineSlug').append($('<img>').addClass('ve-ce-chimera ve-ce-chimera-debug').attr({
        src: ve.ce.chimeraImgDataUri,
        role: 'none',
        alt: ''
    })).get(0);
    ve.ce.BranchNode.blockSlugTemplate = $('<div>').addClass('ve-ce-branchNode-slug ve-ce-branchNode-blockSlug').get(0);
    ve.ce.BranchNode.prototype.initialize = function() {
        ve.ce.BranchNode.super.prototype.initialize.call(this);
        this.$element.addClass('ve-ce-branchNode');
    }
    ;
    ve.ce.BranchNode.prototype.updateTagName = function() {
        var wrapper, tagName = this.getTagName();
        if (tagName !== this.tagName) {
            this.emit('teardown');
            wrapper = document.createElement(tagName);
            wrapper.className = this.$element[0].className;
            wrapper.contentEditable = this.$element[0].contentEditable;
            while (this.$element[0].firstChild) {
                wrapper.appendChild(this.$element[0].firstChild);
            }
            if (this.$element[0].parentNode) {
                this.$element[0].parentNode.replaceChild(wrapper, this.$element[0]);
            }
            this.$element = $(wrapper);
            this.tagName = tagName;
            this.initialize();
            this.emit('setup');
            if (this.root instanceof ve.ce.DocumentNode) {
                this.root.getSurface().setContentBranchNodeChanged();
            }
        }
    }
    ;
    ve.ce.BranchNode.prototype.onModelUpdate = function(transaction) {
        this.emit('childUpdate', transaction);
    }
    ;
    ve.ce.BranchNode.prototype.onSplice = function(index) {
        var i, length, removals, position, j, fragment, inAttachedRoot, upstreamOfAttachedRoot, dmDoc = this.getModel().getDocument(), attachedRoot = dmDoc && dmDoc.attachedRoot, isAllAttached = !attachedRoot || attachedRoot instanceof ve.dm.DocumentNode, args = [];
        if (!isAllAttached) {
            inAttachedRoot = this.getModel().isDownstreamOf(attachedRoot);
            upstreamOfAttachedRoot = attachedRoot.collectUpstream();
        }
        for (i = 0,
        length = arguments.length; i < length; i++) {
            args.push(arguments[i]);
        }
        if (args.length >= 3) {
            for (i = 2,
            length = args.length; i < length; i++) {
                if (isAllAttached || inAttachedRoot || upstreamOfAttachedRoot.indexOf(args[i]) !== -1 || args[i].findParent(ve.dm.InternalItemNode)) {
                    args[i] = ve.ce.nodeFactory.createFromModel(args[i]);
                    args[i].model.connect(this, {
                        update: 'onModelUpdate'
                    });
                } else {
                    args[i] = new ve.ce.UnrenderedNode(args[i]);
                }
            }
        }
        removals = this.children.splice.apply(this.children, args);
        for (i = 0,
        length = removals.length; i < length; i++) {
            removals[i].model.disconnect(this, {
                update: 'onModelUpdate'
            });
            removals[i].model.disconnect(removals[i]);
            removals[i].setLive(false);
            removals[i].detach();
            removals[i].$element.detach();
            removals[i].destroy();
        }
        if (args.length >= 3) {
            fragment = document.createDocumentFragment();
            for (i = args.length - 1; i >= 2; i--) {
                args[i].attach(this);
                for (j = args[i].$element.length - 1; j >= 0; j--) {
                    fragment.insertBefore(args[i].$element[j], fragment.childNodes[0] || null);
                }
            }
            if (fragment.childNodes.length) {
                position = this.getDomPosition(index);
                position.node.insertBefore(fragment, position.node.children[position.offset] || null);
            }
            for (i = args.length - 1; i >= 2; i--) {
                if (this.live !== args[i].isLive()) {
                    args[i].setLive(this.live);
                }
            }
        }
        this.setupBlockSlugs();
        this.setupInlineSlugs();
    }
    ;
    ve.ce.BranchNode.prototype.setupBlockSlugs = function() {
        if (this.canHaveChildrenNotContent()) {
            this.setupSlugs(true);
        }
    }
    ;
    ve.ce.BranchNode.prototype.setupInlineSlugs = function() {
        if (!this.canHaveChildrenNotContent()) {
            this.setupSlugs(false);
        }
    }
    ;
    ve.ce.BranchNode.prototype.removeSlugs = function() {
        var i;
        for (i in this.slugNodes) {
            if (this.slugNodes[i] !== undefined && this.slugNodes[i].parentNode) {
                this.slugNodes[i].parentNode.removeChild(this.slugNodes[i]);
            }
            delete this.slugNodes[i];
        }
    }
    ;
    ve.ce.BranchNode.prototype.setupSlugs = function(isBlock) {
        var i, slugTemplate, slugNode, child, slugButton, doc;
        if (this.getModel().getDocument() && this.getModel().getDocument().sourceMode && isBlock) {
            return;
        }
        doc = this.getElementDocument();
        this.removeSlugs();
        if (isBlock) {
            slugTemplate = ve.ce.BranchNode.blockSlugTemplate;
        } else if (ve.inputDebug) {
            slugTemplate = ve.ce.BranchNode.inputDebugInlineSlugTemplate;
        } else {
            slugTemplate = ve.ce.BranchNode.inlineSlugTemplate;
        }
        for (i in this.getModel().slugPositions) {
            slugNode = doc.importNode(slugTemplate, true);
            if (this.children[i] && this.children[i].$element[0]) {
                child = this.children[i].$element[0];
                child.parentNode.insertBefore(slugNode, child);
            } else {
                this.$element[0].appendChild(slugNode);
            }
            this.slugNodes[i] = slugNode;
            if (isBlock) {
                slugButton = new ve.ui.NoFocusButtonWidget({
                    label: ve.msg('visualeditor-slug-insert'),
                    icon: 'add',
                    framed: !1
                }).on('click', this.onSlugClick.bind(this, slugNode));
                $(slugNode).append(slugButton.$element);
            }
        }
    }
    ;
    ve.ce.BranchNode.prototype.onSlugClick = function(slugNode) {
        this.getRoot().getSurface().createSlug(slugNode);
    }
    ;
    ve.ce.BranchNode.prototype.getSlugAtOffset = function(offset) {
        var i, startOffset = this.model.getOffset() + (this.isWrapped() ? 1 : 0);
        if (offset === startOffset) {
            return this.slugNodes[0] || null;
        }
        for (i = 0; i < this.children.length; i++) {
            startOffset += this.children[i].model.getOuterLength();
            if (offset === startOffset) {
                return this.slugNodes[i + 1] || null;
            }
        }
        return null;
    }
    ;
    ve.ce.BranchNode.prototype.setLive = function(live) {
        var i;
        ve.ce.BranchNode.super.prototype.setLive.apply(this, arguments);
        for (i = 0; i < this.children.length; i++) {
            this.children[i].setLive(live);
        }
    }
    ;
    ve.ce.BranchNode.prototype.destroy = function() {
        var i, len;
        for (i = 0,
        len = this.children.length; i < len; i++) {
            this.children[i].destroy();
        }
        ve.ce.BranchNode.super.prototype.destroy.call(this);
    }
    ;
    ve.ce.BranchNode.prototype.detach = function() {
        var i, len;
        for (i = 0,
        len = this.children.length; i < len; i++) {
            this.children[i].detach();
        }
        ve.ce.BranchNode.super.prototype.detach.call(this);
    }
    ;
    ve.ce.BranchNode.prototype.getDomPosition = function(offset) {
        var i, ceNode, domNode = this.$element.last()[0];
        i = offset - 1;
        while (true) {
            ceNode = this.children[i--];
            if (!ceNode) {
                return {
                    node: domNode,
                    offset: 0
                };
            }
            if (ceNode.$element && ceNode.$element.length > 0) {
                return {
                    node: domNode,
                    offset: Array.prototype.indexOf.call(domNode.childNodes, ceNode.$element.last()[0]) + 1
                };
            }
            if (ceNode.getType() === 'text') {
                break;
            }
        }
        i = offset;
        while (true) {
            ceNode = this.children[i++];
            if (!ceNode) {
                return {
                    node: domNode,
                    offset: domNode.childNodes.length
                };
            }
            if (ceNode.$element && ceNode.$element.length > 0) {
                return {
                    node: domNode,
                    offset: Array.prototype.indexOf.call(domNode.childNodes, ceNode.$element.first()[0])
                };
            }
            if (ceNode.getType() === 'text') {
                break;
            }
        }
        throw new Error('Cannot calculate DOM position: adjacent text nodes');
    }
    ;
    ve.ce.ContentBranchNode = function VeCeContentBranchNode() {
        this.lastTransaction = null;
        this.rendered = !1;
        this.unicornAnnotations = null;
        this.unicorns = null;
        ve.ce.ContentBranchNode.super.apply(this, arguments);
        this.onClickHandler = this.onClick.bind(this);
        this.$element.addClass('ve-ce-contentBranchNode');
        this.connect(this, {
            childUpdate: 'onChildUpdate'
        });
        this.model.connect(this, {
            detach: 'onModelDetach'
        });
        this.$element.on('click', this.onClickHandler);
    }
    ;
    OO.inheritClass(ve.ce.ContentBranchNode, ve.ce.BranchNode);
    ve.ce.ContentBranchNode.static.splitOnEnter = !0;
    ve.ce.ContentBranchNode.static.appendRenderedContents = function(container, wrapper) {
        function resolveOriginals(domElement) {
            var i, len, child;
            for (i = 0,
            len = domElement.childNodes.length; i < len; i++) {
                child = domElement.childNodes[i];
                if (child.veOrigNode) {
                    domElement.replaceChild(child.veOrigNode, child);
                } else if (child.childNodes && child.childNodes.length) {
                    resolveOriginals(child);
                }
            }
        }
        resolveOriginals(wrapper);
        while (wrapper.firstChild) {
            container.appendChild(wrapper.firstChild);
        }
    }
    ;
    ve.ce.ContentBranchNode.prototype.onSetup = function() {
        ve.ce.ContentBranchNode.super.prototype.onSetup.apply(this, arguments);
        this.$element.addClass('ve-ce-contentBranchNode');
    }
    ;
    ve.ce.ContentBranchNode.prototype.onClick = function(e) {
        if ((e.target !== this.$element[0] && e.target.nodeName.toUpperCase() === 'A') && (!e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey)) {
            e.preventDefault();
        }
    }
    ;
    ve.ce.ContentBranchNode.prototype.onChildUpdate = function(transaction) {
        if (transaction === null || transaction === this.lastTransaction) {
            this.lastTransaction = transaction;
            return;
        }
        this.renderContents();
    }
    ;
    ve.ce.ContentBranchNode.prototype.onSplice = function(index, howmany) {
        ve.ce.ContentBranchNode.super.prototype.onSplice.apply(this, arguments);
        if (this.root instanceof ve.ce.DocumentNode && this.root.getSurface().isRenderingLocked) {
            this.slugNodes.splice.apply(this.slugNodes, [index, howmany].concat(new Array(arguments.length - 2)));
        }
        this.renderContents();
    }
    ;
    ve.ce.ContentBranchNode.prototype.setupBlockSlugs = function() {
        if (this.root instanceof ve.ce.DocumentNode && this.root.getSurface().isRenderingLocked()) {
            return;
        }
        ve.ce.ContentBranchNode.super.prototype.setupBlockSlugs.apply(this, arguments);
    }
    ;
    ve.ce.ContentBranchNode.prototype.setupInlineSlugs = function() {
        if (this.root instanceof ve.ce.DocumentNode && this.root.getSurface().isRenderingLocked()) {
            return;
        }
        ve.ce.ContentBranchNode.super.prototype.setupInlineSlugs.apply(this, arguments);
    }
    ;
    ve.ce.ContentBranchNode.prototype.getRenderedContents = function() {
        var i, ilen, j, jlen, item, itemAnnotations, clone, dmSurface, dmSelection, relCursor, unicorn, preUnicorn, postUnicorn, annotationsChanged, childLength, offset, htmlItem, ceSurface, store = this.model.doc.getStore(), annotationSet = new ve.dm.AnnotationSet(store), annotatedHtml = [], doc = this.getElementDocument(), wrapper = doc.createElement('div'), current = wrapper, annotationStack = [], nodeStack = [], unicornInfo = {
            hasCursor: !1,
            annotations: null,
            unicorns: null
        }, buffer = '', node = this;
        if (this.getModel().getDocument().sourceMode) {
            wrapper.appendChild(document.createTextNode(this.getModel().getDocument().getDataFromNode(this.getModel()).join('')));
            wrapper.unicornInfo = unicornInfo;
            return wrapper;
        }
        function openAnnotation(annotation) {
            var ann;
            annotationsChanged = !0;
            if (buffer !== '') {
                if (current.nodeType === Node.TEXT_NODE) {
                    current.textContent += buffer;
                } else {
                    current.appendChild(doc.createTextNode(buffer));
                }
                buffer = '';
            }
            annotation.store = store;
            ann = ve.ce.annotationFactory.create(annotation.getType(), annotation, node);
            ann.appendTo(current);
            annotationStack.push(ann);
            nodeStack.push(current);
            current = ann.getContentContainer();
        }
        function closeAnnotation() {
            var ann;
            annotationsChanged = !0;
            if (buffer !== '') {
                if (current.nodeType === Node.TEXT_NODE) {
                    current.textContent += buffer;
                } else {
                    current.appendChild(doc.createTextNode(buffer));
                }
                buffer = '';
            }
            ann = annotationStack.pop();
            ann.attachContents();
            current = nodeStack.pop();
        }
        for (i = 0,
        ilen = this.children.length; i < ilen; i++) {
            annotatedHtml = annotatedHtml.concat(this.children[i].getAnnotatedHtml());
        }
        relCursor = -1;
        if (this.getRoot()) {
            ceSurface = this.getRoot().getSurface();
            dmSurface = ceSurface.getModel();
            dmSelection = dmSurface.getTranslatedSelection();
            if (dmSelection instanceof ve.dm.LinearSelection && dmSelection.isCollapsed()) {
                relCursor = dmSelection.getRange().start - this.getOffset() - 1;
            }
        }
        if (relCursor < 0 || relCursor > this.getLength()) {
            unicornInfo.hasCursor = !1;
        } else {
            unicornInfo.hasCursor = !0;
            offset = 0;
            for (i = 0,
            ilen = annotatedHtml.length; i < ilen; i++) {
                htmlItem = annotatedHtml[i][0];
                childLength = (typeof htmlItem === 'string') ? 1 : 2;
                if (offset <= relCursor && relCursor < offset + childLength) {
                    unicorn = [{}, dmSurface.getInsertionAnnotations().storeHashes];
                    annotatedHtml.splice(i, 0, unicorn);
                    break;
                }
                offset += childLength;
            }
            if (i === ilen && offset === relCursor) {
                unicorn = [{}, dmSurface.getInsertionAnnotations().storeHashes];
                annotatedHtml.push(unicorn);
            }
        }
        for (i = 0,
        ilen = annotatedHtml.length; i < ilen; i++) {
            if (Array.isArray(annotatedHtml[i])) {
                item = annotatedHtml[i][0];
                itemAnnotations = new ve.dm.AnnotationSet(store,annotatedHtml[i][1]);
            } else {
                item = annotatedHtml[i];
                itemAnnotations = new ve.dm.AnnotationSet(store);
            }
            annotationsChanged = !1;
            ve.dm.Converter.static.openAndCloseAnnotations(annotationSet, itemAnnotations, openAnnotation, closeAnnotation);
            if (typeof item === 'string') {
                buffer += item;
            } else if (unicorn && item === unicorn[0]) {
                if (annotationsChanged) {
                    if (buffer !== '') {
                        current.appendChild(doc.createTextNode(buffer));
                        buffer = '';
                    }
                    preUnicorn = doc.createElement('img');
                    postUnicorn = doc.createElement('img');
                    preUnicorn.className = 've-ce-unicorn ve-ce-pre-unicorn';
                    postUnicorn.className = 've-ce-unicorn ve-ce-post-unicorn';
                    $(preUnicorn).data('modelOffset', (this.getOffset() + 1 + i));
                    $(postUnicorn).data('modelOffset', (this.getOffset() + 1 + i));
                    if (ve.inputDebug) {
                        preUnicorn.setAttribute('src', ve.ce.unicornImgDataUri);
                        postUnicorn.setAttribute('src', ve.ce.unicornImgDataUri);
                        preUnicorn.className += ' ve-ce-unicorn-debug';
                        postUnicorn.className += ' ve-ce-unicorn-debug';
                    } else {
                        preUnicorn.setAttribute('src', ve.ce.minImgDataUri);
                        postUnicorn.setAttribute('src', ve.ce.minImgDataUri);
                    }
                    current.appendChild(preUnicorn);
                    current.appendChild(postUnicorn);
                    unicornInfo.annotations = dmSurface.getInsertionAnnotations();
                    unicornInfo.unicorns = [preUnicorn, postUnicorn];
                } else {
                    unicornInfo.annotations = null;
                    unicornInfo.unicorns = null;
                }
            } else {
                if (buffer !== '') {
                    current.appendChild(doc.createTextNode(buffer));
                    buffer = '';
                }
                for (j = 0,
                jlen = item.length; j < jlen; j++) {
                    clone = item[j].cloneNode(true);
                    clone.veOrigNode = item[j];
                    current.appendChild(clone);
                }
            }
        }
        if (buffer !== '') {
            current.appendChild(doc.createTextNode(buffer));
            buffer = '';
        }
        while (annotationStack.length > 0) {
            closeAnnotation();
        }
        wrapper.unicornInfo = unicornInfo;
        return wrapper;
    }
    ;
    ve.ce.ContentBranchNode.prototype.onModelDetach = function() {
        if (this.root instanceof ve.ce.DocumentNode) {
            this.root.getSurface().setContentBranchNodeChanged();
        }
    }
    ;
    ve.ce.ContentBranchNode.prototype.renderContents = function() {
        var i, len, element, rendered, unicornInfo, oldWrapper, newWrapper, node = this;
        if (this.root instanceof ve.ce.DocumentNode && this.root.getSurface().isRenderingLocked()) {
            return false;
        }
        if (this.root instanceof ve.ce.DocumentNode) {
            this.root.getSurface().setContentBranchNodeChanged();
        }
        rendered = this.getRenderedContents();
        unicornInfo = rendered.unicornInfo;
        if (this.rendered) {
            oldWrapper = this.$element[0].cloneNode(true);
            $(oldWrapper).find('.ve-ce-annotation-active').removeClass('ve-ce-annotation-active');
            $(oldWrapper).find('.ve-ce-branchNode-inlineSlug').children().unwrap().filter('.ve-ce-chimera').remove();
            newWrapper = this.$element[0].cloneNode(false);
            while (rendered.firstChild) {
                newWrapper.appendChild(rendered.firstChild);
            }
            ve.normalizeNode(oldWrapper);
            ve.normalizeNode(newWrapper);
            if (newWrapper.isEqualNode(oldWrapper)) {
                return false;
            }
            rendered = newWrapper;
        }
        this.rendered = !0;
        this.unicornAnnotations = unicornInfo.annotations || null;
        this.unicorns = unicornInfo.unicorns || null;
        for (i = 0,
        len = this.$element.length; i < len; i++) {
            element = this.$element[i];
            while (element.firstChild) {
                element.removeChild(element.firstChild);
            }
        }
        this.constructor.static.appendRenderedContents(this.$element[0], rendered);
        if (this.getRoot()) {
            if (!unicornInfo.hasCursor) {
                this.getRoot().getSurface().setNotUnicorning(this);
            } else if (this.unicorns) {
                this.getRoot().getSurface().setUnicorning(this);
            } else {
                this.getRoot().getSurface().setNotUnicorningAll(this);
            }
        }
        this.setupInlineSlugs();
        if (ve.inputDebug) {
            this.$element.css('backgroundColor', '#eee');
            setTimeout(function() {
                node.$element.css('backgroundColor', '');
            }, 300);
        }
        return true;
    }
    ;
    ve.ce.ContentBranchNode.prototype.detach = function() {
        if (this.getRoot()) {
            this.getRoot().getSurface().setNotUnicorning(this);
        }
        ve.ce.ContentBranchNode.super.prototype.detach.call(this);
    }
    ;
    ve.ce.ContentBranchNode.prototype.destroy = function() {
        this.$element.off('click', this.onClickHandler);
        ve.ce.ContentBranchNode.super.prototype.destroy.call(this);
    }
    ;
    ve.ce.LeafNode = function VeCeLeafNode() {
        ve.LeafNode.call(this);
        ve.ce.LeafNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ce.LeafNode, ve.ce.Node);
    OO.mixinClass(ve.ce.LeafNode, ve.LeafNode);
    ve.ce.LeafNode.static.tagName = 'span';
    ve.ce.LeafNode.prototype.initialize = function() {
        ve.ce.LeafNode.super.prototype.initialize.call(this);
        if (this.model.isWrapped()) {
            this.$element.addClass('ve-ce-leafNode');
        }
    }
    ;
    ve.ce.LeafNode.prototype.getAnnotatedHtml = function() {
        return [[this.$element, this.getModel().getAnnotations()]];
    }
    ;
    ve.ce.MetaItem = function VeCeMetaItem(model, config) {
        ve.ce.MetaItem.super.call(this, model, ve.extendObject({}, config, {
            $element: $()
        }));
    }
    ;
    OO.inheritClass(ve.ce.MetaItem, ve.ce.LeafNode);
    ve.ce.MetaItem.static.name = 'meta';
    ve.ce.nodeFactory.register(ve.ce.MetaItem);
    ve.ce.ClassAttributeNode = function VeCeClassAttributeNode($classedElement) {
        this.$classedElement = $classedElement || this.$element;
        this.currentAttributeClasses = '';
        this.$classedElement.removeClass(this.getModel().getAttribute('originalClasses')).addClass(this.getModel().getAttribute('unrecognizedClasses'));
        this.connect(this, {
            setup: 'updateAttributeClasses'
        });
        this.model.connect(this, {
            attributeChange: 'updateAttributeClasses'
        });
    }
    ;
    OO.initClass(ve.ce.ClassAttributeNode);
    ve.ce.ClassAttributeNode.prototype.updateAttributeClasses = function() {
        this.$classedElement.removeClass(this.currentAttributeClasses);
        this.currentAttributeClasses = this.model.constructor.static.getClassAttrFromAttributes(this.model.element.attributes);
        this.$classedElement.addClass(this.currentAttributeClasses);
    }
    ;
    ve.ce.AlignableNode = function VeCeAlignableNode() {
        ve.ce.AlignableNode.super.apply(this, arguments);
        this.align = null;
    }
    ;
    OO.inheritClass(ve.ce.AlignableNode, ve.ce.ClassAttributeNode);
    ve.ce.AlignableNode.prototype.updateAttributeClasses = function() {
        var align;
        ve.ce.AlignableNode.super.prototype.updateAttributeClasses.apply(this, arguments);
        align = this.model.getAttribute('align');
        if (align && align !== this.align) {
            this.emit('align', align);
            this.align = align;
        }
    }
    ;
    ve.ce.FocusableNode = function VeCeFocusableNode($focusable, config) {
        config = config || {};
        this.focused = !1;
        this.highlighted = !1;
        this.isFocusableSetup = !1;
        this.$highlights = $('<div>').addClass('ve-ce-focusableNode-highlights');
        this.$focusable = $focusable || this.$element;
        this.$bounding = config.$bounding || this.$focusable;
        this.focusableSurface = null;
        this.rects = null;
        this.boundingRect = null;
        this.startAndEndRects = null;
        this.icon = null;
        this.touchMoved = !1;
        if (Array.isArray(config.classes)) {
            this.$highlights.addClass(config.classes.join(' '));
        }
        this.redrawHighlightsDebounced = ve.debounce(this.redrawHighlights.bind(this), 100);
        this.$element.addClass('ve-ce-focusableNode').prop('contentEditable', 'false');
        this.connect(this, {
            setup: 'onFocusableSetup',
            teardown: 'onFocusableTeardown',
            resizeStart: 'onFocusableResizeStart',
            resizeEnd: 'onFocusableResizeEnd',
            rerender: 'onFocusableRerender'
        });
    }
    ;
    OO.initClass(ve.ce.FocusableNode);
    ve.ce.FocusableNode.static.iconWhenInvisible = null;
    ve.ce.FocusableNode.static.getRectsForElement = function($element, relativeRect) {
        var i, l, $set, columnCount, columnWidth, boundingRect = null, rects = [], filteredRects = [], webkitColumns = 'webkitColumnCount'in document.createElement('div').style;
        function contains(rect1, rect2) {
            return rect2.left >= rect1.left && rect2.top >= rect1.top && rect2.right <= rect1.right && rect2.bottom <= rect1.bottom;
        }
        function process(el) {
            var i, j, il, jl, contained, clientRects, overflow, $el;
            if (el.classList.contains('ve-ce-noHighlight')) {
                return;
            }
            $el = $(el);
            if (webkitColumns) {
                columnCount = $el.css('-webkit-column-count');
                columnWidth = $el.css('-webkit-column-width');
                if ((columnCount && columnCount !== 'auto') || (columnWidth && columnWidth !== 'auto')) {
                    $set = $set.not($el.find('*'));
                }
            }
            overflow = $el.css('overflow');
            if (overflow && overflow !== 'visible' && $el.css('display') !== 'inline') {
                $set = $set.not($el.find('*'));
            }
            clientRects = el.getClientRects();
            for (i = 0,
            il = clientRects.length; i < il; i++) {
                contained = !1;
                for (j = 0,
                jl = rects.length; j < jl; j++) {
                    if (contains(rects[j], clientRects[i])) {
                        contained = !0;
                        break;
                    }
                    if (contains(clientRects[i], rects[j])) {
                        rects.splice(j, 1);
                        j--;
                        jl--;
                    }
                }
                if (!contained) {
                    rects.push(clientRects[i]);
                }
            }
        }
        $set = $element.find('*').addBack();
        for (i = 0; i < $set.length; i++) {
            process($set[i]);
        }
        filteredRects = rects.filter(function(rect) {
            return rect.width > 1 && rect.height > 1;
        });
        if (filteredRects.length > 0) {
            rects = filteredRects;
        }
        boundingRect = null;
        for (i = 0,
        l = rects.length; i < l; i++) {
            if (relativeRect) {
                rects[i] = ve.translateRect(rects[i], -relativeRect.left, -relativeRect.top);
            }
            if (!boundingRect) {
                boundingRect = ve.copy(rects[i]);
            } else {
                boundingRect.top = Math.min(boundingRect.top, rects[i].top);
                boundingRect.left = Math.min(boundingRect.left, rects[i].left);
                boundingRect.bottom = Math.max(boundingRect.bottom, rects[i].bottom);
                boundingRect.right = Math.max(boundingRect.right, rects[i].right);
            }
        }
        if (boundingRect) {
            boundingRect.width = boundingRect.right - boundingRect.left;
            boundingRect.height = boundingRect.bottom - boundingRect.top;
        }
        return {
            rects: rects,
            boundingRect: boundingRect
        };
    }
    ;
    ve.ce.FocusableNode.prototype.createHighlight = function() {
        var extraClasses = this.generatedContentsInvalid ? ' ve-ce-focusableNode-highlight-error' : '';
        return $('<div>').addClass('ve-ce-focusableNode-highlight' + extraClasses).prop({
            title: this.constructor.static.getDescription(this.model),
            draggable: !0
        }).on({
            dragstart: this.onFocusableDragStart.bind(this),
            dragend: this.onFocusableDragEnd.bind(this)
        });
    }
    ;
    ve.ce.FocusableNode.prototype.onFocusableSetup = function() {
        if (this.isFocusableSetup || !this.root) {
            return;
        }
        this.focusableSurface = this.root.getSurface();
        if (!this.$element.hasClass('ve-ce-focusableNode')) {
            this.$element.addClass('ve-ce-focusableNode').prop('contentEditable', 'false');
        }
        this.$focusable.on({
            'mouseenter.ve-ce-focusableNode': this.onFocusableMouseEnter.bind(this),
            'touchstart.ve-ce-focusableNode': this.onFocusableTouchStart.bind(this),
            'touchmove.ve-ce-focusableNode': this.onFocusableTouchMove.bind(this),
            'mousedown.ve-ce-focusableNode touchend.ve-ce-focusableNode': this.onFocusableMouseDown.bind(this)
        });
        if (!this.$element.is(this.$focusable)) {
            this.$element.on({
                'mousedown.ve-ce-focusableNode': function(e) {
                    if (!ve.isContentEditable(e.target)) {
                        e.preventDefault();
                    }
                }
            });
        }
        this.$element.on({
            'click.ve-ce-focusableNode': function(e) {
                if (!ve.isContentEditable(e.target) && e.which === OO.ui.MouseButtons.LEFT) {
                    e.preventDefault();
                }
            }
        });
        if (this.constructor.static.iconWhenInvisible) {
            this.$element.find('img:not([width]),img:not([height])').addBack('img:not([width]),img:not([height])').on('load', this.updateInvisibleIcon.bind(this));
            this.updateInvisibleIcon();
        }
        this.isFocusableSetup = !0;
    }
    ;
    ve.ce.FocusableNode.prototype.updateInvisibleIcon = function() {
        var showIcon, rAF = window.requestAnimationFrame || setTimeout, node = this;
        if (!this.constructor.static.iconWhenInvisible) {
            return;
        }
        if (this.icon) {
            this.icon.$element.detach();
        }
        showIcon = !this.hasRendering();
        rAF(function() {
            node.updateInvisibleIconSync(showIcon);
        });
    }
    ;
    ve.ce.FocusableNode.prototype.updateInvisibleIconSync = function(showIcon) {
        if (!this.getModel()) {
            return;
        }
        if (showIcon) {
            this.createInvisibleIcon();
            this.$element.first().addClass('ve-ce-focusableNode-invisible').prepend(this.icon.$element);
        } else if (this.icon) {
            this.$element.first().removeClass('ve-ce-focusableNode-invisible');
            this.icon.$element.detach();
        }
    }
    ;
    ve.ce.FocusableNode.prototype.createInvisibleIcon = function() {
        if (this.icon) {
            return;
        }
        this.icon = new OO.ui.ButtonWidget({
            classes: ['ve-ce-focusableNode-invisibleIcon'],
            framed: !1,
            tabIndex: null,
            icon: this.constructor.static.iconWhenInvisible
        });
        this.updateInvisibleIconLabel();
    }
    ;
    ve.ce.FocusableNode.prototype.getInvisibleIconLabel = function() {
        return this.model ? this.constructor.static.getDescription(this.model) : '';
    }
    ;
    ve.ce.FocusableNode.prototype.updateInvisibleIconLabel = function() {
        if (this.icon) {
            this.icon.setLabel(this.getInvisibleIconLabel() || null);
        }
    }
    ;
    ve.ce.FocusableNode.prototype.onFocusableTeardown = function() {
        if (!this.isFocusableSetup || !this.root) {
            return;
        }
        this.$focusable.off('.ve-ce-focusableNode');
        this.$element.off('.ve-ce-focusableNode');
        this.clearHighlights();
        this.$element.removeClass('ve-ce-focusableNode').removeProp('contentEditable');
        this.focusableSurface = null;
        this.isFocusableSetup = !1;
    }
    ;
    ve.ce.FocusableNode.prototype.onFocusableMouseDown = function(e) {
        var range, node = this, surfaceModel = this.focusableSurface.getModel(), selection = surfaceModel.getSelection(), nodeRange = this.model.getOuterRange();
        if (e.type === 'touchend' && this.touchMoved) {
            return;
        }
        if (!this.isInContentEditable()) {
            return;
        }
        if (e.which === OO.ui.MouseButtons.RIGHT) {
            this.$highlights.prop('contentEditable', 'true');
            ve.selectElement(this.$highlights[0]);
            setTimeout(function() {
                node.$highlights.prop('contentEditable', 'false');
                node.focusableSurface.preparePasteTargetForCopy();
            });
        }
        setTimeout(function() {
            range = selection instanceof ve.dm.LinearSelection && selection.getRange();
            surfaceModel.getLinearFragment(e.shiftKey && range ? ve.Range.static.newCoveringRange([range, nodeRange], range.from > nodeRange.from) : nodeRange).select();
            node.focusableSurface.updateActiveAnnotations();
            node.focusableSurface.activate();
        });
    }
    ;
    ve.ce.FocusableNode.prototype.onFocusableDblClick = function() {
        if (!this.isInContentEditable()) {
            return;
        }
        if (this.getModel().isEditable()) {
            this.executeCommand();
        }
    }
    ;
    ve.ce.FocusableNode.prototype.executeCommand = function() {
        var command, surface;
        if (!this.model.isInspectable()) {
            return;
        }
        surface = this.focusableSurface.getSurface();
        command = surface.commandRegistry.getCommandForNode(this);
        if (command) {
            command.execute(surface);
        }
    }
    ;
    ve.ce.FocusableNode.prototype.onFocusableDragStart = function(e) {
        if (this.focusableSurface) {
            this.focusableSurface.onDocumentDragStart(e);
        }
    }
    ;
    ve.ce.FocusableNode.prototype.onFocusableDragEnd = function() {
        if (this.focusableSurface) {
            this.focusableSurface.endRelocation();
        }
    }
    ;
    ve.ce.FocusableNode.prototype.onFocusableMouseEnter = function() {
        if (!this.root.getSurface().dragging && !this.root.getSurface().resizing && this.isInContentEditable()) {
            this.createHighlights();
        }
    }
    ;
    ve.ce.FocusableNode.prototype.onFocusableTouchStart = function() {
        this.touchMoved = !1;
    }
    ;
    ve.ce.FocusableNode.prototype.onFocusableTouchMove = function() {
        this.touchMoved = !0;
    }
    ;
    ve.ce.FocusableNode.prototype.onSurfaceMouseMove = function(e) {
        var $target = $(e.target);
        if (!$target.hasClass('ve-ce-focusableNode-highlight') && !OO.ui.contains(this.$focusable.toArray(), $target[0], true)) {
            this.clearHighlights();
        }
    }
    ;
    ve.ce.FocusableNode.prototype.onSurfaceMouseLeave = function(e) {
        if (e.relatedTarget === null) {
            this.clearHighlights();
        }
    }
    ;
    ve.ce.FocusableNode.prototype.onFocusableResizeStart = function() {
        this.clearHighlights();
    }
    ;
    ve.ce.FocusableNode.prototype.onFocusableResizeEnd = function() {
        this.redrawHighlightsDebounced();
    }
    ;
    ve.ce.FocusableNode.prototype.onFocusableRerender = function() {
        if (this.focused && this.focusableSurface) {
            this.redrawHighlightsDebounced();
            this.focusableSurface.getSurface().getContext().updateDimensions(true);
        }
    }
    ;
    ve.ce.FocusableNode.prototype.isFocused = function() {
        return this.focused;
    }
    ;
    ve.ce.FocusableNode.prototype.setFocused = function(value) {
        value = !!value;
        if (this.focused !== value) {
            this.focused = value;
            if (this.focused) {
                this.emit('focus');
                this.$element.addClass('ve-ce-focusableNode-focused');
                this.createHighlights();
                this.focusableSurface.appendHighlights(this.$highlights, this.focused);
                this.focusableSurface.$element.off('.ve-ce-focusableNode');
            } else {
                this.emit('blur');
                this.$element.removeClass('ve-ce-focusableNode-focused');
                this.$highlights.removeClass('ve-ce-focusableNode-highlights-deactivated');
                this.clearHighlights();
            }
        }
    }
    ;
    ve.ce.FocusableNode.prototype.createHighlights = function() {
        if (this.highlighted) {
            return;
        }
        this.$highlights.on({
            mousedown: this.onFocusableMouseDown.bind(this),
            dblclick: this.onFocusableDblClick.bind(this)
        });
        this.highlighted = !0;
        this.positionHighlights();
        this.focusableSurface.appendHighlights(this.$highlights, this.focused);
        this.focusableSurface.connect(this, {
            position: 'positionHighlights',
            activation: 'onSurfaceActivation'
        });
        if (!this.focused) {
            this.focusableSurface.$element.on({
                'mousemove.ve-ce-focusableNode': this.onSurfaceMouseMove.bind(this),
                'mouseleave.ve-ce-focusableNode': this.onSurfaceMouseLeave.bind(this)
            });
        }
    }
    ;
    ve.ce.FocusableNode.prototype.onSurfaceActivation = function() {
        this.$highlights.toggleClass('ve-ce-focusableNode-highlights-deactivated', !!this.focusableSurface.isShownAsDeactivated());
    }
    ;
    ve.ce.FocusableNode.prototype.clearHighlights = function() {
        if (!this.highlighted) {
            return;
        }
        this.$highlights.remove().empty();
        this.focusableSurface.$element.off('.ve-ce-focusableNode');
        this.focusableSurface.disconnect(this);
        this.highlighted = !1;
        this.boundingRect = null;
    }
    ;
    ve.ce.FocusableNode.prototype.redrawHighlights = function() {
        if (this.focused) {
            this.setFocused(false);
            this.setFocused(true);
        }
    }
    ;
    ve.ce.FocusableNode.prototype.calculateHighlights = function() {
        var allRects, surfaceOffset;
        if (!this.focusableSurface) {
            this.rects = [];
            this.boundingRect = null;
            this.startAndEndRects = null;
            return;
        }
        surfaceOffset = this.focusableSurface.getSurface().getBoundingClientRect();
        allRects = this.constructor.static.getRectsForElement(this.$focusable, surfaceOffset);
        this.rects = allRects.rects;
        this.boundingRect = allRects.boundingRect;
        this.startAndEndRects = null;
    }
    ;
    ve.ce.FocusableNode.prototype.positionHighlights = function() {
        var i, l;
        if (!this.highlighted) {
            return;
        }
        this.calculateHighlights();
        this.$highlights.empty().append($('<span>').addClass('ve-ce-focusableNode-highlight-selectable').html('&nbsp;'));
        for (i = 0,
        l = this.rects.length; i < l; i++) {
            this.$highlights.append(this.createHighlight().css({
                top: this.rects[i].top,
                left: this.rects[i].left,
                width: this.rects[i].width,
                height: this.rects[i].height
            }));
        }
    }
    ;
    ve.ce.FocusableNode.prototype.getRects = function() {
        if (!this.highlighted) {
            this.calculateHighlights();
        }
        return this.rects;
    }
    ;
    ve.ce.FocusableNode.prototype.getBoundingRect = function() {
        var surfaceOffset, allRects;
        if (!this.$bounding.is(this.$focusable)) {
            surfaceOffset = this.focusableSurface.getSurface().getBoundingClientRect();
            allRects = this.constructor.static.getRectsForElement(this.$bounding, surfaceOffset);
            return allRects.boundingRect;
        }
        if (!this.highlighted) {
            this.calculateHighlights();
        }
        return this.boundingRect;
    }
    ;
    ve.ce.FocusableNode.prototype.getStartAndEndRects = function() {
        if (!this.highlighted) {
            this.calculateHighlights();
        }
        if (!this.startAndEndRects) {
            this.startAndEndRects = ve.getStartAndEndRects(this.rects);
        }
        return this.startAndEndRects;
    }
    ;
    ve.ce.FocusableNode.prototype.hasRendering = function() {
        var visible = !1;
        if (this.$element.text().trim() !== '') {
            return true;
        }
        this.$element.each(function() {
            if ((this.offsetWidth >= 8 && this.offsetHeight >= 8) || (this.width >= 8 && this.height >= 8)) {
                visible = !0;
                return false;
            }
        });
        return visible;
    }
    ;
    ve.ce.ResizableNode = function VeCeResizableNode($resizable, config) {
        config = config || {};
        this.$resizable = $resizable || this.$element;
        this.resizing = !1;
        this.$resizeHandles = $('<div>');
        this.snapToGrid = config.snapToGrid !== undefined ? config.snapToGrid : 10;
        this.outline = !!config.outline;
        this.showSizeLabel = config.showSizeLabel !== !1;
        this.showScaleLabel = config.showScaleLabel !== !1;
        this.canShowScaleLabel = !1;
        if (this.showSizeLabel || this.showScaleLabel) {
            this.$sizeText = $('<span>').addClass('ve-ce-resizableNode-sizeText');
            this.$sizeLabel = $('<div>').addClass('ve-ce-resizableNode-sizeLabel').append(this.$sizeText);
        }
        this.resizableOffset = null;
        this.resizableSurface = null;
        this.connect(this, {
            focus: 'onResizableFocus',
            blur: 'onResizableBlur',
            setup: 'onResizableSetup',
            teardown: 'onResizableTeardown',
            resizing: 'onResizableResizing',
            resizeEnd: 'onResizableFocus',
            rerender: 'onResizableFocus',
            align: 'onResizableAlign'
        });
        this.model.connect(this, {
            attributeChange: 'onResizableAttributeChange'
        });
        this.$resizeHandles.addClass('ve-ce-resizableNode-handles').append($('<div>').addClass('ve-ce-resizableNode-nwHandle').data('handle', 'nw')).append($('<div>').addClass('ve-ce-resizableNode-neHandle').data('handle', 'ne')).append($('<div>').addClass('ve-ce-resizableNode-seHandle').data('handle', 'se')).append($('<div>').addClass('ve-ce-resizableNode-swHandle').data('handle', 'sw'));
    }
    ;
    OO.initClass(ve.ce.ResizableNode);
    ve.ce.ResizableNode.prototype.isResizable = function() {
        return this.$resizable && !!this.$resizable.length && !OO.ui.isMobile() && !(this.root && this.root.getSurface() && this.root.getSurface().isReadOnly());
    }
    ;
    ve.ce.ResizableNode.prototype.getResizableOffset = function() {
        if (!this.resizableOffset) {
            this.resizableOffset = OO.ui.Element.static.getRelativePosition(this.$resizable, this.resizableSurface.getSurface().$element);
        }
        return this.resizableOffset;
    }
    ;
    ve.ce.ResizableNode.prototype.setOriginalDimensions = function(dimensions) {
        var scalable;
        if (!this.isResizable()) {
            return;
        }
        scalable = this.model.getScalable();
        scalable.setOriginalDimensions(dimensions);
        this.canShowScaleLabel = this.showScaleLabel && scalable.getOriginalDimensions().width && scalable.getOriginalDimensions().height;
    }
    ;
    ve.ce.ResizableNode.prototype.hideSizeLabel = function() {
        var node = this;
        if (!this.isResizable()) {
            return;
        }
        setTimeout(function() {
            node.$sizeLabel.removeClass('ve-ce-resizableNode-sizeLabel-resizing');
        });
        setTimeout(function() {
            node.$sizeLabel.addClass('oo-ui-element-hidden');
        }, 200);
    }
    ;
    ve.ce.ResizableNode.prototype.updateSizeLabel = function() {
        var top, height, scalable, dimensions, offset, minWidth;
        if (!this.isResizable()) {
            return;
        }
        if (!this.showSizeLabel && !this.canShowScaleLabel) {
            return;
        }
        scalable = this.model.getScalable();
        dimensions = scalable.getCurrentDimensions();
        offset = this.getResizableOffset();
        minWidth = (this.showSizeLabel ? 100 : 0) + (this.showScaleLabel ? 30 : 0);
        if (dimensions.width < minWidth) {
            top = offset.top + dimensions.height;
            height = 30;
        } else {
            top = offset.top;
            height = dimensions.height;
        }
        this.$sizeLabel.removeClass('oo-ui-element-hidden').addClass('ve-ce-resizableNode-sizeLabel-resizing').css({
            top: top,
            left: offset.left,
            width: dimensions.width,
            height: height,
            lineHeight: height + 'px'
        });
        this.$sizeText.empty();
        if (this.showSizeLabel) {
            this.$sizeText.append($('<span>').addClass('ve-ce-resizableNode-sizeText-size').text(Math.round(dimensions.width) + '  ' + Math.round(dimensions.height)));
        }
        if (this.canShowScaleLabel) {
            this.$sizeText.append($('<span>').addClass('ve-ce-resizableNode-sizeText-scale').text(Math.round(100 * scalable.getCurrentScale()) + '%'));
        }
        this.$sizeText.toggleClass('ve-ce-resizableNode-sizeText-warning', scalable.isTooSmall() || scalable.isTooLarge());
    }
    ;
    ve.ce.ResizableNode.prototype.showHandles = function(handles) {
        var i, len, add = [], remove = [], allDirections = ['nw', 'ne', 'sw', 'se'];
        if (!this.isResizable()) {
            return;
        }
        for (i = 0,
        len = allDirections.length; i < len; i++) {
            if (handles === undefined || handles.indexOf(allDirections[i]) !== -1) {
                remove.push('ve-ce-resizableNode-hide-' + allDirections[i]);
            } else {
                add.push('ve-ce-resizableNode-hide-' + allDirections[i]);
            }
        }
        this.$resizeHandles.addClass(add.join(' ')).removeClass(remove.join(' '));
    }
    ;
    ve.ce.ResizableNode.prototype.onResizableFocus = function() {
        if (!this.isResizable() || !this.isFocused()) {
            return;
        }
        this.$resizeHandles.appendTo(this.resizableSurface.getSurface().$controls);
        if (this.$sizeLabel) {
            this.$sizeLabel.appendTo(this.resizableSurface.getSurface().$controls);
        }
        this.model.getScalable();
        this.setResizableHandlesSizeAndPosition();
        this.$resizeHandles.find('.ve-ce-resizableNode-neHandle').css({
            marginRight: -this.$resizable.outerWidth()
        });
        this.$resizeHandles.find('.ve-ce-resizableNode-swHandle').css({
            marginBottom: -this.$resizable.outerHeight()
        });
        this.$resizeHandles.find('.ve-ce-resizableNode-seHandle').css({
            marginRight: -this.$resizable.outerWidth(),
            marginBottom: -this.$resizable.outerHeight()
        });
        this.$resizeHandles.children().off('.ve-ce-resizableNode').on('mousedown.ve-ce-resizableNode', this.onResizeHandlesCornerMouseDown.bind(this));
        this.resizableSurface.connect(this, {
            position: 'setResizableHandlesSizeAndPosition'
        });
    }
    ;
    ve.ce.ResizableNode.prototype.onResizableBlur = function() {
        if (!this.isResizableSetup || !this.root) {
            return;
        }
        this.$resizeHandles.detach();
        if (this.$sizeLabel) {
            this.$sizeLabel.detach();
        }
        this.resizableSurface.disconnect(this, {
            position: 'setResizableHandlesSizeAndPosition'
        });
    }
    ;
    ve.ce.ResizableNode.prototype.onResizableAlign = function(align) {
        if (!this.isResizable()) {
            return;
        }
        switch (align) {
        case 'right':
            this.showHandles(['sw']);
            break;
        case 'left':
            this.showHandles(['se']);
            break;
        case 'center':
            this.showHandles(['sw', 'se']);
            break;
        default:
            this.showHandles();
            break;
        }
    }
    ;
    ve.ce.ResizableNode.prototype.onResizableSetup = function() {
        if (this.isResizableSetup || !this.root) {
            return;
        }
        this.resizableSurface = this.root.getSurface();
        this.isResizableSetup = !0;
    }
    ;
    ve.ce.ResizableNode.prototype.onResizableTeardown = function() {
        if (!this.isResizableSetup || !this.root) {
            return;
        }
        this.onResizableBlur();
        this.resizableSurface = null;
        this.isResizableSetup = !1;
    }
    ;
    ve.ce.ResizableNode.prototype.onResizableResizing = function(dimensions) {
        if (!this.isResizable()) {
            return;
        }
        this.resizableOffset = null;
        this.model.getScalable().setCurrentDimensions(dimensions);
        if (!this.outline) {
            this.$resizable.css(this.model.getScalable().getCurrentDimensions());
            this.setResizableHandlesPosition();
        }
        this.updateSizeLabel();
    }
    ;
    ve.ce.ResizableNode.prototype.onResizableAttributeChange = function() {
        if (!this.isResizable()) {
            return;
        }
        this.$resizable.css(this.model.getCurrentDimensions());
    }
    ;
    ve.ce.ResizableNode.prototype.onResizeHandlesCornerMouseDown = function(e) {
        this.root.getSurface().getSurface().getContext().toggle(false);
        this.$resizeHandles.addClass('ve-ce-resizableNode-handles-resizing').css({
            width: this.$resizable.outerWidth(),
            height: this.$resizable.outerHeight()
        });
        this.$resizeHandles.children().css('margin', 0);
        this.resizeInfo = {
            mouseX: e.screenX,
            mouseY: e.screenY,
            top: this.$resizeHandles.position().top,
            left: this.$resizeHandles.position().left,
            height: this.$resizeHandles.height(),
            width: this.$resizeHandles.width(),
            handle: $(e.target).data('handle')
        };
        this.resizing = !0;
        this.root.getSurface().resizing = !0;
        this.model.getScalable().setCurrentDimensions({
            width: this.resizeInfo.width,
            height: this.resizeInfo.height
        });
        this.updateSizeLabel();
        $(this.getElementDocument()).on({
            'mousemove.ve-ce-resizableNode': this.onDocumentMouseMove.bind(this),
            'mouseup.ve-ce-resizableNode': this.onDocumentMouseUp.bind(this)
        });
        this.emit('resizeStart');
        e.preventDefault();
    }
    ;
    ve.ce.ResizableNode.prototype.setResizableHandlesSizeAndPosition = function() {
        var width, height;
        if (!this.isResizable()) {
            return;
        }
        width = this.$resizable.outerWidth();
        height = this.$resizable.outerHeight();
        this.resizableOffset = null;
        this.setResizableHandlesPosition();
        this.$resizeHandles.css({
            width: 0,
            height: 0
        }).find('.ve-ce-resizableNode-neHandle').css({
            marginRight: -width
        });
        this.$resizeHandles.find('.ve-ce-resizableNode-swHandle').css({
            marginBottom: -height
        });
        this.$resizeHandles.find('.ve-ce-resizableNode-seHandle').css({
            marginRight: -width,
            marginBottom: -height
        });
    }
    ;
    ve.ce.ResizableNode.prototype.setResizableHandlesPosition = function() {
        var offset;
        if (!this.isResizable()) {
            return;
        }
        offset = this.getResizableOffset();
        this.$resizeHandles.css({
            top: offset.top,
            left: offset.left
        });
    }
    ;
    ve.ce.ResizableNode.prototype.onDocumentMouseMove = function(e) {
        var diff = {}
          , dimensions = {
            width: 0,
            height: 0,
            top: this.resizeInfo.top,
            left: this.resizeInfo.left
        };
        if (this.resizing) {
            switch (this.resizeInfo.handle) {
            case 'se':
                diff.x = e.screenX - this.resizeInfo.mouseX;
                diff.y = e.screenY - this.resizeInfo.mouseY;
                break;
            case 'nw':
                diff.x = this.resizeInfo.mouseX - e.screenX;
                diff.y = this.resizeInfo.mouseY - e.screenY;
                break;
            case 'ne':
                diff.x = e.screenX - this.resizeInfo.mouseX;
                diff.y = this.resizeInfo.mouseY - e.screenY;
                break;
            case 'sw':
                diff.x = this.resizeInfo.mouseX - e.screenX;
                diff.y = e.screenY - this.resizeInfo.mouseY;
                break;
            }
            dimensions = this.model.getScalable().getBoundedDimensions({
                width: this.resizeInfo.width + diff.x,
                height: this.resizeInfo.height + diff.y
            }, e.shiftKey && this.snapToGrid);
            switch (this.resizeInfo.handle) {
            case 'ne':
                dimensions.top = this.resizeInfo.top + (this.resizeInfo.height - dimensions.height);
                break;
            case 'sw':
                dimensions.left = this.resizeInfo.left + (this.resizeInfo.width - dimensions.width);
                break;
            case 'nw':
                dimensions.top = this.resizeInfo.top + (this.resizeInfo.height - dimensions.height);
                dimensions.left = this.resizeInfo.left + (this.resizeInfo.width - dimensions.width);
                break;
            }
            this.$resizeHandles.css(dimensions);
            this.emit('resizing', {
                width: dimensions.width,
                height: dimensions.height
            });
        }
    }
    ;
    ve.ce.ResizableNode.prototype.onDocumentMouseUp = function() {
        var attrChanges, width = this.$resizeHandles.outerWidth(), height = this.$resizeHandles.outerHeight();
        this.$resizeHandles.removeClass('ve-ce-resizableNode-handles-resizing');
        $(this.getElementDocument()).off('.ve-ce-resizableNode');
        this.resizing = !1;
        this.root.getSurface().resizing = !1;
        this.hideSizeLabel();
        attrChanges = this.getAttributeChanges(width, height);
        if (!ve.isEmptyObject(attrChanges)) {
            this.resizableSurface.getModel().getFragment().changeAttributes(attrChanges);
        }
        this.root.getSurface().getSurface().getContext().updateDimensions();
        this.emit('resizeEnd');
    }
    ;
    ve.ce.ResizableNode.prototype.getAttributeChanges = function(width, height) {
        var attrChanges = {}
          , currentDimensions = this.model.getCurrentDimensions();
        if (currentDimensions.width !== width) {
            attrChanges.width = width;
        }
        if (currentDimensions.height !== height) {
            attrChanges.height = height;
        }
        return attrChanges;
    }
    ;
    ve.ce.TableCellableNode = function VeCeTableCellableNode() {
        if (this.isCellable() && !this.isCellEditable()) {
            this.$element.attr('title', ve.msg('visualeditor-aliennode-tooltip'));
        }
        this.$element.addClass('ve-ce-tableCellableNode');
    }
    ;
    OO.initClass(ve.ce.TableCellableNode);
    ve.ce.TableCellableNode.prototype.setEditing = function() {}
    ;
    ve.ce.TableCellableNode.prototype.getTagName = function() {
        var style = this.model.getAttribute('style')
          , types = {
            data: 'td',
            header: 'th'
        };
        if (!Object.prototype.hasOwnProperty.call(types, style)) {
            throw new Error('Invalid style');
        }
        return types[style];
    }
    ;
    ve.ce.Selection = function VeCeSelection(model, surface) {
        this.model = model;
        this.surface = surface;
    }
    ;
    OO.initClass(ve.ce.Selection);
    ve.ce.Selection.static.type = null;
    ve.ce.Selection.static.newFromModel = function(model, surface) {
        return ve.ce.selectionFactory.create(model.getName(), model, surface);
    }
    ;
    ve.ce.Selection.prototype.getSurface = function() {
        return this.surface;
    }
    ;
    ve.ce.Selection.prototype.getModel = function() {
        return this.model;
    }
    ;
    ve.ce.Selection.prototype.getSelectionRects = null;
    ve.ce.Selection.prototype.getSelectionStartAndEndRects = function() {
        return ve.getStartAndEndRects(this.getSelectionRects());
    }
    ;
    ve.ce.Selection.prototype.getSelectionFocusRect = function() {
        var toSelection = new this.constructor(this.getModel().collapseToTo(),this.surface);
        return toSelection.getSelectionBoundingRect();
    }
    ;
    ve.ce.Selection.prototype.getSelectionBoundingRect = null;
    ve.ce.Selection.prototype.isFocusedNode = null;
    ve.ce.Selection.prototype.isNativeCursor = null;
    ve.ce.Selection.prototype.equals = function(other) {
        return this.getSurface() === other.getSurface() && this.getModel().equals(other.getModel());
    }
    ;
    ve.ce.Selection.prototype.getDirectionality = null;
    ve.ce.selectionFactory = new OO.Factory();
    ve.ce.Surface = function VeCeSurface(model, ui, config) {
        var surface = this;
        ve.ce.Surface.super.call(this, config);
        OO.EventEmitter.call(this);
        this.surface = ui;
        this.model = model;
        this.documentView = new ve.ce.Document(model.getDocument(),this);
        this.attachedRoot = this.getDocument().getDocumentNode().getNodeFromOffset(model.getAttachedRoot().getOffset() + (model.getAttachedRoot().isWrapped() ? 1 : 0));
        this.selection = null;
        this.readOnly = !1;
        this.surfaceObserver = new ve.ce.SurfaceObserver(this);
        this.$window = $(this.getElementWindow());
        this.$document = $(this.getElementDocument());
        this.$attachedRootNode = this.attachedRoot.$element.addClass('ve-ce-attachedRootNode');
        this.$documentNode = this.$attachedRootNode;
        this.root = this.attachedRoot;
        this.nativeSelection = this.getElementWindow().getSelection();
        ve.fixSelectionNodes(this.nativeSelection);
        this.eventSequencer = new ve.EventSequencer(['keydown', 'keypress', 'keyup', 'compositionstart', 'compositionend', 'input', 'mousedown']);
        this.clipboard = null;
        this.clipboardId = Math.random().toString();
        this.clipboardIndex = 0;
        this.middleClickSelection = null;
        this.renderLocks = 0;
        this.dragging = !1;
        this.relocatingSelection = null;
        this.relocatingNode = null;
        this.allowedFile = null;
        this.resizing = !1;
        this.focused = !1;
        this.deactivated = !1;
        this.showAsActivated = !1;
        this.hideSelection = !1;
        this.$deactivatedSelection = $('<div>');
        this.activeNode = null;
        this.contentBranchNodeChanged = !1;
        this.selectionLink = null;
        this.delayedSequences = [];
        this.$highlightsFocused = $('<div>');
        this.$highlightsBlurred = $('<div>');
        this.$highlightsUserSelections = $('<div>');
        this.$highlightsUserCursors = $('<div>');
        this.userSelectionOverlays = {};
        this.$highlights = $('<div>').append(this.$highlightsFocused, this.$highlightsBlurred, this.$highlightsUserSelections, this.$highlightsUserCursors);
        this.$findResults = $('<div>');
        this.$dropMarker = $('<div>').addClass('ve-ce-surface-dropMarker oo-ui-element-hidden');
        this.$lastDropTarget = null;
        this.lastDropPosition = null;
        this.$pasteTarget = $('<div>');
        this.pasting = !1;
        this.copying = !1;
        this.pasteSpecial = !1;
        this.pointerEvents = null;
        this.focusedBlockSlug = null;
        this.focusedNode = null;
        this.activeAnnotations = [];
        this.contexedAnnotations = [];
        this.previousActiveAnnotations = [];
        this.newModelSelection = null;
        this.keyDownState = {
            event: null,
            selectionState: null
        };
        this.cursorDirectionality = null;
        this.unicorningNode = null;
        this.setUnicorningRecursionGuard = !1;
        this.cursorHolders = null;
        this.hasSelectionChangeEvents = 'onselectionchange'in this.getElementDocument();
        this.onPositionDebounced = ve.debounce(this.onPosition.bind(this));
        this.connect(this, {
            position: this.onPositionDebounced
        });
        this.model.connect(this, {
            select: 'onModelSelect',
            documentUpdate: 'onModelDocumentUpdate',
            insertionAnnotationsChange: 'onInsertionAnnotationsChange'
        });
        if (this.model.synchronizer) {
            this.model.synchronizer.connect(this, {
                authorSelect: 'onSynchronizerAuthorUpdate',
                authorChange: 'onSynchronizerAuthorUpdate',
                authorDisconnect: 'onSynchronizerAuthorDisconnect',
                wrongDoc: 'onSynchronizerWrongDoc',
                pause: 'onSynchronizerPause'
            });
        }
        this.onDocumentMouseUpHandler = this.onDocumentMouseUp.bind(this);
        this.$attachedRootNode.on({
            mousedown: this.onDocumentMouseDown.bind(this),
            cut: this.onCut.bind(this),
            copy: this.onCopy.bind(this)
        });
        this.onWindowResizeHandler = ve.debounce(this.onWindowResize.bind(this), 50);
        this.$window.on('resize', this.onWindowResizeHandler);
        this.onDocumentFocusInOutHandler = this.onDocumentFocusInOut.bind(this);
        this.$document.on('focusin focusout', this.onDocumentFocusInOutHandler);
        this.debounceFocusChange = ve.debounce(this.onFocusChange.bind(this));
        this.$document.on('mousedown', this.debounceFocusChange);
        this.$attachedRootNode.on('mouseup', this.debounceFocusChange);
        this.$pasteTarget.add(this.$highlights).on({
            cut: this.onCut.bind(this),
            copy: this.onCopy.bind(this),
            paste: this.onPaste.bind(this)
        });
        this.$attachedRootNode.on('paste', this.onPaste.bind(this)).on('focus', 'a', function() {
            surface.$attachedRootNode[0].focus();
        });
        this.onDocumentSelectionChangeDebounced = ve.debounce(this.onDocumentSelectionChange.bind(this));
        if (this.hasSelectionChangeEvents) {
            this.$document.on('selectionchange', this.onDocumentSelectionChangeDebounced);
        } else {
            this.$attachedRootNode.on('mousemove', function() {
                if (surface.dragging) {
                    surface.onDocumentSelectionChangeDebounced();
                }
            });
            this.eventSequencer.after({
                mousedown: this.onDocumentSelectionChangeDebounced
            });
        }
        this.$element.on({
            dragstart: this.onDocumentDragStart.bind(this),
            dragover: this.onDocumentDragOver.bind(this),
            dragleave: this.onDocumentDragLeave.bind(this),
            drop: this.onDocumentDrop.bind(this)
        });
        this.eventSequencer.on({
            keydown: this.onDocumentKeyDown.bind(this),
            keyup: this.onDocumentKeyUp.bind(this),
            keypress: this.onDocumentKeyPress.bind(this),
            input: this.onDocumentInput.bind(this),
            compositionstart: this.onDocumentCompositionStart.bind(this)
        }).after({
            keydown: this.afterDocumentKeyDown.bind(this)
        });
        this.$element.addClass('ve-ce-surface notranslate');
        this.$highlights.addClass('ve-ce-surface-highlights');
        this.$highlightsFocused.addClass('ve-ce-surface-highlights-focused');
        this.$highlightsBlurred.addClass('ve-ce-surface-highlights-blurred');
        this.$deactivatedSelection.addClass('ve-ce-surface-deactivatedSelection');
        this.$highlightsUserSelections.addClass('ve-ce-surface-highlights-user-selections');
        this.$highlightsUserCursors.addClass('ve-ce-surface-highlights-user-cursors');
        this.$pasteTarget.addClass('ve-ce-surface-paste').prop({
            tabIndex: -1,
            contentEditable: 'true'
        });
        this.$highlights.append(this.$dropMarker);
        this.$element.append(this.$attachedRootNode, this.$pasteTarget);
        this.surface.$blockers.append(this.$highlights);
        this.surface.$selections.append(this.$deactivatedSelection);
    }
    ;
    OO.inheritClass(ve.ce.Surface, OO.ui.Element);
    OO.mixinClass(ve.ce.Surface, OO.EventEmitter);
    ve.ce.Surface.static.unsafeAttributes = ['about', 'content', 'datatype', 'property', 'rel', 'resource', 'rev', 'typeof', 'style'];
    ve.ce.Surface.static.inputTypeCommands = {
        historyUndo: 'undo',
        historyRedo: 'redo',
        formatBold: 'bold',
        formatItalic: 'italic',
        formatUnderline: 'underline',
        formatStrikeThrough: 'strikethrough',
        formatSuperscript: 'superscript',
        formatSubscript: 'subscript',
        formatJustifyFull: null,
        formatJustifyCenter: null,
        formatJustifyRight: null,
        formatJustifyLeft: null,
        formatIndent: 'indent',
        formatOutdent: 'outdent',
        formatRemove: 'clear',
        formatSetBlockTextDirection: null,
        formatSetInlineTextDirection: null,
        formatBackColor: null,
        formatFontColor: null,
        formatFontName: null
    };
    ve.ce.Surface.static.cursorHolderTemplate = $('<div>').addClass('ve-ce-cursorHolder').prop('contentEditable', 'true').append($('<img>').addClass('ve-ce-cursorHolder-img').attr({
        role: 'none',
        alt: ''
    })).get(0);
    ve.ce.Surface.static.getClipboardHash = function($elements, beforePasteData) {
        beforePasteData = beforePasteData || {};
        return $elements.text().slice(beforePasteData.leftText ? beforePasteData.leftText.length : 0, beforePasteData.rightText ? -beforePasteData.rightText.length : undefined).replace(/\s/gm, '');
    }
    ;
    ve.ce.Surface.prototype.destroy = function() {
        var attachedRoot = this.attachedRoot;
        if (this.isFocused()) {
            this.blur();
        }
        this.surfaceObserver.stopTimerLoop();
        this.surfaceObserver.detach();
        this.eventSequencer.detach();
        attachedRoot.setLive(false);
        this.model.disconnect(this);
        this.$document.off('focusin focusout', this.onDocumentFocusInOutHandler);
        this.$document.off('mousedown', this.debounceFocusChange);
        if (this.hasSelectionChangeEvents) {
            this.$document.off('selectionchange', this.onDocumentSelectionChangeDebounced);
        }
        if (this.model.synchronizer) {
            this.model.synchronizer.destroy();
            this.model.synchronizer.disconnect(this);
        }
        this.$window.off('resize', this.onWindowResizeHandler);
        this.$element.remove();
        this.$highlights.remove();
    }
    ;
    ve.ce.Surface.prototype.getOffsetFromEventCoords = function(e) {
        return this.getOffsetFromCoords(e.pageX - this.$document.scrollLeft(), e.pageY - this.$document.scrollTop());
    }
    ;
    ve.ce.Surface.prototype.getOffsetFromCoords = function(x, y) {
        var offset, caretPosition, range, textRange, $marker, doc = this.getElementDocument();
        try {
            if (doc.caretPositionFromPoint) {
                caretPosition = document.caretPositionFromPoint(x, y);
                offset = ve.ce.getOffset(caretPosition.offsetNode, caretPosition.offset);
            } else if (doc.caretRangeFromPoint) {
                range = document.caretRangeFromPoint(x, y);
                offset = ve.ce.getOffset(range.startContainer, range.startOffset);
            } else if (document.body.createTextRange) {
                textRange = document.body.createTextRange();
                textRange.moveToPoint(x, y);
                textRange.pasteHTML('<span class="ve-ce-textRange-drop-marker">&nbsp;</span>');
                $marker = $('.ve-ce-textRange-drop-marker');
                offset = ve.ce.getOffset($marker.get(0), 0);
                $marker.remove();
            }
            return offset;
        } catch (e) {
            return -1;
        }
    }
    ;
    ve.ce.Surface.prototype.getSelection = function(selection) {
        if (selection) {
            return ve.ce.Selection.static.newFromModel(selection, this);
        } else if (!this.selection) {
            this.selection = ve.ce.Selection.static.newFromModel(this.getModel().getSelection(), this);
        }
        return this.selection;
    }
    ;
    ve.ce.Surface.prototype.getSelectionDirectionality = function() {
        return this.getSelection().getDirectionality(this.getDocument());
    }
    ;
    ve.ce.Surface.prototype.initialize = function() {
        this.attachedRoot.setLive(true);
        if ($.client.profile().layout === 'gecko') {
            try {
                this.$document[0].execCommand('enableObjectResizing', false, false);
                this.$document[0].execCommand('enableInlineTableEditing', false, false);
            } catch (e) {}
        }
    }
    ;
    ve.ce.Surface.prototype.setReadOnly = function(readOnly) {
        this.readOnly = !!readOnly;
        this.$element.toggleClass('ve-ce-surface-readOnly', this.readOnly);
        this.$element.toggleClass('ve-ce-surface-enabled', !this.readOnly);
    }
    ;
    ve.ce.Surface.prototype.isReadOnly = function() {
        return this.readOnly;
    }
    ;
    ve.ce.Surface.prototype.focus = function() {
        var node, surface = this, selection = this.getSelection();
        if (!this.attachedRoot.isLive()) {
            OO.ui.warnDeprecation('Tried to focus an un-initialized surface view. Wait for the ve.ui.Surface `ready` event to fire.');
            return;
        }
        if (selection.getModel().isNull()) {
            this.getModel().selectFirstContentOffset();
            selection = this.getSelection();
        }
        if (selection.isFocusedNode()) {
            this.$pasteTarget[0].focus();
        } else if (selection.isNativeCursor()) {
            node = this.getDocument().getNodeAndOffset(selection.getModel().getRange().start).node;
            $(node).closest('[contenteditable=true]')[0].focus();
        }
        this.onModelSelect();
        setTimeout(function() {
            if (!surface.isFocused()) {
                surface.getModel().selectFirstContentOffset();
            }
        });
    }
    ;
    ve.ce.Surface.prototype.blur = function() {
        if (this.deactivated) {
            this.getModel().setNullSelection();
            this.activate();
        }
        this.removeRangesAndBlur();
        this.onFocusChange();
        if (OO.ui.isMobile()) {
            this.updateActiveAnnotations();
            this.contexedAnnotations = [];
        }
    }
    ;
    ve.ce.Surface.prototype.removeRangesAndBlur = function() {
        this.nativeSelection.removeAllRanges();
        if (this.getElementDocument().activeElement) {
            this.getElementDocument().activeElement.blur();
        }
    }
    ;
    ve.ce.Surface.prototype.onDocumentFocusInOut = function(e) {
        if (e.target.nodeName.toLowerCase() === 'iframe') {
            return;
        }
        this.debounceFocusChange();
    }
    ;
    ve.ce.Surface.prototype.onFocusChange = function() {
        var hasFocus = !1;
        hasFocus = OO.ui.contains([this.$attachedRootNode[0], this.$pasteTarget[0], this.$highlights[0]], this.nativeSelection.anchorNode, true);
        if (this.deactivated) {
            if (OO.ui.contains(this.$attachedRootNode[0], this.nativeSelection.anchorNode, true)) {
                this.onDocumentFocus();
            }
        } else {
            if (hasFocus && !this.isFocused()) {
                this.onDocumentFocus();
            }
            if (!hasFocus && this.isFocused()) {
                this.onDocumentBlur();
            }
        }
    }
    ;
    ve.ce.Surface.prototype.isDeactivated = function() {
        return this.deactivated;
    }
    ;
    ve.ce.Surface.prototype.isShownAsDeactivated = function() {
        return this.deactivated && !this.showAsActivated;
    }
    ;
    ve.ce.Surface.prototype.deactivate = function(showAsActivated, noSelectionChange, hideSelection) {
        this.showAsActivated = showAsActivated === undefined || !!showAsActivated;
        this.hideSelection = hideSelection;
        if (!this.deactivated) {
            this.surfaceObserver.disable();
            this.deactivated = !0;
            this.previousActiveAnnotations = this.activeAnnotations;
            this.checkDelayedSequences();
            this.$element.addClass('ve-ce-surface-deactivated');
            if (!noSelectionChange) {
                this.removeRangesAndBlur();
            }
            this.updateDeactivatedSelection();
            this.clearKeyDownState();
            this.emit('activation');
        }
    }
    ;
    ve.ce.Surface.prototype.activate = function() {
        var previousSelection, newSelection, annotationClasses;
        if (this.deactivated) {
            this.deactivated = !1;
            this.showAsActivated = !1;
            this.hideSelection = !1;
            this.updateDeactivatedSelection();
            this.surfaceObserver.enable();
            this.$element.removeClass('ve-ce-surface-deactivated');
            if (OO.ui.isMobile()) {
                this.model.emit('contextChange');
            }
            previousSelection = this.getModel().getSelection();
            if (OO.ui.contains(this.$attachedRootNode[0], this.nativeSelection.anchorNode, true)) {
                this.surfaceObserver.clear();
                this.surfaceObserver.pollOnce();
            } else {
                this.focusedNode = null;
                this.onModelSelect();
            }
            newSelection = this.getModel().getSelection();
            if (previousSelection.getCoveringRange() && newSelection.getCoveringRange() && previousSelection.getCoveringRange().containsRange(newSelection.getCoveringRange())) {
                this.getModel().setSelection(previousSelection);
                if (this.previousActiveAnnotations.length) {
                    annotationClasses = this.previousActiveAnnotations.map(function(ann) {
                        return ann.constructor;
                    });
                    this.selectAnnotation(function(view) {
                        return ve.isInstanceOfAny(view, annotationClasses);
                    });
                }
            }
            this.emit('activation');
        }
    }
    ;
    ve.ce.Surface.prototype.updateDeactivatedSelection = function() {
        var rects, textColor, currentNode, surface = this, selection = this.getSelection(), isCollapsed = selection.getModel().isCollapsed();
        this.$deactivatedSelection.empty();
        if (this.deactivated && selection.isNativeCursor() && !this.hideSelection) {
            if (isCollapsed) {
                currentNode = this.getDocument().getBranchNodeFromOffset(selection.getModel().getCoveringRange().start);
                if (currentNode) {
                    textColor = currentNode.$element.css('color');
                }
            }
            rects = selection.getSelectionRects();
            if (rects) {
                rects.forEach(function(rect) {
                    var $rect = $('<div>').css({
                        top: rect.top,
                        left: rect.left,
                        width: Math.max(rect.width, 1),
                        height: rect.height
                    });
                    if (textColor) {
                        $rect.css('background-color', textColor);
                    }
                    surface.$deactivatedSelection.append($rect);
                });
                this.$deactivatedSelection.toggleClass('ve-ce-surface-deactivatedSelection-showAsDeactivated', this.isShownAsDeactivated()).toggleClass('ve-ce-surface-deactivatedSelection-collapsed', isCollapsed);
            }
        }
    }
    ;
    ve.ce.Surface.prototype.onDocumentFocus = function() {
        if (this.getModel().getSelection().isNull()) {
            this.getModel().selectFirstContentOffset();
        }
        this.eventSequencer.attach(this.$element);
        this.surfaceObserver.startTimerLoop();
        this.focused = !0;
        this.activate();
        this.$element.addClass('ve-ce-surface-focused');
        this.emit('focus');
    }
    ;
    ve.ce.Surface.prototype.onDocumentBlur = function() {
        var nullSelectionOnBlur = this.surface.nullSelectionOnBlur;
        if (!nullSelectionOnBlur) {
            this.deactivate(false, true);
        }
        this.eventSequencer.detach();
        this.surfaceObserver.stopTimerLoop();
        this.surfaceObserver.pollOnce();
        this.surfaceObserver.clear();
        this.onDocumentSelectionChange();
        this.setDragging(false);
        this.focused = !1;
        if (nullSelectionOnBlur) {
            if (this.focusedNode) {
                this.focusedNode.setFocused(false);
                this.focusedNode = null;
            }
            this.getModel().setNullSelection();
        }
        this.$element.removeClass('ve-ce-surface-focused');
        this.emit('blur');
    }
    ;
    ve.ce.Surface.prototype.isFocused = function() {
        return this.focused;
    }
    ;
    ve.ce.Surface.prototype.onDocumentMouseDown = function(e) {
        var newFragment, contexedAnnotations, offset, node, surface = this;
        if (e.which !== OO.ui.MouseButtons.LEFT) {
            if (e.which === OO.ui.MouseButtons.MIDDLE) {
                this.middleClickSelection = this.getModel().getSelection();
                this.$document.one('mouseup', function() {
                    setTimeout(function() {
                        surface.middleClickSelection = null;
                    });
                });
            }
            return;
        }
        function isContexedNode(view) {
            return surface.surface.context.getRelatedSourcesFromModels([view.model]).length;
        }
        offset = this.getOffsetFromEventCoords(e);
        if (offset !== -1) {
            contexedAnnotations = this.annotationsAtNode(e.target, isContexedNode);
            if (contexedAnnotations.length) {
                node = e.target;
            } else {
                contexedAnnotations = this.annotationsAtModelSelection(isContexedNode, offset);
            }
            if (OO.ui.isMobile()) {
                if (contexedAnnotations.length && (this.focusedNode || !(this.contexedAnnotations.length === contexedAnnotations.length && this.contexedAnnotations.every(function(ann, i) {
                    return ann === contexedAnnotations[i];
                })))) {
                    setTimeout(function() {
                        surface.getModel().setLinearSelection(new ve.Range(offset));
                        surface.activate();
                        surface.deactivate(false, false, true);
                        surface.updateActiveAnnotations(node || true);
                    });
                    this.contexedAnnotations = contexedAnnotations;
                    e.preventDefault();
                    return;
                }
            }
            this.contexedAnnotations = contexedAnnotations;
        }
        this.setDragging(true);
        this.$document.on('mouseup', this.onDocumentMouseUpHandler);
        this.surfaceObserver.stopTimerLoop();
        setTimeout(this.afterDocumentMouseDown.bind(this, e, this.getSelection()));
        if (e.originalEvent.detail >= 3 && !ve.init.platform.constructor.static.isInternetExplorer()) {
            e.preventDefault();
            newFragment = this.getModel().getFragment().collapseToStart().expandLinearSelection('closest', ve.dm.ContentBranchNode).adjustLinearSelection(1, -1);
            if (!newFragment.isNull()) {
                newFragment.select();
            }
        }
    }
    ;
    ve.ce.Surface.prototype.afterDocumentMouseDown = function(e, selectionBefore) {
        var scrollTop, view = this;
        this.surfaceObserver.pollOnce();
        if (e.shiftKey) {
            this.fixShiftClickSelect(selectionBefore);
        }
        function blockScroll() {
            view.$window.scrollTop(scrollTop);
        }
        if (OO.ui.isMobile() && $.client.profile().layout === 'gecko') {
            scrollTop = this.$window.scrollTop();
            view.$window.on('scroll', blockScroll);
            setTimeout(function() {
                view.$window.off('scroll', blockScroll);
            }, 1000);
        }
    }
    ;
    ve.ce.Surface.prototype.onDocumentMouseUp = function(e) {
        this.$document.off('mouseup', this.onDocumentMouseUpHandler);
        this.surfaceObserver.startTimerLoop();
        setTimeout(this.afterDocumentMouseUp.bind(this, e, this.getSelection()));
    }
    ;
    ve.ce.Surface.prototype.afterDocumentMouseUp = function(e, selectionBefore) {
        this.surfaceObserver.pollOnce();
        if (e.shiftKey) {
            this.fixShiftClickSelect(selectionBefore);
        }
        this.setDragging(false);
    }
    ;
    ve.ce.Surface.prototype.fixShiftClickSelect = function(selectionBefore) {
        var newSelection;
        if (!selectionBefore.isNativeCursor()) {
            return;
        }
        newSelection = this.getSelection();
        if (newSelection.getModel().isCollapsed() && !newSelection.equals(selectionBefore)) {
            this.getModel().setLinearSelection(new ve.Range(selectionBefore.getModel().getRange().from,newSelection.getModel().getRange().to));
        }
    }
    ;
    ve.ce.Surface.prototype.setDragging = function(dragging) {
        this.dragging = !!dragging;
        this.$element.toggleClass('ve-ce-surface-dragging', this.dragging);
    }
    ;
    ve.ce.Surface.prototype.onDocumentSelectionChange = function() {
        if (!this.focused || this.deactivated) {
            return;
        }
        this.fixupCursorPosition(0, this.dragging);
        this.updateActiveAnnotations();
        this.surfaceObserver.pollOnceSelection();
    }
    ;
    ve.ce.Surface.prototype.onDocumentDragStart = function(e) {
        this.onCopy(e);
        this.startRelocation();
    }
    ;
    ve.ce.Surface.prototype.onDocumentDragOver = function(e) {
        var i, l, $target, $dropTarget, node, dropPosition, targetPosition, targetOffset, top, left, nodeType, item, fakeItem, dataTransferHandlerFactory = this.getSurface().dataTransferHandlerFactory, isContent = !0, dataTransfer = e.originalEvent.dataTransfer;
        if (this.readOnly) {
            return;
        }
        if (this.relocatingNode) {
            isContent = this.relocatingNode.isContent();
            nodeType = this.relocatingNode.getType();
        } else {
            if (this.allowedFile === null) {
                this.allowedFile = !1;
                if (dataTransfer.items) {
                    for (i = 0,
                    l = dataTransfer.items.length; i < l; i++) {
                        item = dataTransfer.items[i];
                        if (item.kind !== 'string') {
                            fakeItem = new ve.ui.DataTransferItem(item.kind,item.type);
                            if (dataTransferHandlerFactory.getHandlerNameForItem(fakeItem)) {
                                this.allowedFile = !0;
                                break;
                            }
                        }
                    }
                } else if (dataTransfer.files) {
                    for (i = 0,
                    l = dataTransfer.files.length; i < l; i++) {
                        item = dataTransfer.items[i];
                        fakeItem = new ve.ui.DataTransferItem(item.kind,item.type);
                        if (dataTransferHandlerFactory.getHandlerNameForItem(fakeItem)) {
                            this.allowedFile = !0;
                            break;
                        }
                    }
                } else if (Array.prototype.indexOf.call(dataTransfer.types || [], 'Files') !== -1) {
                    this.allowedFile = !0;
                }
            }
            if (this.allowedFile) {
                isContent = !1;
                nodeType = 'alienBlock';
            }
        }
        function getNearestDropTarget(node) {
            while (node.parent && !node.parent.isAllowedChildNodeType(nodeType)) {
                node = node.parent;
            }
            if (node.parent) {
                node.parent.traverseUpstream(function(n) {
                    if (n.shouldIgnoreChildren()) {
                        node = null;
                        return false;
                    }
                });
                return node;
            }
        }
        if (!isContent) {
            e.preventDefault();
            $target = $(e.target).closest('.ve-ce-branchNode, .ve-ce-leafNode');
            if ($target.length) {
                node = getNearestDropTarget($target.data('view'));
                if (node) {
                    $dropTarget = node.$element;
                    dropPosition = e.originalEvent.pageY - $dropTarget.offset().top > $dropTarget.outerHeight() / 2 ? 'bottom' : 'top';
                } else {
                    targetOffset = this.getOffsetFromEventCoords(e.originalEvent);
                    if (targetOffset !== -1) {
                        node = getNearestDropTarget(this.getDocument().getBranchNodeFromOffset(targetOffset));
                        if (node) {
                            $dropTarget = node.$element;
                            dropPosition = 'top';
                        }
                    }
                    if (!$dropTarget) {
                        $dropTarget = this.$lastDropTarget;
                        dropPosition = this.lastDropPosition;
                    }
                }
            }
            if (this.$lastDropTarget && (!this.$lastDropTarget.is($dropTarget) || dropPosition !== this.lastDropPosition)) {
                this.$dropMarker.addClass('oo-ui-element-hidden');
                $dropTarget = null;
            }
            if ($dropTarget && (!$dropTarget.is(this.$lastDropTarget) || dropPosition !== this.lastDropPosition)) {
                targetPosition = $dropTarget.position();
                top = targetPosition.top + parseFloat($dropTarget.css('margin-top'));
                left = targetPosition.left + parseFloat($dropTarget.css('margin-left'));
                if (dropPosition === 'bottom') {
                    top += $dropTarget.outerHeight();
                }
                this.$dropMarker.css({
                    top: top,
                    left: left
                }).width($dropTarget.outerWidth()).removeClass('oo-ui-element-hidden');
            }
            if ($dropTarget !== undefined) {
                this.$lastDropTarget = $dropTarget;
                this.lastDropPosition = dropPosition;
            }
        }
    }
    ;
    ve.ce.Surface.prototype.onDocumentDragLeave = function() {
        this.allowedFile = null;
        if (this.$lastDropTarget) {
            this.$dropMarker.addClass('oo-ui-element-hidden');
            this.$lastDropTarget = null;
            this.lastDropPosition = null;
        }
    }
    ;
    ve.ce.Surface.prototype.onDocumentDrop = function(e) {
        var originFragment, originData, targetRange, targetOffset, targetFragment, targetViewNode, isMultiline, slice, linearData, surfaceModel = this.getModel(), dataTransfer = e.originalEvent.dataTransfer, $dropTarget = this.$lastDropTarget, dropPosition = this.lastDropPosition, platformKey = ve.getSystemPlatform() === 'mac' ? 'mac' : 'pc';
        e.preventDefault();
        if (this.readOnly) {
            return;
        }
        if ($dropTarget) {
            if ($dropTarget) {
                targetRange = $dropTarget.data('view').getModel().getOuterRange();
                if (dropPosition === 'top') {
                    targetOffset = targetRange.start;
                } else {
                    targetOffset = targetRange.end;
                }
            } else {
                return;
            }
        } else {
            targetOffset = this.getOffsetFromEventCoords(e.originalEvent);
            if (targetOffset === -1) {
                return;
            }
        }
        targetFragment = surfaceModel.getLinearFragment(new ve.Range(targetOffset));
        targetViewNode = this.getDocument().getBranchNodeFromOffset(targetFragment.getSelection().getCoveringRange().from);
        isMultiline = targetViewNode.isMultiline();
        if (this.relocatingSelection) {
            originFragment = surfaceModel.getFragment(this.relocatingSelection);
            if (!isMultiline) {
                slice = this.model.documentModel.shallowCloneFromRange(originFragment.getSelection().getCoveringRange());
                linearData = new ve.dm.ElementLinearData(originFragment.getDocument().getStore(),slice.getBalancedData());
                linearData.sanitize({
                    singleLine: !0
                });
                originData = linearData.data;
                if (originData[0].type && ve.dm.nodeFactory.canNodeContainContent(originData[0].type)) {
                    originData = originData.slice(1, originData.length - 1);
                }
            } else {
                originData = originFragment.getData();
            }
            surfaceModel.pushStaging();
            if ((platformKey === 'pc' && !e.ctrlKey) || (platformKey === 'mac' && !e.altKey)) {
                originFragment.removeContent();
            }
            try {
                targetFragment.insertContent(originData);
                surfaceModel.applyStaging();
            } catch (error) {
                surfaceModel.popStaging();
            }
        } else {
            if (isMultiline) {
                this.handleDataTransfer(dataTransfer, false, targetFragment);
            }
        }
        this.endRelocation();
    }
    ;
    ve.ce.Surface.prototype.onDocumentKeyDown = function(e) {
        var trigger, executed, selection = this.getModel().getSelection(), updateFromModel = !1;
        if (selection.isNull()) {
            return;
        }
        if (e.which === 229) {
            return;
        }
        this.surfaceObserver.stopTimerLoop();
        this.incRenderLock();
        try {
            this.surfaceObserver.pollOnce();
        } finally {
            this.decRenderLock();
        }
        this.storeKeyDownState(e);
        if (ve.ce.keyDownHandlerFactory.executeHandlersForKey(e.keyCode, selection.getName(), this, e)) {
            updateFromModel = !0;
        } else {
            trigger = new ve.ui.Trigger(e);
            if (trigger.isComplete()) {
                executed = this.surface.execute(trigger);
                if (executed || this.isBlockedTrigger(trigger)) {
                    e.preventDefault();
                    e.stopPropagation();
                    updateFromModel = !0;
                }
            }
        }
        if (this.readOnly && !(ve.ce.LinearArrowKeyDownHandler.static.keys.indexOf(e.keyCode) !== -1 || (e.keyCode >= 112 && e.keyCode <= 123) || e.metaKey || e.ctrlKey || e.altKey)) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        if (!updateFromModel) {
            this.incRenderLock();
        }
        try {
            this.surfaceObserver.pollOnce();
        } finally {
            if (!updateFromModel) {
                this.decRenderLock();
            }
        }
        this.surfaceObserver.startTimerLoop();
    }
    ;
    ve.ce.Surface.prototype.isBlockedTrigger = function(trigger) {
        var platformKey = ve.getSystemPlatform() === 'mac' ? 'mac' : 'pc'
          , blocked = {
            mac: ['cmd+b', 'cmd+i', 'cmd+u', 'cmd+z', 'cmd+y', 'cmd+shift+z', 'tab', 'shift+tab', 'cmd+[', 'cmd+]'],
            pc: ['ctrl+b', 'ctrl+i', 'ctrl+u', 'ctrl+z', 'ctrl+y', 'ctrl+shift+z', 'tab', 'shift+tab']
        };
        return blocked[platformKey].indexOf(trigger.toString()) !== -1;
    }
    ;
    ve.ce.Surface.prototype.onDocumentKeyPress = function(e) {
        var selection;
        if (e.keyCode === OO.ui.Keys.ENTER && !this.keyDownState.event && !((selection = this.getModel().getSelection()).isNull())) {
            this.surfaceObserver.stopTimerLoop();
            if (ve.ce.keyDownHandlerFactory.executeHandlersForKey(e.keyCode, selection.getName(), this, e)) {
                this.surfaceObserver.pollOnce();
            }
            this.surfaceObserver.startTimerLoop();
            return;
        }
        if (e.which === 0 || e.charCode === 0 || e.keyCode === OO.ui.Keys.TAB || e.keyCode === OO.ui.Keys.ESCAPE || ve.ce.isShortcutKey(e)) {
            return;
        }
        this.handleInsertion();
    }
    ;
    ve.ce.Surface.prototype.afterDocumentKeyDown = function(e) {
        var keyDownSelectionState, direction, focusableNode, captionNode, startOffset, endOffset, offsetDiff, dmFocus, dmSelection, inNonSlug, ceSelection, ceNode, range, fixupCursorForUnicorn, matrix, col, row, $focusNode, removedUnicorns, tableNode, surface = this, documentModel = this.getModel().getDocument(), isArrow = (e.keyCode === OO.ui.Keys.UP || e.keyCode === OO.ui.Keys.DOWN || e.keyCode === OO.ui.Keys.LEFT || e.keyCode === OO.ui.Keys.RIGHT);
        function getSurroundingFocusableNode(node, offset, direction) {
            var focusNode;
            if (node.nodeType === Node.TEXT_NODE) {
                focusNode = node;
            } else if (direction > 0 && offset < node.childNodes.length) {
                focusNode = node.childNodes[offset];
            } else if (direction < 0 && offset > 0) {
                focusNode = node.childNodes[offset - 1];
            } else {
                focusNode = node;
            }
            if (ve.isContentEditable(focusNode)) {
                return null;
            }
            return $(focusNode).closest('.ve-ce-focusableNode, .ve-ce-tableNode').data('view') || null;
        }
        function getDirection() {
            return (isArrow && keyDownSelectionState && ve.compareDocumentOrder(surface.nativeSelection.focusNode, surface.nativeSelection.focusOffset, keyDownSelectionState.focusNode, keyDownSelectionState.focusOffset)) || null;
        }
        if (e !== this.keyDownState.event) {
            return;
        }
        keyDownSelectionState = this.keyDownState.selectionState;
        this.clearKeyDownState();
        if ((e.keyCode === OO.ui.Keys.BACKSPACE || e.keyCode === OO.ui.Keys.DELETE) && this.nativeSelection.focusNode) {
            inNonSlug = this.nativeSelection.focusNode.nodeType === Node.ELEMENT_NODE && !this.nativeSelection.focusNode.classList.contains('ve-ce-branchNode-inlineSlug');
            if (inNonSlug) {
                this.incRenderLock();
                try {
                    this.surfaceObserver.pollOnce();
                } finally {
                    this.decRenderLock();
                }
                dmSelection = surface.model.getSelection();
                if (dmSelection instanceof ve.dm.LinearSelection) {
                    dmFocus = dmSelection.getRange().end;
                    ceNode = this.documentView.getBranchNodeFromOffset(dmFocus);
                    if (ceNode && ceNode.getModel().hasSlugAtOffset(dmFocus)) {
                        ceNode.setupBlockSlugs();
                    }
                }
            }
            ceSelection = new ve.SelectionState(this.nativeSelection);
            this.nativeSelection.removeAllRanges();
            this.showSelectionState(ceSelection);
            if (inNonSlug) {
                return;
            }
        }
        if (isArrow && !(surface.model.getSelection()instanceof ve.dm.LinearSelection)) {
            return;
        }
        if (isArrow && this.restoreActiveNodeSelection()) {
            return;
        }
        $focusNode = $(this.nativeSelection.focusNode);
        if ($focusNode.hasClass('ve-ce-cursorHolder')) {
            if ($focusNode.hasClass('ve-ce-cursorHolder-after')) {
                direction = -1;
                focusableNode = $focusNode.prev().data('view');
            } else {
                direction = 1;
                focusableNode = $focusNode.next().data('view');
            }
            this.removeCursorHolders();
        } else if (isArrow && !e.ctrlKey && !e.altKey && !e.metaKey && keyDownSelectionState && keyDownSelectionState.isCollapsed && this.nativeSelection.isCollapsed && (direction = getDirection()) !== null) {
            focusableNode = getSurroundingFocusableNode(this.nativeSelection.focusNode, this.nativeSelection.focusOffset, direction);
            if (!focusableNode) {
                try {
                    startOffset = ve.ce.getOffset(keyDownSelectionState.focusNode, keyDownSelectionState.focusOffset);
                    endOffset = ve.ce.getOffset(this.nativeSelection.focusNode, this.nativeSelection.focusOffset);
                    offsetDiff = endOffset - startOffset;
                } catch (ex) {
                    startOffset = endOffset = offsetDiff = undefined;
                }
                if (Math.abs(offsetDiff) === 2) {
                    focusableNode = documentModel.documentNode.getNodeFromOffset((startOffset + endOffset) / 2);
                    if (focusableNode.isFocusable()) {
                        range = new ve.Range(startOffset,endOffset);
                    } else {
                        focusableNode = undefined;
                    }
                }
            }
        }
        if (isArrow && direction > 0 && this.getActiveNode()instanceof ve.ce.TableCaptionNode && this.getActiveNode() !== $focusNode.closest('.ve-ce-tableCaptionNode').data('view')) {
            tableNode = this.getActiveNode().getParent();
            this.model.setSelection(new ve.dm.TableSelection(tableNode.getOuterRange(),0,0));
        }
        if (focusableNode) {
            if (!range) {
                range = focusableNode.getOuterRange();
                if (direction < 0) {
                    range = range.flip();
                }
            }
            if (focusableNode instanceof ve.ce.TableNode) {
                if (direction > 0) {
                    if ((captionNode = focusableNode.getModel().getCaptionNode())) {
                        this.model.setLinearSelection(documentModel.getRelativeRange(new ve.Range(captionNode.getRange().start), 1));
                    } else {
                        this.model.setSelection(new ve.dm.TableSelection(range,0,0));
                    }
                } else {
                    matrix = focusableNode.getModel().getMatrix();
                    row = matrix.getRowCount() - 1;
                    col = matrix.getColCount(row) - 1;
                    this.model.setSelection(new ve.dm.TableSelection(range,col,row));
                }
            } else {
                this.model.setLinearSelection(range);
            }
            if (e.keyCode === OO.ui.Keys.LEFT) {
                this.cursorDirectionality = direction > 0 ? 'rtl' : 'ltr';
            } else if (e.keyCode === OO.ui.Keys.RIGHT) {
                this.cursorDirectionality = direction < 0 ? 'rtl' : 'ltr';
            }
        }
        if (direction === undefined) {
            direction = getDirection();
        }
        fixupCursorForUnicorn = (!e.shiftKey && (e.keyCode === OO.ui.Keys.LEFT || e.keyCode === OO.ui.Keys.RIGHT));
        removedUnicorns = this.cleanupUnicorns(fixupCursorForUnicorn);
        if (removedUnicorns) {
            this.surfaceObserver.pollOnceNoCallback();
        } else {
            this.incRenderLock();
            try {
                this.surfaceObserver.pollOnce();
            } finally {
                this.decRenderLock();
            }
        }
        this.fixupCursorPosition(direction, e.shiftKey);
    }
    ;
    ve.ce.Surface.prototype.cleanupUnicorns = function(fixupCursor) {
        var preUnicorn, range, node, fixup, veRange, contentBranchNodeBefore, contentBranchNodeAfter;
        if (!this.unicorningNode || !this.unicorningNode.unicorns) {
            return false;
        }
        preUnicorn = this.unicorningNode.unicorns[0];
        if (!this.$attachedRootNode[0].contains(preUnicorn)) {
            return false;
        }
        if (this.nativeSelection.rangeCount === 0) {
            return false;
        }
        range = this.nativeSelection.getRangeAt(0);
        node = range.endContainer;
        if (node.nodeType === Node.ELEMENT_NODE) {
            node = range.endOffset > 0 ? node.childNodes[range.endOffset - 1] : null;
        }
        while (node !== null && node.nodeType === Node.TEXT_NODE) {
            node = node.previousSibling;
        }
        if (node === preUnicorn) {
            return false;
        }
        if (ve.compareDocumentOrder(range.endContainer, range.endOffset, preUnicorn.parentNode, ve.parentIndex(preUnicorn)) <= 0) {
            fixup = -1;
        } else {
            fixup = 1;
        }
        contentBranchNodeBefore = this.getSelectedContentBranchNode();
        if (this.unicorningNode !== contentBranchNodeBefore) {
            this.setNotUnicorningAll();
            return true;
        }
        veRange = ve.ce.veRangeFromSelection(this.nativeSelection);
        if (veRange) {
            this.incRenderLock();
            try {
                this.changeModel(null, new ve.dm.LinearSelection(veRange));
                if (fixupCursor) {
                    this.moveModelCursor(fixup);
                }
            } finally {
                this.decRenderLock();
            }
        }
        contentBranchNodeAfter = this.getSelectedContentBranchNode();
        if (contentBranchNodeAfter) {
            contentBranchNodeAfter.renderContents();
        }
        if (contentBranchNodeBefore && contentBranchNodeBefore !== contentBranchNodeAfter) {
            contentBranchNodeBefore.renderContents();
        }
        this.showModelSelection();
        return true;
    }
    ;
    ve.ce.Surface.prototype.onDocumentKeyUp = function() {
        this.emit('keyup');
    }
    ;
    ve.ce.Surface.prototype.onCut = function(e) {
        var surface = this
          , selection = this.getModel().getSelection();
        if (selection.isCollapsed()) {
            return;
        }
        this.onCopy(e);
        setTimeout(function() {
            ve.ce.keyDownHandlerFactory.executeHandlersForKey(OO.ui.Keys.BACKSPACE, selection.getName(), surface, e);
        });
    }
    ;
    ve.ce.Surface.prototype.onCopy = function(e, selection) {
        var originalSelection, clipboardKey, scrollTop, unsafeSelector, slice, isClipboard = e.type === 'copy' || e.type === 'cut', view = this, htmlDoc = this.getModel().getDocument().getHtmlDocument(), clipboardData = isClipboard ? e.originalEvent.clipboardData : e.originalEvent.dataTransfer;
        selection = selection || this.getModel().getSelection();
        this.$pasteTarget.empty();
        if (selection.isCollapsed()) {
            return;
        }
        slice = this.model.documentModel.shallowCloneFromSelection(selection);
        slice.data.cloneElements(true);
        ve.dm.converter.getDomSubtreeFromModel(slice, this.$pasteTarget[0], ve.dm.Converter.static.CLIPBOARD_MODE);
        this.$pasteTarget.find('span').addClass('ve-pasteProtect');
        if (this.$pasteTarget.text() === '') {
            this.$pasteTarget.find('*:not( :has( * ) )').html('&nbsp;');
        }
        ve.resolveAttributes(this.$pasteTarget[0], htmlDoc, ve.dm.Converter.static.computedAttributes);
        unsafeSelector = '[' + ve.ce.Surface.static.unsafeAttributes.join('],[') + ']';
        this.$pasteTarget.find(unsafeSelector).each(function() {
            var i, val, attrs = {}, ua = ve.ce.Surface.static.unsafeAttributes;
            i = ua.length;
            while (i--) {
                val = this.getAttribute(ua[i]);
                if (val !== null) {
                    attrs[ua[i]] = val;
                }
            }
            this.setAttribute('data-ve-attributes', JSON.stringify(attrs));
        });
        this.clipboardIndex++;
        clipboardKey = this.clipboardId + '-' + this.clipboardIndex;
        this.clipboard = {
            slice: slice,
            hash: null
        };
        if (isClipboard && !ve.isClipboardDataFormatsSupported(e)) {
            this.$pasteTarget.prepend($('<span>').attr('data-ve-clipboard-key', clipboardKey).html('&nbsp;'));
            this.clipboard.hash = this.constructor.static.getClipboardHash(this.$pasteTarget.contents());
        }
        if (clipboardData && !ve.init.platform.constructor.static.isEdge()) {
            if (isClipboard) {
                e.preventDefault();
            }
            if (isClipboard && ve.isClipboardDataFormatsSupported(e, true)) {
                clipboardData.setData('text/xcustom', clipboardKey);
            }
            try {
                clipboardData.setData('text/html', this.$pasteTarget.html());
                clipboardData.setData('text/plain', this.$pasteTarget[0].innerText || this.$pasteTarget.text() || ' ');
            } catch (err) {}
        } else {
            if (this.getSelection().isNativeCursor()) {
                originalSelection = new ve.SelectionState(this.nativeSelection);
                scrollTop = this.$window.scrollTop();
                this.surfaceObserver.disable();
                ve.selectElement(this.$pasteTarget[0]);
                this.$window.scrollTop(scrollTop);
                setTimeout(function() {
                    if (!OO.ui.contains(view.$highlights[0], originalSelection.focusNode, true)) {
                        view.$attachedRootNode[0].focus();
                        view.showSelectionState(originalSelection);
                        view.$window.scrollTop(scrollTop);
                    }
                    view.surfaceObserver.clear();
                    view.surfaceObserver.enable();
                });
            } else {
                ve.selectElement(this.$pasteTarget[0]);
            }
        }
        ve.track('activity.clipboard', {
            action: e.type
        });
    }
    ;
    ve.ce.Surface.prototype.onPaste = function(e) {
        var surface = this;
        if (this.pasting || this.readOnly) {
            return false;
        }
        this.beforePaste(e);
        this.surfaceObserver.disable();
        this.pasting = !0;
        setTimeout(function() {
            var afterPastePromise = ve.createDeferred().resolve().promise();
            try {
                if (!e.isDefaultPrevented()) {
                    afterPastePromise = surface.afterPaste(e);
                }
            } finally {
                afterPastePromise.always(function() {
                    surface.surfaceObserver.clear();
                    surface.surfaceObserver.enable();
                    surface.pasting = !1;
                    surface.pasteSpecial = !1;
                    surface.beforePasteData = null;
                    ve.track('activity.clipboard', {
                        action: 'paste'
                    });
                });
            }
        });
    }
    ;
    ve.ce.Surface.prototype.beforePaste = function(e) {
        var range, startNode, endNode, contextElement, nativeRange, context, leftText, rightText, textNode, textStart, textEnd, selection = this.getModel().getSelection(), clipboardData = e.originalEvent.clipboardData, surfaceModel = this.getModel(), fragment = surfaceModel.getFragment(), documentModel = surfaceModel.getDocument();
        if (selection instanceof ve.dm.LinearSelection) {
            range = fragment.getSelection().getRange();
        } else if (selection instanceof ve.dm.TableSelection) {
            range = new ve.Range(selection.getRanges(documentModel)[0].start);
        } else {
            e.preventDefault();
            return;
        }
        this.beforePasteData = {};
        if (this.middleClickSelection) {
            if (!this.middleClickSelection.isCollapsed()) {
                this.clipboardIndex++;
                this.clipboard = {
                    slice: this.model.documentModel.shallowCloneFromSelection(this.middleClickSelection),
                    hash: null
                };
            }
            if (this.clipboard) {
                this.beforePasteData.custom = this.clipboardId + '-' + this.clipboardIndex;
            }
        } else if (clipboardData) {
            if (this.handleDataTransfer(clipboardData, true)) {
                e.preventDefault();
                return;
            }
            this.beforePasteData.custom = clipboardData.getData('text/xcustom');
            this.beforePasteData.html = clipboardData.getData('text/html');
            if (this.beforePasteData.html) {
                this.beforePasteData.html = this.beforePasteData.html.replace(/^[\s\S]*<!-- *StartFragment *-->/, '').replace(/<!-- *EndFragment *-->[\s\S]*$/, '');
            }
        }
        this.beforePasteData.scrollTop = this.$window.scrollTop();
        this.$pasteTarget.empty();
        startNode = documentModel.getBranchNodeFromOffset(range.start);
        if (startNode.canContainContent()) {
            textStart = textEnd = 0;
            contextElement = startNode.getClonedElement();
            $(documentModel.getStore().value(contextElement.originalDomElementsHash)).removeAttr('id typeof rel');
            context = [contextElement];
            if (range.start > startNode.getRange().start) {
                leftText = '';
                context.push(leftText);
                textStart = textEnd = 1;
            }
            endNode = documentModel.getBranchNodeFromOffset(range.end);
            if (range.end < endNode.getRange().end) {
                rightText = '';
                context.push(rightText);
            }
            if (!leftText && !rightText) {
                context.push('');
                textEnd = 1;
            }
            context.push({
                type: '/' + context[0].type
            });
            delete contextElement.internal;
            ve.dm.converter.getDomSubtreeFromModel(documentModel.cloneWithData(context, true), this.$pasteTarget[0]);
            this.$pasteTarget[0].focus();
            nativeRange = this.getElementDocument().createRange();
            textNode = this.$pasteTarget.children().contents()[0];
            nativeRange.setStart(textNode, textStart);
            nativeRange.setEnd(textNode, textEnd);
            this.nativeSelection.removeAllRanges();
            this.nativeSelection.addRange(nativeRange);
            this.beforePasteData.context = context;
            this.beforePasteData.leftText = leftText;
            this.beforePasteData.rightText = rightText;
        } else {
            this.$pasteTarget[0].focus();
        }
        this.$window.scrollTop(this.beforePasteData.scrollTop);
    }
    ;
    ve.ce.Surface.prototype.afterPaste = function() {
        var pasteData, isMultiline, pending, tableAction, surfaceModel = this.getModel(), documentModel = surfaceModel.getDocument(), fragment = surfaceModel.getFragment(), targetFragment = surfaceModel.getFragment(null, true), view = this, beforePasteData = this.beforePasteData || {}, done = ve.createDeferred().resolve().promise();
        if (!this.nativeSelection.isCollapsed) {
            return done;
        }
        if (this.getModel().getFragment().isNull()) {
            return done;
        }
        this.$pasteTarget.find('style').remove();
        pasteData = this.afterPasteExtractClipboardData();
        if (fragment.getSelection()instanceof ve.dm.TableSelection) {
            if (fragment.getSelection()instanceof ve.dm.TableSelection && pasteData.slice instanceof ve.dm.TableSlice) {
                tableAction = new ve.ui.TableAction(this.getSurface());
                tableAction.importTable(pasteData.slice.getTableNode(documentModel));
                return ve.createDeferred().resolve().promise();
            }
            targetFragment = surfaceModel.getLinearFragment(fragment.getSelection().getRanges(documentModel)[0], true);
        }
        isMultiline = this.getDocument().getBranchNodeFromOffset(targetFragment.getSelection().getCoveringRange().from).isMultiline();
        if (pasteData.slice) {
            pending = this.afterPasteAddToFragmentFromInternal(pasteData.slice, fragment, targetFragment, isMultiline);
        } else {
            pending = this.afterPasteAddToFragmentFromExternal(pasteData.clipboardKey, pasteData.$clipboardHtml, fragment, targetFragment, isMultiline);
        }
        return pending.then(function() {
            if (view.getSelection().isNativeCursor()) {
                view.$attachedRootNode[0].focus();
                view.$window.scrollTop(beforePasteData.scrollTop);
                setTimeout(function() {
                    view.$window.scrollTop(beforePasteData.scrollTop);
                });
            }
            if (fragment.getSelection()instanceof ve.dm.LinearSelection) {
                targetFragment.collapseToEnd().select();
                view.checkSequences(true);
            }
        });
    }
    ;
    ve.ce.Surface.prototype.afterPasteExtractClipboardData = function() {
        var clipboardKey, clipboardHash, $clipboardHtml, slice, beforePasteData = this.beforePasteData || {};
        if (beforePasteData.custom) {
            clipboardKey = beforePasteData.custom;
        } else {
            if (beforePasteData.html) {
                $clipboardHtml = $(ve.sanitizeHtml(beforePasteData.html)).filter(function() {
                    var val = this.getAttribute && this.getAttribute('data-ve-clipboard-key');
                    if (val) {
                        clipboardKey = val;
                        return false;
                    }
                    return true;
                });
                clipboardHash = this.constructor.static.getClipboardHash($clipboardHtml);
            } else {
                clipboardKey = this.$pasteTarget.find('span[data-ve-clipboard-key]').data('ve-clipboard-key');
                clipboardHash = this.constructor.static.getClipboardHash(this.$pasteTarget, beforePasteData);
            }
        }
        if (clipboardKey === this.clipboardId + '-' + this.clipboardIndex) {
            if (beforePasteData.custom || clipboardHash === this.clipboard.hash) {
                slice = this.clipboard.slice;
                slice.data.cloneElements(true);
            }
        }
        if (!slice && !$clipboardHtml && beforePasteData.html) {
            $clipboardHtml = $(ve.sanitizeHtml(beforePasteData.html));
        }
        return {
            clipboardKey: clipboardKey,
            $clipboardHtml: $clipboardHtml,
            slice: slice
        };
    }
    ;
    ve.ce.Surface.prototype.afterPasteSanitize = function(linearData, isMultiline, isExternal) {
        var importRules = this.afterPasteImportRules(isMultiline);
        if (isExternal) {
            linearData.sanitize(importRules.external || {});
        }
        linearData.sanitize(importRules.all || {});
    }
    ;
    ve.ce.Surface.prototype.afterPasteImportRules = function(isMultiline) {
        var importRules = !this.pasteSpecial ? this.getSurface().getImportRules() : {
            all: {
                plainText: !0,
                keepEmptyContentBranches: !0
            }
        };
        if (!isMultiline) {
            importRules = {
                all: ve.extendObject({}, importRules.all, {
                    singleLine: !0
                }),
                external: ve.extendObject({}, importRules.external, {
                    singleLine: !0
                })
            };
        }
        return importRules;
    }
    ;
    ve.ce.Surface.prototype.afterPasteAddToFragmentFromInternal = function(slice, fragment, targetFragment, isMultiline) {
        var linearData, data, insertionPromise;
        if (fragment.getSelection()instanceof ve.dm.TableSelection) {
            targetFragment.removeContent();
        }
        if (isMultiline) {
            linearData = new ve.dm.ElementLinearData(slice.getStore(),ve.copy(slice.getOriginalData()));
            if (this.pasteSpecial) {
                this.afterPasteSanitize(linearData, isMultiline);
            }
            try {
                insertionPromise = this.afterPasteInsertInternalData(targetFragment, linearData.getData());
            } catch (e) {}
        }
        if (!insertionPromise) {
            linearData = new ve.dm.ElementLinearData(slice.getStore(),ve.copy(slice.getBalancedData()));
            if (this.pasteSpecial || !isMultiline) {
                this.afterPasteSanitize(linearData, isMultiline);
            }
            data = linearData.getData();
            if (!isMultiline) {
                if (data[0].type) {
                    data = data.slice(1, data.length - 1);
                }
            }
            insertionPromise = this.afterPasteInsertInternalData(targetFragment, data);
        }
        return insertionPromise;
    }
    ;
    ve.ce.Surface.prototype.afterPasteInsertInternalData = function(targetFragment, data) {
        targetFragment.insertContent(data, true);
        return targetFragment.getPending();
    }
    ;
    ve.ce.Surface.prototype.afterPasteAddToFragmentFromExternal = function(clipboardKey, $clipboardHtml, fragment, targetFragment, isMultiline, forceClipboardData) {
        var data, $body, $images, i, htmlDoc, htmlBlacklist, pastedDocumentModel, tableAction, contextRange, pastedNodes, importantElement = '[id],[typeof],[rel]', items = [], surfaceModel = this.getModel(), documentModel = surfaceModel.getDocument(), beforePasteData = this.beforePasteData || {};
        if ((clipboardKey || forceClipboardData) && $clipboardHtml) {
            if (forceClipboardData || clipboardKey === 'useClipboardData-0' || $clipboardHtml.find(importantElement).addBack(importantElement).length > this.$pasteTarget.find(importantElement).length) {
                htmlDoc = ve.sanitizeHtmlToDocument(beforePasteData.html);
                $(htmlDoc).find('span').removeClass('ve-pasteProtect').end().find('span[data-ve-clipboard-key]').remove().end().find('[data-ve-attributes]').removeAttr('data-ve-attributes');
                beforePasteData.context = null;
            }
        }
        if (!htmlDoc) {
            htmlDoc = ve.sanitizeHtmlToDocument(this.$pasteTarget.html());
        }
        $body = $(htmlDoc.body);
        $images = $body.children('img[src^=data\\:]');
        if ($images.length === $body.children().length) {
            for (i = 0; i < $images.length; i++) {
                items.push(ve.ui.DataTransferItem.static.newFromDataUri($images.eq(i).attr('src'), $images[i].outerHTML));
            }
            if (this.handleDataTransferItems(items, true)) {
                return ve.createDeferred().resolve().promise();
            }
        }
        this.afterPasteSanitizeExternal($(htmlDoc.body));
        $(htmlDoc.body).find('ul > ul, ul > ol, ol > ul, ol > ol').each(function() {
            if (this.previousElementSibling) {
                this.previousElementSibling.appendChild(this);
            } else {
                $(this).wrap('<li>');
            }
        });
        $(htmlDoc.body).find('li, dd, dt').each(function() {
            var list, listType = {
                li: 'ul',
                dd: 'dl',
                dt: 'dl'
            }, tag = this.tagName.toLowerCase(), parentTag = this.parentNode.tagName.toLowerCase();
            if ((tag === 'li' && (parentTag !== 'ul' && parentTag !== 'ol')) || ((tag === 'dd' || tag === 'dt') && parentTag !== 'dl')) {
                list = htmlDoc.createElement(listType[tag]);
                this.parentNode.insertBefore(list, this);
                while (list.nextElementSibling && listType[list.nextElementSibling.tagName.toLowerCase()] === listType[tag]) {
                    list.appendChild(list.nextElementSibling);
                }
            }
        });
        htmlBlacklist = ve.getProp(this.afterPasteImportRules(isMultiline), 'external', 'htmlBlacklist');
        if (htmlBlacklist && !clipboardKey) {
            if (htmlBlacklist.remove) {
                Object.keys(htmlBlacklist.remove).forEach(function(selector) {
                    if (htmlBlacklist.remove[selector]) {
                        $(htmlDoc.body).find(selector).remove();
                    }
                });
            }
            if (htmlBlacklist.unwrap) {
                Object.keys(htmlBlacklist.unwrap).forEach(function(selector) {
                    if (htmlBlacklist.unwrap[selector]) {
                        $(htmlDoc.body).find(selector).contents().unwrap();
                    }
                });
            }
        }
        pastedDocumentModel = ve.dm.converter.getModelFromDom(htmlDoc, {
            targetDoc: documentModel.getHtmlDocument(),
            fromClipboard: !0
        });
        data = pastedDocumentModel.data;
        data.cloneElements(true);
        this.afterPasteSanitize(data, isMultiline, !clipboardKey);
        data.remapInternalListKeys(documentModel.getInternalList());
        pastedDocumentModel.buildNodeTree();
        if (fragment.getSelection()instanceof ve.dm.TableSelection) {
            if (pastedDocumentModel.documentNode.children.length === 2 && pastedDocumentModel.documentNode.children[0]instanceof ve.dm.TableNode) {
                tableAction = new ve.ui.TableAction(this.getSurface());
                tableAction.importTable(pastedDocumentModel.documentNode.children[0], true);
                return ve.createDeferred().resolve().promise();
            }
            targetFragment.removeContent();
        }
        if (beforePasteData.context) {
            contextRange = this.afterPasteFromExternalContextRange(pastedDocumentModel, isMultiline, forceClipboardData);
            if (!contextRange) {
                return this.afterPasteAddToFragmentFromExternal(clipboardKey, $clipboardHtml, fragment, targetFragment, isMultiline, true);
            }
        } else {
            contextRange = pastedDocumentModel.getDocumentRange();
        }
        pastedNodes = pastedDocumentModel.selectNodes(contextRange, 'siblings').filter(function(node) {
            return !(node.range && node.range.isCollapsed());
        });
        if (pastedNodes.length === 1 && pastedNodes[0].node.canContainContent()) {
            if (contextRange.containsRange(pastedNodes[0].nodeRange)) {
                contextRange = pastedNodes[0].nodeRange;
            }
        }
        return this.afterPasteInsertExternalData(targetFragment, pastedDocumentModel, contextRange);
    }
    ;
    ve.ce.Surface.prototype.afterPasteInsertExternalData = function(targetFragment, pastedDocumentModel, contextRange) {
        var pastedText, handled;
        if (pastedDocumentModel.data.isPlainText(contextRange, true, undefined, true)) {
            pastedText = pastedDocumentModel.data.getText(true, contextRange);
            if (pastedText) {
                handled = this.handleDataTransferItems([ve.ui.DataTransferItem.static.newFromString(pastedText)], true, targetFragment);
            }
        }
        if (!handled) {
            targetFragment.insertDocument(pastedDocumentModel, contextRange, true);
        }
        return targetFragment.getPending();
    }
    ;
    ve.ce.Surface.prototype.afterPasteFromExternalContextRange = function(pastedDocumentModel, isMultiline, forceClipboardData) {
        var leftText, rightText, left, right, data = pastedDocumentModel.data, documentRange = pastedDocumentModel.getDocumentRange(), beforePasteData = this.beforePasteData || {}, context = new ve.dm.ElementLinearData(pastedDocumentModel.getStore(),ve.copy(beforePasteData.context));
        this.afterPasteSanitize(context, isMultiline);
        leftText = beforePasteData.leftText;
        rightText = beforePasteData.rightText;
        left = 0;
        while (context.getLength() && ve.dm.ElementLinearData.static.compareElementsUnannotated(data.getData(left), data.isElementData(left) ? context.getData(0) : leftText)) {
            if (!data.isElementData(left)) {
                leftText = '';
            }
            left++;
            context.splice(0, 1);
        }
        right = documentRange.end;
        while (right > 0 && context.getLength() && ve.dm.ElementLinearData.static.compareElementsUnannotated(data.getData(right - 1), data.isElementData(right - 1) ? context.getData(context.getLength() - 1) : rightText)) {
            if (!data.isElementData(right - 1)) {
                rightText = '';
            }
            right--;
            context.splice(context.getLength() - 1, 1);
        }
        if ((leftText || rightText) && !forceClipboardData) {
            return false;
        }
        while (right > 0 && data.getType(right - 1) === 'break') {
            right--;
        }
        return new ve.Range(left,right);
    }
    ;
    ve.ce.Surface.prototype.afterPasteSanitizeExternal = function($element) {
        var metadataIdRegExp = ve.init.platform.getMetadataIdRegExp();
        $element.find('span[data-ve-clipboard-key]').remove();
        $element.find('style').remove();
        $element.find('span').each(function(i, node) {
            var $node;
            if (!node.style) {
                return;
            }
            $node = $(node);
            if (+node.style.fontWeight >= 700 || node.style.fontWeight === 'bold') {
                $node.wrap('<b>');
            }
            if (node.style.fontStyle === 'italic') {
                $node.wrap('<i>');
            }
            if (node.style.textDecorationLine === 'underline') {
                $node.wrap('<u>');
            }
            if (node.style.textDecorationLine === 'line-through') {
                $node.wrap('<s>');
            }
            if (node.style.verticalAlign === 'super') {
                $node.wrap('<sup>');
            }
            if (node.style.verticalAlign === 'sub') {
                $node.wrap('<sub>');
            }
        });
        $element.find('[style]').removeAttr('style');
        if (metadataIdRegExp) {
            $element.find('[id]').each(function() {
                var $this = $(this);
                if ($this.attr('id').match(metadataIdRegExp)) {
                    $this.removeAttr('id');
                }
            });
        }
        $element.find('span').each(function() {
            var $this = $(this);
            $this.removeClass('ve-pasteProtect');
            if ($this.attr('class') === '') {
                $this.removeAttr('class');
            }
            if (!this.attributes.length) {
                $this.replaceWith(this.childNodes);
            }
        });
        $element.find('[data-ve-attributes]').each(function() {
            var attrs, attrsJSON = this.getAttribute('data-ve-attributes');
            this.removeAttribute('data-ve-attributes');
            try {
                attrs = JSON.parse(attrsJSON);
            } catch (err) {
                return;
            }
            $(this).attr(attrs);
        });
    }
    ;
    ve.ce.Surface.prototype.handleDataTransfer = function(dataTransfer, isPaste, targetFragment) {
        var i, l, pushItemToBack, items = [], htmlStringData = dataTransfer.getData('text/html'), htmlPreParse, imgCount = 0, hasContent = !1;
        if (!htmlStringData) {
            if (dataTransfer.items) {
                for (i = 0,
                l = dataTransfer.items.length; i < l; i++) {
                    if (dataTransfer.items[i].kind !== 'string') {
                        items.push(ve.ui.DataTransferItem.static.newFromItem(dataTransfer.items[i], htmlStringData));
                    }
                }
            } else if (dataTransfer.files) {
                for (i = 0,
                l = dataTransfer.files.length; i < l; i++) {
                    items.push(ve.ui.DataTransferItem.static.newFromBlob(dataTransfer.files[i], htmlStringData));
                }
            }
        } else if (dataTransfer.files) {
            htmlPreParse = $.parseHTML(htmlStringData);
            for (i = 0; i < htmlPreParse.length; i++) {
                if (htmlPreParse[i].nodeName === 'IMG') {
                    imgCount++;
                } else if ((htmlPreParse[i].nodeType === 1 || htmlPreParse[i].nodeType === 3) && htmlPreParse[i].textContent && htmlPreParse[i].textContent.trim() !== '') {
                    hasContent = !0;
                }
                if (typeof htmlPreParse[i].querySelectorAll === 'function') {
                    imgCount += htmlPreParse[i].querySelectorAll('img').length;
                }
            }
            if (!hasContent && imgCount === dataTransfer.files.length) {
                for (i = 0,
                l = dataTransfer.files.length; i < l; i++) {
                    items.push(ve.ui.DataTransferItem.static.newFromBlob(dataTransfer.files[i], htmlStringData));
                }
            }
        }
        if (dataTransfer.items) {
            for (i = 0,
            l = dataTransfer.items.length; i < l; i++) {
                if (dataTransfer.items[i].kind === 'string' && dataTransfer.items[i].type.substr(0, 5) === 'text/') {
                    items.push(ve.ui.DataTransferItem.static.newFromString(dataTransfer.getData(dataTransfer.items[i].type), dataTransfer.items[i].type, htmlStringData));
                }
            }
        }
        pushItemToBack = function(array, type) {
            var i, l;
            for (i = 0,
            l = array.length; i < l; i++) {
                if (array[i].type === type) {
                    return array.push(array.splice(i, 1)[0]);
                }
            }
        }
        ;
        pushItemToBack(items, 'text/html');
        pushItemToBack(items, 'text/plain');
        return this.handleDataTransferItems(items, isPaste, targetFragment);
    }
    ;
    ve.ce.Surface.prototype.handleDataTransferItems = function(items, isPaste, targetFragment) {
        var i, l, name, item, dataTransferHandlerFactory = this.getSurface().dataTransferHandlerFactory, handled = !1;
        targetFragment = targetFragment || this.getModel().getFragment();
        function insert(docOrData) {
            var resultFragment, rootChildren;
            resultFragment = !isPaste ? targetFragment.collapseToEnd() : targetFragment;
            if (docOrData instanceof ve.dm.Document) {
                rootChildren = docOrData.getDocumentNode().children;
                if (rootChildren[0] && rootChildren[0].type === 'paragraph' && (!rootChildren[1] || rootChildren[1].type === 'internalList')) {
                    resultFragment.insertDocument(docOrData, rootChildren[0].getRange());
                } else {
                    resultFragment.insertDocument(docOrData);
                }
            } else {
                resultFragment.insertContent(docOrData);
            }
            resultFragment.collapseToEnd().select();
        }
        for (i = 0,
        l = items.length; i < l; i++) {
            item = items[i];
            name = dataTransferHandlerFactory.getHandlerNameForItem(item, isPaste, this.pasteSpecial);
            if (name) {
                dataTransferHandlerFactory.create(name, this.surface, item).getInsertableData().done(insert);
                handled = !0;
                break;
            } else if (isPaste && item.type === 'text/html') {
                break;
            }
        }
        return handled;
    }
    ;
    ve.ce.Surface.prototype.selectAll = function() {
        var documentRange, range, matrix, activeNode, selection = this.getModel().getSelection(), dmDoc = this.getModel().getDocument();
        if (selection instanceof ve.dm.LinearSelection) {
            activeNode = this.getActiveNode();
            if (activeNode) {
                range = activeNode.getRange();
                range = new ve.Range(range.from + 1,range.to - 1);
            } else {
                documentRange = this.getModel().getDocument().getDocumentRange();
                range = new ve.Range(dmDoc.getNearestCursorOffset(0, 1),dmDoc.getNearestCursorOffset(documentRange.end, -1));
            }
            this.getModel().setLinearSelection(range);
        } else if (selection instanceof ve.dm.TableSelection) {
            matrix = selection.getTableNode(dmDoc).getMatrix();
            this.getModel().setSelection(new ve.dm.TableSelection(selection.tableRange,0,0,matrix.getMaxColCount() - 1,matrix.getRowCount() - 1));
        }
    }
    ;
    ve.ce.Surface.prototype.onDocumentInput = function(e) {
        var inputType = e.originalEvent ? e.originalEvent.inputType : null
          , inputTypeCommands = this.constructor.static.inputTypeCommands;
        if (inputType && Object.prototype.hasOwnProperty.call(inputTypeCommands, inputType)) {
            if (inputTypeCommands[inputType]) {
                this.getSurface().executeCommand(this.constructor.static.inputTypeCommands[inputType]);
            }
            e.preventDefault();
            return;
        }
        this.incRenderLock();
        try {
            this.surfaceObserver.pollOnce();
        } finally {
            this.decRenderLock();
        }
    }
    ;
    ve.ce.Surface.prototype.onDocumentCompositionStart = function() {
        if (this.model.selection instanceof ve.dm.TableSelection && $.client.profile().layout === 'gecko') {
            return;
        }
        this.handleInsertion();
    }
    ;
    ve.ce.Surface.prototype.onModelSelect = function() {
        var focusedNode, blockSlug, selection = this.getModel().getSelection();
        setTimeout(this.checkDelayedSequences.bind(this));
        this.cursorDirectionality = null;
        this.contentBranchNodeChanged = !1;
        this.selection = null;
        if (selection.isNull()) {
            this.removeCursorHolders();
        }
        if (selection instanceof ve.dm.LinearSelection) {
            blockSlug = this.findBlockSlug(selection.getRange());
            if (blockSlug !== this.focusedBlockSlug) {
                if (this.focusedBlockSlug) {
                    this.focusedBlockSlug.classList.remove('ve-ce-branchNode-blockSlug-focused');
                    this.focusedBlockSlug = null;
                }
                if (blockSlug) {
                    blockSlug.classList.add('ve-ce-branchNode-blockSlug-focused');
                    this.focusedBlockSlug = blockSlug;
                    this.preparePasteTargetForCopy();
                }
            }
            focusedNode = this.findFocusedNode(selection.getRange());
            if (this.isDeactivated() && !this.isShownAsDeactivated() && !blockSlug && !focusedNode) {
                this.activate();
            }
            if (focusedNode !== this.focusedNode) {
                if (this.focusedNode) {
                    this.focusedNode.setFocused(false);
                    this.focusedNode = null;
                }
                if (focusedNode) {
                    focusedNode.setFocused(true);
                    this.focusedNode = focusedNode;
                    if (!this.dragging) {
                        this.preparePasteTargetForCopy();
                        this.surfaceObserver.clear();
                    }
                }
            }
        } else {
            if (selection instanceof ve.dm.TableSelection) {
                this.preparePasteTargetForCopy();
            }
            if (this.focusedNode) {
                this.focusedNode.setFocused(false);
            }
            this.focusedNode = null;
        }
        if (!this.isRenderingLocked() && selection !== this.newModelSelection) {
            this.showModelSelection();
            this.cleanupUnicorns(false);
        }
        this.surfaceObserver.pollOnceNoCallback();
    }
    ;
    ve.ce.Surface.prototype.preparePasteTargetForCopy = function() {
        if (!OO.ui.isMobile()) {
            this.$pasteTarget.text((this.focusedNode && this.focusedNode.$element.text().trim()) || '');
            ve.selectElement(this.$pasteTarget[0]);
            this.$pasteTarget[0].focus();
        } else {
            this.deactivate(true);
        }
    }
    ;
    ve.ce.Surface.prototype.getFocusedNode = function(range) {
        var selection;
        if (!range) {
            return this.focusedNode;
        }
        selection = this.getModel().getSelection();
        if (selection instanceof ve.dm.LinearSelection && range.equalsSelection(selection.getRange())) {
            return this.focusedNode;
        }
        return this.findFocusedNode(range);
    }
    ;
    ve.ce.Surface.prototype.findBlockSlug = function(range) {
        var node;
        if (!range.isCollapsed()) {
            return null;
        }
        node = this.documentView.getBranchNodeFromOffset(range.end);
        if (!node.canHaveChildrenNotContent()) {
            return null;
        }
        return node.getSlugAtOffset(range.end);
    }
    ;
    ve.ce.Surface.prototype.findFocusedNode = function(range) {
        var startNode, endNode, documentNode = this.getDocument().getDocumentNode();
        if (!range.isCollapsed()) {
            startNode = documentNode.getNodeFromOffset(range.start + 1);
            if (startNode && startNode.isFocusable()) {
                endNode = documentNode.getNodeFromOffset(range.end - 1);
                if (startNode === endNode) {
                    return startNode;
                }
            }
        } else {
            startNode = documentNode.getNodeFromOffset(range.start);
            if (startNode && startNode.isFocusable()) {
                return startNode;
            }
        }
        return null;
    }
    ;
    ve.ce.Surface.prototype.onModelDocumentUpdate = function() {
        var surface = this;
        if (this.contentBranchNodeChanged) {
            this.onModelSelect();
        }
        this.surfaceObserver.pollOnceNoCallback();
        setTimeout(function() {
            surface.emit('position');
        });
    }
    ;
    ve.ce.Surface.prototype.onInsertionAnnotationsChange = function() {
        var changed = this.renderSelectedContentBranchNode();
        if (!changed) {
            return;
        }
        this.forceShowModelSelection();
        this.surfaceObserver.pollOnceNoCallback();
    }
    ;
    ve.ce.Surface.prototype.getSelectedContentBranchNode = function() {
        var node, selection = this.model.getSelection();
        if (!(selection instanceof ve.dm.LinearSelection)) {
            return null;
        }
        node = this.documentView.getBranchNodeFromOffset(selection.getRange().to);
        if (!node || !(node instanceof ve.ce.ContentBranchNode)) {
            return null;
        }
        return node;
    }
    ;
    ve.ce.Surface.prototype.renderSelectedContentBranchNode = function() {
        var node = this.getSelectedContentBranchNode();
        if (!node) {
            return false;
        }
        return node.renderContents();
    }
    ;
    ve.ce.Surface.prototype.handleObservedChanges = function(oldState, newState) {
        var newSelection, transaction, removedUnicorns, offset, activeNode, coveringRange, nodeRange, containsStart, containsEnd, blockSlug, surface = this, dmDoc = this.getModel().getDocument(), insertedText = !1, removedText = !1;
        if (newState.contentChanged) {
            if (this.readOnly) {
                newState.node.renderContents();
                this.showModelSelection();
                return;
            } else {
                transaction = newState.textState.getChangeTransaction(oldState.textState, dmDoc, newState.node.getOffset(), newState.node.unicornAnnotations);
                if (transaction) {
                    this.incRenderLock();
                    try {
                        this.changeModel(transaction);
                    } finally {
                        this.decRenderLock();
                    }
                    insertedText = transaction.operations.some(function(op) {
                        return op.type === 'replace' && op.insert.length;
                    });
                    removedText = transaction.operations.some(function(op) {
                        return op.type === 'replace' && op.remove.length;
                    });
                }
            }
        }
        if (!this.readOnly && newState.branchNodeChanged && oldState && oldState.node && oldState.node.root && oldState.node instanceof ve.ce.ContentBranchNode) {
            oldState.node.renderContents();
        }
        if (newState.selectionChanged && !(oldState && oldState.veRange && newState.veRange && !newState.veRange.isCollapsed() && oldState.veRange.equalsSelection(newState.veRange))) {
            if (newState.veRange) {
                if (newState.veRange.isCollapsed()) {
                    offset = dmDoc.getNearestCursorOffset(newState.veRange.from, 0);
                    if (offset === -1) {
                        newSelection = new ve.dm.NullSelection();
                    } else {
                        newSelection = new ve.dm.LinearSelection(new ve.Range(offset));
                    }
                } else {
                    newSelection = new ve.dm.LinearSelection(newState.veRange);
                }
            } else {
                newSelection = new ve.dm.NullSelection();
            }
            this.incRenderLock();
            try {
                this.changeModel(null, newSelection);
                if (newSelection instanceof ve.dm.LinearSelection && newSelection.isCollapsed()) {
                    blockSlug = this.findBlockSlug(newSelection.getRange());
                    if (blockSlug) {
                        this.preparePasteTargetForCopy();
                        this.surfaceObserver.pollOnceNoCallback();
                    }
                }
            } finally {
                this.decRenderLock();
            }
            removedUnicorns = this.cleanupUnicorns(false);
            if (removedUnicorns) {
                this.surfaceObserver.pollOnceNoCallback();
            }
            activeNode = this.getActiveNode();
            coveringRange = newSelection.getCoveringRange();
            if (activeNode && coveringRange) {
                nodeRange = activeNode.getRange();
                containsStart = nodeRange.containsRange(new ve.Range(coveringRange.start));
                containsEnd = nodeRange.containsRange(new ve.Range(coveringRange.end));
                if (containsStart !== containsEnd) {
                    newSelection = oldState && oldState.veRange ? new ve.dm.LinearSelection(oldState.veRange) : new ve.dm.NullSelection();
                    setTimeout(function() {
                        surface.changeModel(null, newSelection);
                        surface.showModelSelection();
                    });
                }
            }
            while (this.nativeSelection.rangeCount > 1) {
                this.nativeSelection.removeRange(this.nativeSelection.getRangeAt(0));
            }
        }
        if (insertedText) {
            surface.afterRenderLock(function() {
                surface.checkSequences();
                surface.maybeSetBreakpoint();
            });
        } else if (removedText) {
            surface.afterRenderLock(function() {
                surface.checkSequences(false, true);
                surface.maybeSetBreakpoint();
            });
        }
        if (newState.branchNodeChanged && newState.node) {
            this.updateCursorHolders();
            this.showModelSelection();
        }
        if (!insertedText) {
            surface.getModel().breakpoint();
        }
    }
    ;
    ve.ce.Surface.prototype.createSlug = function(element) {
        var $slug, surface = this, offset = ve.ce.getOffsetOfSlug(element), documentModel = this.getModel().getDocument();
        this.changeModel(ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, offset, [{
            type: 'paragraph',
            internal: {
                generated: 'slug'
            }
        }, {
            type: '/paragraph'
        }]), new ve.dm.LinearSelection(new ve.Range(offset + 1)));
        $slug = this.getDocument().getDocumentNode().getNodeFromOffset(offset + 1).$element;
        $slug.addClass('ve-ce-branchNode-newSlug');
        setTimeout(function() {
            $slug.addClass('ve-ce-branchNode-newSlug-open');
            setTimeout(function() {
                surface.emit('position');
            }, 200);
        });
        this.onModelSelect();
    }
    ;
    ve.ce.Surface.prototype.fixupCursorPosition = function(direction, extend) {
        var node, offset, previousNode, fixedPosition, nextNode;
        direction = direction > 0 ? 1 : -1;
        if (this.nativeSelection.rangeCount === 0) {
            return;
        }
        node = this.nativeSelection.focusNode;
        offset = this.nativeSelection.focusOffset;
        if (node.nodeType !== Node.ELEMENT_NODE) {
            return;
        }
        previousNode = node.childNodes[offset - 1];
        nextNode = node.childNodes[offset];
        if (!(previousNode && previousNode.nodeType === Node.ELEMENT_NODE && (previousNode.classList.contains('ve-ce-nail-pre-open') || previousNode.classList.contains('ve-ce-nail-pre-close'))) && !(nextNode && nextNode.nodeType === Node.ELEMENT_NODE && (nextNode.classList.contains('ve-ce-nail-post-open') || nextNode.classList.contains('ve-ce-nail-post-close')))) {
            return;
        }
        fixedPosition = ve.adjacentDomPosition({
            node: node,
            offset: offset
        }, direction, {
            stop: ve.isHardCursorStep
        });
        node = fixedPosition.node;
        offset = fixedPosition.offset;
        if (direction === -1) {
            fixedPosition = ve.adjacentDomPosition(fixedPosition, direction, {
                stop: ve.isHardCursorStep
            });
            if (fixedPosition.node.nodeType === Node.TEXT_NODE) {
                node = fixedPosition.node;
                offset = fixedPosition.node.length;
            }
        }
        this.showSelectionState(new ve.SelectionState({
            anchorNode: extend ? this.nativeSelection.anchorNode : node,
            anchorOffset: extend ? this.nativeSelection.anchorOffset : offset,
            focusNode: node,
            focusOffset: offset
        }));
    }
    ;
    ve.ce.Surface.prototype.checkSequences = function(isPaste, isDelete) {
        var matchingSequences, model = this.getModel(), selection = this.getSelection();
        if (!selection.isNativeCursor()) {
            return;
        }
        matchingSequences = this.getSurface().sequenceRegistry.findMatching(model.getDocument().data, selection.getModel().getCoveringRange().end, isPaste, isDelete);
        this.executeSequences(matchingSequences);
    }
    ;
    ve.ce.Surface.prototype.checkDelayedSequences = function() {
        var matchingSequences, matchingByName, i, matchingSeq, sequences = [], model = this.getModel(), selection = this.getSelection();
        if (this.deactivated || !selection.isNativeCursor()) {
            matchingSequences = [];
        } else {
            matchingSequences = this.getSurface().sequenceRegistry.findMatching(model.getDocument().data, selection.getModel().getCoveringRange().end);
        }
        matchingByName = {};
        for (i = 0; i < matchingSequences.length; i++) {
            matchingByName[matchingSequences[i].sequence.getName()] = matchingSequences[i];
        }
        for (i = 0; i < this.delayedSequences.length; i++) {
            matchingSeq = matchingByName[this.delayedSequences[i].sequence.getName()];
            if (!matchingSeq || matchingSeq.range.start !== this.delayedSequences[i].range.start) {
                this.delayedSequences[i].wasDelayed = !0;
                sequences.push(this.delayedSequences[i]);
            }
        }
        this.delayedSequences = [];
        this.executeSequences(sequences);
    }
    ;
    ve.ce.Surface.prototype.executeSequences = function(sequences) {
        var i, executed = !1;
        for (i = 0; i < sequences.length; i++) {
            if (sequences[i].sequence.delayed && !sequences[i].wasDelayed) {
                this.delayedSequences.push(sequences[i]);
            } else {
                executed = sequences[i].sequence.execute(this.surface, sequences[i].range) || executed;
            }
        }
        if (executed) {
            this.delayedSequences = [];
            this.showModelSelection();
        }
    }
    ;
    ve.ce.Surface.prototype.maybeSetBreakpoint = function() {
        var offset, data = this.getModel().getDocument().data, selection = this.getSelection();
        if (!selection.isNativeCursor()) {
            return;
        }
        offset = selection.getModel().getCoveringRange().end - 1;
        if (data.getWordRange(offset).end === offset) {
            this.getModel().breakpoint();
        }
    }
    ;
    ve.ce.Surface.prototype.onWindowResize = function() {
        this.emit('position');
        if (OO.ui.isMobile() && !ve.init.platform.constructor.static.isIos()) {
            this.getSurface().scrollSelectionIntoView();
        }
    }
    ;
    ve.ce.Surface.prototype.startRelocation = function() {
        this.relocatingSelection = this.getModel().getSelection();
        this.relocatingNode = this.getModel().getSelectedNode();
        this.emit('relocationStart');
    }
    ;
    ve.ce.Surface.prototype.endRelocation = function() {
        this.relocatingSelection = null;
        this.relocatingNode = null;
        this.onDocumentDragLeave();
        this.emit('relocationEnd');
    }
    ;
    ve.ce.Surface.prototype.setActiveNode = function(node) {
        this.activeNode = node;
    }
    ;
    ve.ce.Surface.prototype.getActiveNode = function() {
        return this.activeNode;
    }
    ;
    ve.ce.Surface.prototype.storeKeyDownState = function(e) {
        this.keyDownState.event = e;
        this.keyDownState.selectionState = null;
        if (this.nativeSelection.rangeCount > 0 && e && (e.keyCode === OO.ui.Keys.UP || e.keyCode === OO.ui.Keys.DOWN || e.keyCode === OO.ui.Keys.LEFT || e.keyCode === OO.ui.Keys.RIGHT)) {
            this.keyDownState.selectionState = new ve.SelectionState(this.nativeSelection);
        }
    }
    ;
    ve.ce.Surface.prototype.clearKeyDownState = function() {
        this.keyDownState.event = null;
        this.keyDownState.selectionState = null;
    }
    ;
    ve.ce.Surface.prototype.moveModelCursor = function(offset) {
        var selection = this.model.getSelection();
        if (selection instanceof ve.dm.LinearSelection) {
            this.model.setLinearSelection(this.model.getDocument().getRelativeRange(selection.getRange(), offset, 'character', false));
        }
    }
    ;
    ve.ce.Surface.prototype.getFocusedNodeDirectionality = function() {
        var cursorNode, range = this.model.getSelection().getRange();
        if (this.cursorDirectionality) {
            return this.cursorDirectionality;
        }
        cursorNode = this.getDocument().getNodeAndOffset(range.to).node;
        if (cursorNode.nodeType === Node.TEXT_NODE) {
            cursorNode = cursorNode.parentNode;
        }
        return $(cursorNode).css('direction');
    }
    ;
    ve.ce.Surface.prototype.restoreActiveNodeSelection = function() {
        var currentRange, activeNode = this.getActiveNode(), activeRange = activeNode && activeNode.getRange();
        if (activeRange && (currentRange = ve.ce.veRangeFromSelection(this.nativeSelection)) && (!currentRange.isCollapsed() || activeNode.trapsCursor()) && !activeRange.containsRange(currentRange)) {
            this.showModelSelection();
            return true;
        } else {
            return false;
        }
    }
    ;
    ve.ce.Surface.prototype.findAdjacentUneditableBranchNode = function(direction) {
        var node, viewNode, activeNode = this.getActiveNode(), forward = direction > 0;
        node = $(this.nativeSelection.focusNode).closest('.ve-ce-branchNode,.ve-ce-leafNode,.ve-ce-surface-paste')[0];
        if (!node || node.classList.contains('ve-ce-surface-paste')) {
            return null;
        }
        while (true) {
            while (!(forward ? node.nextSibling : node.previousSibling)) {
                node = node.parentNode;
                if (node === null) {
                    return null;
                }
            }
            node = forward ? node.nextSibling : node.previousSibling;
            while (true) {
                if ($.data(node, 'view')instanceof ve.ce.ContentBranchNode || node.nodeType === Node.TEXT_NODE) {
                    return null;
                }
                if ($(node).is('.ve-ce-focusableNode,.ve-ce-tableNode')) {
                    if (activeNode) {
                        viewNode = $(node).data('view');
                        if (!activeNode.getRange().containsRange(viewNode.getRange())) {
                            return null;
                        }
                    }
                    return node;
                }
                if (!node.childNodes || node.childNodes.length === 0) {
                    break;
                }
                node = forward ? node.firstChild : node.lastChild;
            }
        }
    }
    ;
    ve.ce.Surface.prototype.updateCursorHolders = function() {
        var holderBefore = null
          , holderAfter = null
          , doc = this.getElementDocument()
          , nodeBefore = this.findAdjacentUneditableBranchNode(-1)
          , nodeAfter = this.findAdjacentUneditableBranchNode(1);
        this.removeCursorHolders();
        if (nodeBefore) {
            holderBefore = doc.importNode(this.constructor.static.cursorHolderTemplate, true);
            holderBefore.classList.add('ve-ce-cursorHolder-after');
            if (ve.inputDebug) {
                holderBefore.classList.add('ve-ce-cursorHolder-debug');
            }
            $(nodeBefore).after(holderBefore);
        }
        if (nodeAfter) {
            holderAfter = doc.importNode(this.constructor.static.cursorHolderTemplate, true);
            holderAfter.classList.add('ve-ce-cursorHolder-before');
            $(nodeAfter).before(holderAfter);
            if (ve.inputDebug) {
                holderAfter.classList.add('ve-ce-cursorHolder-debug');
            }
        }
        this.cursorHolders = {
            before: holderBefore,
            after: holderAfter
        };
    }
    ;
    ve.ce.Surface.prototype.removeCursorHolders = function() {
        if (!this.cursorHolders) {
            return;
        }
        if (this.cursorHolders.before && this.cursorHolders.before.parentNode) {
            this.cursorHolders.before.parentNode.removeChild(this.cursorHolders.before);
        }
        if (this.cursorHolders.after && this.cursorHolders.after.parentNode) {
            this.cursorHolders.after.parentNode.removeChild(this.cursorHolders.after);
        }
        this.cursorHolders = null;
    }
    ;
    ve.ce.Surface.prototype.handleInsertion = function() {
        var range, surfaceModel = this.getModel(), fragment = surfaceModel.getFragment(), selection = this.getSelection();
        if (selection instanceof ve.ce.TableSelection) {
            surfaceModel.setSelection(selection.getModel().collapseToFrom());
            ve.ce.keyDownHandlerFactory.lookup('tableDelete').static.execute(this);
            this.documentView.getBranchNodeFromOffset(selection.getModel().tableRange.start + 1).setEditing(true);
            selection = this.getSelection();
        } else if (selection.isFocusedNode()) {
            return;
        }
        if (!(selection instanceof ve.ce.LinearSelection)) {
            return;
        }
        range = selection.getModel().getRange();
        if (this.selectionSplitsNailedAnnotation() || (!range.isCollapsed() && !this.documentView.rangeInsideOneLeafNode(range))) {
            surfaceModel.setNullSelection();
            fragment.removeContent().collapseToStart().select();
            this.surfaceObserver.clear();
            this.storeKeyDownState(this.keyDownState.event);
            this.surfaceObserver.stopTimerLoop();
            this.surfaceObserver.pollOnce();
        }
    }
    ;
    ve.ce.Surface.prototype.getViewportRange = function() {
        var surface = this
          , documentModel = this.getModel().getDocument()
          , data = documentModel.data
          , dimensions = this.surface.getViewportDimensions()
          , padding = 50
          , top = Math.max(0, dimensions.top - padding)
          , bottom = dimensions.bottom + (padding * 2)
          , documentRange = this.getModel().getDocument().getDocumentRange();
        function highestIgnoreChildrenNode(childNode) {
            var ignoreChildrenNode = null;
            childNode.traverseUpstream(function(node) {
                if (node.shouldIgnoreChildren()) {
                    ignoreChildrenNode = node;
                }
            });
            return ignoreChildrenNode;
        }
        function binarySearch(offset, range, side) {
            var mid, rect, midNode, ignoreChildrenNode, nodeRange, start = range.start, end = range.end, lastLength = Infinity;
            while (range.getLength() < lastLength) {
                lastLength = range.getLength();
                mid = Math.round((range.start + range.end) / 2);
                midNode = documentModel.documentNode.getNodeFromOffset(mid);
                ignoreChildrenNode = highestIgnoreChildrenNode(midNode);
                if (ignoreChildrenNode) {
                    nodeRange = ignoreChildrenNode.getOuterRange();
                    mid = side === 'top' ? nodeRange.end : nodeRange.start;
                } else {
                    mid = data.getNearestContentOffset(mid);
                }
                rect = surface.getSelection(new ve.dm.LinearSelection(new ve.Range(mid))).getSelectionBoundingRect();
                if (rect[side] > offset) {
                    end = mid;
                    range = new ve.Range(range.start,end);
                } else {
                    start = mid;
                    range = new ve.Range(start,range.end);
                }
            }
            return side === 'bottom' ? start : end;
        }
        return new ve.Range(binarySearch(top, documentRange, 'bottom'),binarySearch(bottom, documentRange, 'top'));
    }
    ;
    ve.ce.Surface.prototype.forceShowModelSelection = function() {
        return this.showModelSelection(true);
    }
    ;
    ve.ce.Surface.prototype.showModelSelection = function(force) {
        var selection, changed, modelRange, impliedModelRange;
        if (this.deactivated) {
            setTimeout(this.updateDeactivatedSelection.bind(this));
            return false;
        }
        selection = this.getSelection();
        if (selection.getModel().isNull()) {
            if (!this.nativeSelection.rangeCount) {
                return false;
            }
            modelRange = null;
        } else {
            if (!selection.isNativeCursor() || this.focusedBlockSlug) {
                return false;
            }
            modelRange = selection.getModel().getRange();
            if (!force && this.$attachedRootNode.get(0).contains(this.nativeSelection.focusNode)) {
                impliedModelRange = new ve.Range(ve.ce.getOffset(this.nativeSelection.anchorNode, this.nativeSelection.anchorOffset),ve.ce.getOffset(this.nativeSelection.focusNode, this.nativeSelection.focusOffset));
                if (modelRange.equals(impliedModelRange)) {
                    return false;
                }
            }
        }
        changed = this.showSelectionState(this.getSelectionState(modelRange));
        if (changed) {
            this.updateCursorHolders();
            return true;
        }
        return false;
    }
    ;
    ve.ce.Surface.prototype.showSelectionState = function(selection) {
        var range, $focusTarget, extendedBackwards = !1, sel = this.nativeSelection, newSel = selection;
        if (newSel.equalsSelection(sel)) {
            this.updateActiveAnnotations();
            return false;
        }
        if (!newSel.getNativeRange(this.getElementDocument())) {
            sel.removeAllRanges();
            return true;
        }
        if (newSel.isBackwards) {
            if (ve.supportsSelectionExtend) {
                range = this.getElementDocument().createRange();
                range.setStart(newSel.anchorNode, newSel.anchorOffset);
                sel.removeAllRanges();
                sel.addRange(range);
                try {
                    sel.extend(newSel.focusNode, newSel.focusOffset);
                    extendedBackwards = !0;
                } catch (e) {}
            }
            if (!extendedBackwards) {
                newSel = newSel.flip();
                if (newSel.equalsSelection(sel)) {
                    this.updateActiveAnnotations();
                    return false;
                }
            }
        }
        if (!extendedBackwards) {
            sel.removeAllRanges();
            sel.addRange(newSel.getNativeRange(this.getElementDocument()));
        }
        $focusTarget = $(newSel.focusNode).closest('[contenteditable=true]');
        if ($focusTarget.get(0) === this.getElementDocument().activeElement) {} else if (!OO.ui.contains($focusTarget.get(0), this.getElementDocument().activeElement)) {
            $focusTarget.trigger('focus');
        } else {
            ve.scrollIntoView($(newSel.focusNode).closest('*').get(0));
        }
        this.updateActiveAnnotations();
        return true;
    }
    ;
    ve.ce.Surface.prototype.updateActiveAnnotations = function(fromModelOrNode) {
        var activeAnnotations, changed = !1, surface = this, canBeActive = function(view) {
            return view.canBeActive();
        };
        if (fromModelOrNode === true) {
            activeAnnotations = this.annotationsAtModelSelection(canBeActive);
        } else if (fromModelOrNode instanceof Node) {
            activeAnnotations = this.annotationsAtNode(fromModelOrNode, canBeActive);
        } else {
            activeAnnotations = this.annotationsAtFocus(canBeActive);
        }
        this.activeAnnotations.forEach(function(annotation) {
            if (activeAnnotations.indexOf(annotation) === -1) {
                annotation.$element.removeClass('ve-ce-annotation-active');
                changed = !0;
            }
        });
        activeAnnotations.forEach(function(annotation) {
            if (surface.activeAnnotations.indexOf(annotation) === -1) {
                annotation.$element.addClass('ve-ce-annotation-active');
                changed = !0;
            }
        });
        if (changed) {
            this.activeAnnotations = activeAnnotations;
            this.model.emit('contextChange');
        }
    }
    ;
    ve.ce.Surface.prototype.selectNodeContents = function(node, collapse) {
        var anchor, focus;
        if (!node) {
            return false;
        }
        anchor = ve.ce.nextCursorOffset(node.childNodes[0]);
        focus = ve.ce.previousCursorOffset(node.childNodes[node.childNodes.length - 1]);
        if (collapse === 'start') {
            focus = anchor;
        } else if (collapse === 'end') {
            anchor = focus;
        }
        return this.showSelectionState(new ve.SelectionState({
            anchorNode: anchor.node,
            anchorOffset: anchor.offset,
            focusNode: focus.node,
            focusOffset: focus.offset,
            isCollapsed: !1
        }));
    }
    ;
    ve.ce.Surface.prototype.selectAnnotation = function(filter) {
        var annotations = this.annotationsAtModelSelection(filter);
        if (annotations.length) {
            this.selectNodeContents(annotations[0].$element[0]);
        }
    }
    ;
    ve.ce.Surface.prototype.annotationsAtModelSelection = function(filter, offset) {
        var nodeAndOffset, annotations = [], documentRange = this.getModel().getDocument().getDocumentRange();
        if (offset === undefined) {
            offset = this.getModel().getSelection().getCoveringRange().start;
        }
        if (offset > documentRange.start) {
            nodeAndOffset = this.getDocument().getNodeAndOffset(offset - 1);
            annotations = nodeAndOffset ? this.annotationsAtNode(nodeAndOffset.node, filter) : [];
        }
        if (offset < documentRange.end) {
            nodeAndOffset = this.getDocument().getNodeAndOffset(offset + 1);
            annotations = OO.unique(annotations.concat(nodeAndOffset ? this.annotationsAtNode(nodeAndOffset.node, filter) : []));
        }
        return annotations;
    }
    ;
    ve.ce.Surface.prototype.annotationsAtFocus = function(filter) {
        return this.annotationsAtNode(this.nativeSelection.focusNode, filter);
    }
    ;
    ve.ce.Surface.prototype.annotationsAtNode = function(node, filter) {
        var annotations = [];
        $(node).parents('.ve-ce-annotation').addBack('.ve-ce-annotation').each(function() {
            var view = $(this).data('view');
            if (view && (!filter || filter(view))) {
                annotations.push(view);
            }
        });
        return annotations;
    }
    ;
    ve.ce.Surface.prototype.getSelectionState = function(range) {
        var anchor, focus, from, to, dmDoc = this.getModel().getDocument();
        if (!range) {
            return ve.SelectionState.static.newNullSelection();
        }
        from = dmDoc.getNearestCursorOffset(range.from, range.isBackwards() ? 1 : -1);
        if (from === -1) {
            return ve.SelectionState.static.newNullSelection();
        }
        try {
            anchor = this.documentView.getNodeAndOffset(from);
        } catch (e) {
            return ve.SelectionState.static.newNullSelection();
        }
        if (range.isCollapsed()) {
            focus = anchor;
        } else {
            to = dmDoc.getNearestCursorOffset(range.to, range.isBackwards() ? -1 : 1);
            if (to === -1) {
                return ve.SelectionState.static.newNullSelection();
            }
            try {
                focus = this.documentView.getNodeAndOffset(to);
            } catch (e) {
                return ve.SelectionState.static.newNullSelection();
            }
        }
        return new ve.SelectionState({
            anchorNode: anchor.node,
            anchorOffset: anchor.offset,
            focusNode: focus.node,
            focusOffset: focus.offset,
            isBackwards: range.isBackwards()
        });
    }
    ;
    ve.ce.Surface.prototype.getNativeRange = function(range) {
        var selectionState;
        if (!range) {
            selectionState = new ve.SelectionState(this.nativeSelection);
        } else {
            selectionState = this.getSelectionState(range);
        }
        return selectionState.getNativeRange(this.getElementDocument());
    }
    ;
    ve.ce.Surface.prototype.appendHighlights = function($highlights, focused) {
        this.$highlightsBlurred.children().detach();
        if (focused) {
            this.$highlightsFocused.append($highlights);
        } else {
            this.$highlightsBlurred.append($highlights);
        }
    }
    ;
    ve.ce.Surface.prototype.getSurface = function() {
        return this.surface;
    }
    ;
    ve.ce.Surface.prototype.getModel = function() {
        return this.model;
    }
    ;
    ve.ce.Surface.prototype.getDocument = function() {
        return this.documentView;
    }
    ;
    ve.ce.Surface.prototype.isRenderingLocked = function() {
        return this.renderLocks > 0 && !this.readOnly;
    }
    ;
    ve.ce.Surface.prototype.incRenderLock = function() {
        this.renderLocks++;
    }
    ;
    ve.ce.Surface.prototype.decRenderLock = function() {
        this.renderLocks--;
    }
    ;
    ve.ce.Surface.prototype.afterRenderLock = function(callback) {
        setTimeout(callback);
    }
    ;
    ve.ce.Surface.prototype.changeModel = function(transactions, selection) {
        if (this.newModelSelection !== null) {
            throw new Error('Nested change of newModelSelection');
        }
        this.newModelSelection = selection;
        try {
            this.model.change(transactions, selection);
        } finally {
            this.newModelSelection = null;
        }
    }
    ;
    ve.ce.Surface.prototype.setContentBranchNodeChanged = function() {
        this.contentBranchNodeChanged = !0;
        this.clearKeyDownState();
    }
    ;
    ve.ce.Surface.prototype.setUnicorning = function(node) {
        if (this.setUnicorningRecursionGuard) {
            throw new Error('setUnicorning recursing');
        }
        if (this.unicorningNode && this.unicorningNode !== node) {
            this.setUnicorningRecursionGuard = !0;
            try {
                this.unicorningNode.renderContents();
            } finally {
                this.setUnicorningRecursionGuard = !1;
            }
        }
        this.unicorningNode = node;
    }
    ;
    ve.ce.Surface.prototype.setNotUnicorning = function(node) {
        if (this.unicorningNode === node) {
            this.unicorningNode = null;
        }
    }
    ;
    ve.ce.Surface.prototype.setNotUnicorningAll = function(node) {
        if (this.unicorningNode === node) {
            this.unicorningNode = null;
        }
        this.setUnicorning(null);
    }
    ;
    ve.ce.Surface.prototype.getSelectedModels = function() {
        var models, fragmentAfter, activeModels;
        if (!(this.model.selection instanceof ve.dm.LinearSelection)) {
            return [];
        }
        models = this.model.getFragment().getSelectedModels();
        if (this.model.selection.isCollapsed()) {
            fragmentAfter = this.model.getFragment(new ve.dm.LinearSelection(new ve.Range(this.model.selection.range.start,this.model.selection.range.start + 1)));
            models = OO.unique([].concat(models, fragmentAfter.getSelectedModels()));
        }
        activeModels = this.activeAnnotations.map(function(view) {
            return view.getModel();
        });
        if (this.model.sourceMode) {
            return models;
        } else {
            return models.filter(function(annModel) {
                if (annModel instanceof ve.dm.Annotation && ve.ce.annotationFactory.canAnnotationBeActive(annModel.getType())) {
                    return activeModels.indexOf(annModel) !== -1;
                }
                return true;
            });
        }
    }
    ;
    ve.ce.Surface.prototype.selectionSplitsNailedAnnotation = function() {
        return ve.ce.nailedAnnotationAt(this.nativeSelection.anchorNode) !== ve.ce.nailedAnnotationAt(this.nativeSelection.focusNode);
    }
    ;
    ve.ce.Surface.prototype.onSynchronizerAuthorUpdate = function(authorId) {
        this.paintAuthor(authorId);
    }
    ;
    ve.ce.Surface.prototype.onSynchronizerAuthorDisconnect = function(authorId) {
        var overlays = this.userSelectionOverlays[authorId];
        if (overlays) {
            overlays.$cursor.detach();
            overlays.$selection.detach();
            delete this.userSelectionOverlays[authorId];
        }
    }
    ;
    ve.ce.Surface.prototype.onSynchronizerWrongDoc = function() {
        OO.ui.alert(ve.msg('visualeditor-missing-document-error'), {
            title: ve.msg('visualeditor-missing-document-title')
        });
    }
    ;
    ve.ce.Surface.prototype.onSynchronizerPause = function() {
        this.$element.toggleClass('ve-ce-surface-paused', !!this.model.synchronizer.paused);
    }
    ;
    ve.ce.Surface.prototype.paintAuthor = function(authorId) {
        var i, l, rects, rect, overlays, color, synchronizer = this.model.synchronizer, authorData = synchronizer.getAuthorData(authorId), selection = synchronizer.authorSelections[authorId];
        if (!authorData || !selection || authorId === synchronizer.getAuthorId()) {
            return;
        }
        color = '#' + authorData.color;
        if (!this.userSelectionOverlays[authorId]) {
            this.userSelectionOverlays[authorId] = {
                $cursor: $('<div>'),
                $selection: $('<div>'),
                deactivateDebounced: ve.debounce(function() {
                    overlays.$cursor.addClass('ve-ce-surface-highlights-user-cursor-inactive');
                    overlays.$selection.addClass('ve-ce-surface-highlights-user-selection-inactive');
                }, 5000)
            };
        }
        overlays = this.userSelectionOverlays[authorId];
        if (!selection || selection.isNull()) {
            overlays.$cursor.detach();
            overlays.$selection.detach();
            return;
        }
        overlays.$cursor.empty().removeClass('ve-ce-surface-highlights-user-cursor-inactive');
        overlays.$selection.empty().removeClass('ve-ce-surface-highlights-user-selection-inactive');
        if (!selection.isCollapsed()) {
            rects = ve.ce.Selection.static.newFromModel(selection, this).getSelectionRects();
            for (i = 0,
            l = rects.length; i < l; i++) {
                rect = rects[i];
                overlays.$selection.append($('<div>').addClass('ve-ce-surface-highlights-user-selection').css({
                    left: rect.left,
                    top: rect.top,
                    width: rect.width,
                    height: rect.height,
                    background: color
                }));
            }
        }
        try {
            if (selection instanceof ve.dm.LinearSelection && this.getFocusedNode(selection.getRange())) {
                rect = ve.ce.Selection.static.newFromModel(selection, this).getSelectionBoundingRect();
            } else {
                rect = ve.ce.Selection.static.newFromModel(selection.collapseToTo(), this).getSelectionRects()[0];
            }
        } catch (e) {
            ve.error('User selection for ' + authorId + ' transformed out of bounds: ' + JSON.stringify(selection));
            return;
        }
        overlays.$cursor.append($('<div>').addClass('ve-ce-surface-highlights-user-cursor').css({
            left: rect.left,
            top: rect.top,
            height: rect.height,
            background: color
        }).append($('<span>').addClass('ve-ce-surface-highlights-user-cursor-label').text(authorData.name).css({
            background: color
        })));
        this.$highlightsUserCursors.append(overlays.$cursor);
        this.$highlightsUserSelections.append(overlays.$selection);
        overlays.deactivateDebounced();
    }
    ;
    ve.ce.Surface.prototype.onPosition = function() {
        var surface = this;
        this.updateDeactivatedSelection();
        if (this.model.synchronizer) {
            setTimeout(function() {
                var authorId, authorSelections = surface.model.synchronizer.authorSelections;
                for (authorId in authorSelections) {
                    surface.onSynchronizerAuthorUpdate(+authorId);
                }
            });
        }
    }
    ;
    ve.ce.SurfaceObserver = function VeCeSurfaceObserver(surface) {
        this.surface = surface;
        this.domDocument = surface.attachedRoot.getElementDocument();
        this.polling = !1;
        this.disabled = !1;
        this.timeoutId = null;
        this.pollInterval = 250;
        this.rangeState = null;
    }
    ;
    OO.initClass(ve.ce.SurfaceObserver);
    ve.ce.SurfaceObserver.prototype.clear = function() {
        this.rangeState = null;
    }
    ;
    ve.ce.SurfaceObserver.prototype.detach = function() {
        this.surface = null;
        this.domDocument = null;
        this.rangeState = null;
    }
    ;
    ve.ce.SurfaceObserver.prototype.startTimerLoop = function() {
        this.polling = !0;
        this.timerLoop(true);
    }
    ;
    ve.ce.SurfaceObserver.prototype.timerLoop = function(firstTime) {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        if (!firstTime) {
            this.pollOnce();
        }
        if (this.pollInterval !== null) {
            this.timeoutId = this.setTimeout(this.timerLoop.bind(this), this.pollInterval);
        }
    }
    ;
    ve.ce.SurfaceObserver.prototype.stopTimerLoop = function() {
        if (this.polling === true) {
            this.polling = !1;
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
    }
    ;
    ve.ce.SurfaceObserver.prototype.disable = function() {
        this.disabled = !0;
    }
    ;
    ve.ce.SurfaceObserver.prototype.enable = function() {
        this.disabled = !1;
    }
    ;
    ve.ce.SurfaceObserver.prototype.pollOnce = function() {
        this.pollOnceInternal(true);
    }
    ;
    ve.ce.SurfaceObserver.prototype.pollOnceNoCallback = function() {
        this.pollOnceInternal(false);
    }
    ;
    ve.ce.SurfaceObserver.prototype.pollOnceSelection = function() {
        this.pollOnceInternal(true, true);
    }
    ;
    ve.ce.SurfaceObserver.prototype.pollOnceInternal = function(signalChanges, selectionOnly) {
        var oldState, newState;
        if (!this.domDocument || this.disabled) {
            return;
        }
        oldState = this.rangeState;
        newState = new ve.ce.RangeState(oldState,this.surface.attachedRoot,selectionOnly);
        this.rangeState = newState;
        if (signalChanges && (newState.contentChanged || newState.branchNodeChanged || newState.selectionChanged)) {
            this.surface.handleObservedChanges(oldState, newState);
        }
    }
    ;
    ve.ce.SurfaceObserver.prototype.setTimeout = function(callback, timeout) {
        return setTimeout(callback, timeout);
    }
    ;
    ve.ce.SurfaceObserver.prototype.getRange = function() {
        if (!this.rangeState) {
            return null;
        }
        return this.rangeState.veRange;
    }
    ;
    ve.ce.KeyDownHandlerFactory = function VeCeKeyDownHandlerFactory() {
        ve.ce.KeyDownHandlerFactory.super.apply(this, arguments);
        this.handlerNamesByKeys = {};
    }
    ;
    OO.inheritClass(ve.ce.KeyDownHandlerFactory, OO.Factory);
    ve.ce.KeyDownHandlerFactory.prototype.register = function(constructor) {
        var i, ilen, keys, name;
        ve.ce.KeyDownHandlerFactory.super.prototype.register.call(this, constructor);
        keys = constructor.static.keys;
        name = constructor.static.name;
        for (i = 0,
        ilen = keys.length; i < ilen; i++) {
            this.handlerNamesByKeys[keys[i]] = this.handlerNamesByKeys[keys[i]] || [];
            if (this.handlerNamesByKeys[keys[i]].indexOf(name) === -1) {
                this.handlerNamesByKeys[keys[i]].push(name);
            }
        }
    }
    ;
    ve.ce.KeyDownHandlerFactory.prototype.lookupHandlersForKey = function(key, selectionName) {
        var i, constructor, supportedSelections, constructors = [], names = this.handlerNamesByKeys[key] || [];
        for (i = 0; i < names.length; i++) {
            constructor = this.registry[names[i]];
            supportedSelections = constructor.static.supportedSelections;
            if (!supportedSelections || supportedSelections.indexOf(selectionName) !== -1) {
                constructors.push(constructor);
            }
        }
        return constructors;
    }
    ;
    ve.ce.KeyDownHandlerFactory.prototype.executeHandlersForKey = function(key, selectionName, surface, e) {
        var i, acted = !1, handlers = this.lookupHandlersForKey(key, selectionName);
        for (i = 0; i < handlers.length; i++) {
            if (handlers[i].static.execute(surface, e)) {
                acted = !0;
            }
        }
        return acted;
    }
    ;
    ve.ce.keyDownHandlerFactory = new ve.ce.KeyDownHandlerFactory();
    ve.ce.KeyDownHandler = function VeCeKeyDownHandler() {}
    ;
    OO.initClass(ve.ce.KeyDownHandler);
    ve.ce.KeyDownHandler.static.name = null;
    ve.ce.KeyDownHandler.static.keys = [];
    ve.ce.KeyDownHandler.static.supportedSelections = null;
    ve.ce.KeyDownHandler.static.execute = null;
    ve.ce.LinearSelection = function VeCeLinearSelection() {
        ve.ce.LinearSelection.super.apply(this, arguments);
        this.focusedNode = this.getSurface().getFocusedNode(this.getModel().getRange());
        this.directionality = null;
    }
    ;
    OO.inheritClass(ve.ce.LinearSelection, ve.ce.Selection);
    ve.ce.LinearSelection.static.name = 'linear';
    ve.ce.LinearSelection.prototype.getSelectionRects = function() {
        var i, l, range, nativeRange, surfaceRect, focusedNode, rect, surface = this.getSurface(), rects = [], relativeRects = [];
        range = this.getModel().getRange();
        focusedNode = surface.getFocusedNode(range);
        if (focusedNode) {
            return focusedNode.getRects();
        }
        nativeRange = surface.getNativeRange(range);
        if (!nativeRange) {
            return null;
        }
        try {
            rects = RangeFix.getClientRects(nativeRange);
            if (!rects.length) {
                throw new Error('getClientRects returned empty list');
            }
        } catch (e) {
            rect = this.getNodeClientRectFromRange(nativeRange);
            if (rect) {
                rects = [rect];
            }
        }
        surfaceRect = surface.getSurface().getBoundingClientRect();
        if (!rects || !surfaceRect) {
            return null;
        }
        for (i = 0,
        l = rects.length; i < l; i++) {
            relativeRects.push(ve.translateRect(rects[i], -surfaceRect.left, -surfaceRect.top));
        }
        return relativeRects;
    }
    ;
    ve.ce.LinearSelection.prototype.getSelectionStartAndEndRects = function() {
        var range, focusedNode, surface = this.getSurface();
        range = this.getModel().getRange();
        focusedNode = surface.getFocusedNode(range);
        if (focusedNode) {
            return focusedNode.getStartAndEndRects();
        }
        return ve.getStartAndEndRects(this.getSelectionRects());
    }
    ;
    ve.ce.LinearSelection.prototype.getSelectionBoundingRect = function() {
        var range, nativeRange, boundingRect, surfaceRect, focusedNode, surface = this.getSurface();
        range = this.getModel().getRange();
        focusedNode = surface.getFocusedNode(range);
        if (focusedNode) {
            return focusedNode.getBoundingRect();
        }
        nativeRange = surface.getNativeRange(range);
        if (!nativeRange) {
            return null;
        }
        try {
            boundingRect = RangeFix.getBoundingClientRect(nativeRange);
        } catch (e) {
            boundingRect = null;
        }
        if (!boundingRect) {
            boundingRect = this.getNodeClientRectFromRange(nativeRange);
        }
        surfaceRect = surface.getSurface().getBoundingClientRect();
        if (!boundingRect || !surfaceRect) {
            return null;
        }
        return ve.translateRect(boundingRect, -surfaceRect.left, -surfaceRect.top);
    }
    ;
    ve.ce.LinearSelection.prototype.getNodeClientRectFromRange = function(range) {
        var rect, side, x, adjacentNode, unicornRect, annotationNode, fixHeight, middle, node, containerNode = range.endContainer, offset = range.endOffset;
        if (containerNode.nodeType === Node.TEXT_NODE && (offset === 0 || offset === containerNode.length)) {
            node = offset ? containerNode.previousSibling : containerNode.nextSibling;
        } else if (containerNode.nodeType === Node.ELEMENT_NODE) {
            node = offset === containerNode.childNodes.length ? containerNode.lastChild : containerNode.childNodes[offset];
            if (node && node.nodeType === Node.ELEMENT_NODE && node.classList.contains('ve-ce-nail')) {
                annotationNode = offset ? node.previousSibling : node.nextSibling;
                fixHeight = annotationNode.offsetHeight;
            }
        } else {
            node = containerNode;
        }
        while (node && node.nodeType !== Node.ELEMENT_NODE) {
            node = node.parentNode;
        }
        if (!node) {
            return null;
        }
        rect = node.getClientRects()[0];
        if (!rect) {
            return null;
        }
        side = $(node).css('direction') === 'rtl' ? 'right' : 'left';
        adjacentNode = range.endContainer.childNodes[range.endOffset];
        if (range.collapsed && adjacentNode && adjacentNode.classList && adjacentNode.classList.contains('ve-ce-unicorn')) {
            unicornRect = adjacentNode.getClientRects()[0];
            if (!unicornRect) {
                return null;
            }
            x = unicornRect[side];
        } else {
            x = rect[side];
        }
        if (fixHeight) {
            middle = (rect.top + rect.bottom) / 2;
            return {
                top: middle - (fixHeight / 2),
                bottom: middle + (fixHeight / 2),
                left: x,
                right: x,
                width: 0,
                height: fixHeight
            };
        } else {
            return {
                top: rect.top,
                bottom: rect.bottom,
                left: x,
                right: x,
                width: 0,
                height: rect.height
            };
        }
    }
    ;
    ve.ce.LinearSelection.prototype.getSelectionFocusRect = function() {
        return !this.isNativeCursor() ? this.getSelectionBoundingRect() : ve.ce.LinearSelection.super.prototype.getSelectionFocusRect.call(this);
    }
    ;
    ve.ce.LinearSelection.prototype.isFocusedNode = function() {
        return !!this.focusedNode;
    }
    ;
    ve.ce.LinearSelection.prototype.isNativeCursor = function() {
        return !this.focusedNode;
    }
    ;
    ve.ce.LinearSelection.prototype.getDirectionality = function(doc) {
        if (!this.directionality) {
            this.directionality = doc.getDirectionalityFromRange(this.getModel().getRange());
        }
        return this.directionality;
    }
    ;
    ve.ce.selectionFactory.register(ve.ce.LinearSelection);
    ve.ce.NullSelection = function VeCeNullSelection() {
        ve.ce.NullSelection.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ce.NullSelection, ve.ce.Selection);
    ve.ce.NullSelection.static.name = 'null';
    ve.ce.NullSelection.prototype.getSelectionRects = function() {
        return null;
    }
    ;
    ve.ce.NullSelection.prototype.getSelectionStartAndEndRects = function() {
        return null;
    }
    ;
    ve.ce.NullSelection.prototype.getSelectionBoundingRect = function() {
        return null;
    }
    ;
    ve.ce.NullSelection.prototype.isFocusedNode = function() {
        return false;
    }
    ;
    ve.ce.NullSelection.prototype.isNativeCursor = function() {
        return false;
    }
    ;
    ve.ce.NullSelection.prototype.getDirectionality = function(doc) {
        return doc.getDir();
    }
    ;
    ve.ce.selectionFactory.register(ve.ce.NullSelection);
    ve.ce.TableSelection = function VeCeTableSelection() {
        ve.ce.TableSelection.super.apply(this, arguments);
        this.directionality = null;
    }
    ;
    OO.inheritClass(ve.ce.TableSelection, ve.ce.Selection);
    ve.ce.TableSelection.static.name = 'table';
    ve.ce.TableSelection.prototype.getSelectionRects = function() {
        return [this.getSelectionBoundingRect()];
    }
    ;
    ve.ce.TableSelection.prototype.getSelectionBoundingRect = function() {
        var i, l, cellNode, cellOffset, top, bottom, left, right, boundingRect, surface = this.getSurface(), tableNode = surface.getDocument().getBranchNodeFromOffset(this.model.tableRange.start + 1), nodes = tableNode.getCellNodesFromSelection(this.getModel()), surfaceRect = surface.getSurface().getBoundingClientRect();
        top = Infinity;
        bottom = -Infinity;
        left = Infinity;
        right = -Infinity;
        for (i = 0,
        l = nodes.length; i < l; i++) {
            cellNode = nodes[i].$element[0];
            if (!cellNode) {
                return null;
            }
            cellOffset = cellNode.getBoundingClientRect();
            top = Math.min(top, cellOffset.top);
            bottom = Math.max(bottom, cellOffset.bottom);
            left = Math.min(left, cellOffset.left);
            right = Math.max(right, cellOffset.right);
        }
        if (!ve.test) {
            switch ($.client.profile().layout) {
            case 'webkit':
                right += 1;
                bottom += 1;
                break;
            case 'gecko':
                left -= 1;
                top -= 1;
                break;
            }
        }
        boundingRect = {
            top: top,
            bottom: bottom,
            left: left,
            right: right,
            width: right - left,
            height: bottom - top
        };
        if (!boundingRect || !surfaceRect) {
            return null;
        }
        return ve.translateRect(boundingRect, -surfaceRect.left, -surfaceRect.top);
    }
    ;
    ve.ce.TableSelection.prototype.getTableBoundingRect = function() {
        var boundingRect, surface = this.getSurface(), tableNode = surface.getDocument().getBranchNodeFromOffset(this.model.tableRange.start + 1), surfaceRect = surface.getSurface().getBoundingClientRect();
        if (!tableNode) {
            return null;
        }
        boundingRect = tableNode.$element[0].getBoundingClientRect();
        if (!boundingRect || !surfaceRect) {
            return null;
        }
        return ve.translateRect(boundingRect, -surfaceRect.left, -surfaceRect.top);
    }
    ;
    ve.ce.TableSelection.prototype.isFocusedNode = function() {
        return true;
    }
    ;
    ve.ce.TableSelection.prototype.isNativeCursor = function() {
        return false;
    }
    ;
    ve.ce.TableSelection.prototype.getDirectionality = function(doc) {
        if (!this.directionality) {
            this.directionality = doc.getDirectionalityFromRange(this.getModel().tableRange);
        }
        return this.directionality;
    }
    ;
    ve.ce.selectionFactory.register(ve.ce.TableSelection);
    ve.ce.LinearArrowKeyDownHandler = function VeCeLinearArrowKeyDownHandler() {}
    ;
    OO.inheritClass(ve.ce.LinearArrowKeyDownHandler, ve.ce.KeyDownHandler);
    ve.ce.LinearArrowKeyDownHandler.static.name = 'linearArrow';
    ve.ce.LinearArrowKeyDownHandler.static.keys = [OO.ui.Keys.UP, OO.ui.Keys.DOWN, OO.ui.Keys.LEFT, OO.ui.Keys.RIGHT, OO.ui.Keys.HOME, OO.ui.Keys.END, OO.ui.Keys.PAGEUP, OO.ui.Keys.PAGEDOWN];
    ve.ce.LinearArrowKeyDownHandler.static.supportedSelections = ['linear'];
    ve.ce.LinearArrowKeyDownHandler.static.execute = function(surface, e) {
        var nativeRange, collapseNode, collapseOffset, direction, directionality, startFocusNode, startFocusOffset, isBlockMove = e.keyCode === OO.ui.Keys.UP || e.keyCode === OO.ui.Keys.DOWN || e.keyCode === OO.ui.Keys.PAGEUP || e.keyCode === OO.ui.Keys.PAGEDOWN || e.keyCode === OO.ui.Keys.HOME || e.keyCode === OO.ui.Keys.END, keyBlockDirection = e.keyCode === OO.ui.Keys.DOWN || e.keyCode === OO.ui.Keys.PAGEDOWN || e.keyCode === OO.ui.Keys.END ? 1 : -1, range = surface.model.getSelection().getRange(), activeNode = surface.getActiveNode();
        surface.surfaceObserver.stopTimerLoop();
        surface.surfaceObserver.pollOnce();
        if (surface.focusedBlockSlug) {
            if (isBlockMove) {
                direction = keyBlockDirection;
            } else {
                directionality = $(surface.focusedBlockSlug).css('direction');
                if (e.keyCode === OO.ui.Keys.LEFT ^ directionality === 'rtl') {
                    direction = -1;
                } else {
                    direction = 1;
                }
            }
            range = surface.model.getDocument().getRelativeRange(range, direction, 'character', e.shiftKey, activeNode && (e.shiftKey || activeNode.trapsCursor()) ? activeNode.getRange() : null);
            surface.model.setLinearSelection(range);
            e.preventDefault();
            return true;
        }
        if (surface.focusedNode) {
            if (isBlockMove) {
                direction = keyBlockDirection;
            } else {
                directionality = surface.getFocusedNodeDirectionality();
                if (e.keyCode === OO.ui.Keys.LEFT ^ directionality === 'rtl') {
                    direction = -1;
                } else {
                    direction = 1;
                }
            }
            if (!surface.focusedNode.isContent()) {
                range = surface.model.getDocument().getRelativeRange(range, direction, 'character', e.shiftKey, activeNode && (e.shiftKey || activeNode.trapsCursor()) ? activeNode.getRange() : null);
                surface.model.setLinearSelection(range);
                e.preventDefault();
                return true;
            }
            if (e.shiftKey) {
                if (direction === -1 ^ range.isBackwards()) {
                    range = range.flip();
                }
                surface.model.setLinearSelection(new ve.Range(range.to));
            } else {
                range = new ve.Range(direction === 1 ? range.end : range.start);
                surface.model.setLinearSelection(range);
                if (!isBlockMove) {
                    e.preventDefault();
                    return true;
                }
            }
        }
        if (e.shiftKey && !ve.supportsSelectionExtend && range.isBackwards()) {
            collapseNode = surface.nativeSelection.anchorNode;
            collapseOffset = surface.nativeSelection.anchorOffset;
        } else if (e.shiftKey && !range.isCollapsed() && isBlockMove) {
            collapseNode = surface.nativeSelection.focusNode;
            collapseOffset = surface.nativeSelection.focusOffset;
        }
        if (collapseNode) {
            nativeRange = surface.getElementDocument().createRange();
            nativeRange.setStart(collapseNode, collapseOffset);
            nativeRange.setEnd(collapseNode, collapseOffset);
            surface.nativeSelection.removeAllRanges();
            surface.nativeSelection.addRange(nativeRange);
        }
        startFocusNode = surface.nativeSelection.focusNode;
        startFocusOffset = surface.nativeSelection.focusOffset;
        surface.eventSequencer.afterOne({
            keydown: function() {
                var viewNode, newRange, afterDirection;
                viewNode = $(surface.nativeSelection.focusNode).closest('.ve-ce-leafNode,.ve-ce-branchNode').data('view');
                if (!viewNode) {
                    return;
                }
                if (viewNode.isFocusable()) {
                    if (isBlockMove) {
                        afterDirection = keyBlockDirection;
                    } else {
                        afterDirection = ve.compareDocumentOrder(surface.nativeSelection.focusNode, surface.nativeSelection.focusOffset, startFocusNode, startFocusOffset);
                    }
                    newRange = (afterDirection > 0 ? viewNode.getOuterRange() : viewNode.getOuterRange().flip());
                } else {
                    surface.surfaceObserver.pollOnceNoCallback();
                    newRange = new ve.Range(surface.surfaceObserver.getRange().to);
                }
                if (e.shiftKey) {
                    newRange = new ve.Range(range.from,newRange.to);
                    surface.getModel().setLinearSelection(newRange);
                }
                surface.updateActiveAnnotations();
                surface.surfaceObserver.pollOnce();
            }
        });
        return true;
    }
    ;
    ve.ce.keyDownHandlerFactory.register(ve.ce.LinearArrowKeyDownHandler);
    ve.ce.LinearDeleteKeyDownHandler = function VeCeLinearDeleteKeyDownHandler() {}
    ;
    OO.inheritClass(ve.ce.LinearDeleteKeyDownHandler, ve.ce.KeyDownHandler);
    ve.ce.LinearDeleteKeyDownHandler.static.name = 'linearDelete';
    ve.ce.LinearDeleteKeyDownHandler.static.keys = [OO.ui.Keys.BACKSPACE, OO.ui.Keys.DELETE];
    ve.ce.LinearDeleteKeyDownHandler.static.supportedSelections = ['linear'];
    ve.ce.LinearDeleteKeyDownHandler.static.execute = function(surface, e) {
        var docLength, startNode, position, skipNode, pairNode, linkNode, range, documentModelSelectedNodes, i, node, nodeRange, nodeOuterRange, matrix, col, row, direction = e.keyCode === OO.ui.Keys.DELETE ? 1 : -1, unit = (e.altKey === true || e.ctrlKey === true) ? 'word' : 'character', offset = 0, rangeToRemove = surface.getModel().getSelection().getRange(), documentModel = surface.getModel().getDocument(), data = documentModel.data;
        if (surface.isReadOnly()) {
            e.preventDefault();
            return true;
        }
        if (direction === 1 && e.shiftKey && ve.getSystemPlatform() !== 'mac') {
            return false;
        }
        if (rangeToRemove.isCollapsed() && !e.ctrlKey) {
            position = ve.adjacentDomPosition({
                node: surface.nativeSelection.focusNode,
                offset: surface.nativeSelection.focusOffset
            }, direction, {
                stop: ve.isHardCursorStep
            });
            skipNode = position.steps[position.steps.length - 1].node;
            if (skipNode.nodeType === Node.TEXT_NODE) {
                surface.eventSequencer.afterOne({
                    keydown: surface.surfaceObserver.pollOnce.bind(surface.surfaceObserver)
                });
                return true;
            }
            if (direction > 0 ? skipNode.classList.contains('ve-ce-nail-pre-open') : skipNode.classList.contains('ve-ce-nail-post-close')) {
                position = ve.adjacentDomPosition(position, direction, {
                    stop: ve.isHardCursorStep
                });
                range = document.createRange();
                range.setStart(position.node, position.offset);
                surface.nativeSelection.removeAllRanges();
                surface.nativeSelection.addRange(range);
                surface.updateActiveAnnotations();
                e.preventDefault();
                return true;
            }
            if (skipNode.classList && skipNode.classList.contains(direction > 0 ? 've-ce-nail-pre-close' : 've-ce-nail-post-open') && (pairNode = (direction > 0 ? skipNode.previousSibling : skipNode.nextSibling)) && pairNode.classList && pairNode.classList.contains(direction > 0 ? 've-ce-nail-post-open' : 've-ce-nail-pre-close')) {
                linkNode = skipNode.parentNode;
                range = document.createRange();
                range.setStart(linkNode.parentNode, ve.parentIndex(linkNode) - 1);
                linkNode.parentNode.removeChild(linkNode.previousSibling);
                linkNode.parentNode.removeChild(linkNode.nextSibling);
                linkNode.parentNode.removeChild(linkNode);
                surface.nativeSelection.removeAllRanges();
                surface.nativeSelection.addRange(range);
                surface.updateActiveAnnotations();
                e.preventDefault();
                return true;
            }
            if (direction > 0 ? skipNode.classList.contains('ve-ce-nail-pre-close') : skipNode.classList.contains('ve-ce-nail-post-open')) {
                position = ve.adjacentDomPosition(position, direction, {
                    stop: ve.isHardCursorStep
                });
                range = document.createRange();
                range.setStart(position.node, position.offset);
                surface.nativeSelection.removeAllRanges();
                surface.nativeSelection.addRange(range);
                surface.updateActiveAnnotations();
                e.preventDefault();
                return true;
            }
            offset = rangeToRemove.start;
            if (!e.ctrlKey && ((direction < 0 && !data.isElementData(offset - 1)) || (direction > 0 && !data.isElementData(offset)))) {
                surface.eventSequencer.afterOne({
                    keydown: surface.surfaceObserver.pollOnce.bind(surface.surfaceObserver)
                });
                return true;
            }
        }
        if (rangeToRemove.isCollapsed()) {
            rangeToRemove = documentModel.getRelativeRange(rangeToRemove, direction, unit, true);
            if (surface.getActiveNode() && !surface.getActiveNode().getRange().containsRange(rangeToRemove)) {
                e.preventDefault();
                return true;
            }
            documentModelSelectedNodes = documentModel.selectNodes(rangeToRemove, 'siblings');
            for (i = 0; i < documentModelSelectedNodes.length; i++) {
                node = documentModelSelectedNodes[i].node;
                nodeOuterRange = documentModelSelectedNodes[i].nodeOuterRange;
                if (node instanceof ve.dm.TableNode) {
                    if (rangeToRemove.containsOffset(nodeOuterRange.start)) {
                        surface.getModel().setSelection(new ve.dm.TableSelection(nodeOuterRange,0,0));
                    } else {
                        matrix = node.getMatrix();
                        row = matrix.getRowCount() - 1;
                        col = matrix.getColCount(row) - 1;
                        surface.getModel().setSelection(new ve.dm.TableSelection(nodeOuterRange,col,row));
                    }
                    e.preventDefault();
                    return true;
                }
            }
            offset = rangeToRemove.start;
            docLength = documentModel.getDocumentRange().getLength();
            if (offset < docLength - 1) {
                while (offset < docLength - 1 && data.isCloseElementData(offset)) {
                    offset++;
                }
                startNode = documentModel.getDocumentNode().getNodeFromOffset(offset + 1);
                if (startNode.isFocusable()) {
                    surface.getModel().setLinearSelection(startNode.getOuterRange());
                    e.preventDefault();
                    return true;
                }
            }
            if (rangeToRemove.isCollapsed()) {
                startNode = documentModel.getDocumentNode().getNodeFromOffset(offset - 1);
                nodeRange = startNode.getOuterRange();
                if (!startNode.isUnwrappable() || ((startNode.canContainContent() || surface.attachedRoot === startNode) && (nodeRange.start === 0 || nodeRange.end === docLength))) {
                    e.preventDefault();
                    return true;
                } else {
                    switch (startNode.getType()) {
                    case 'list':
                        rangeToRemove = new ve.Range(nodeRange.start,nodeRange.start + 2);
                        break;
                    case 'listItem':
                        rangeToRemove = new ve.Range(nodeRange.start,nodeRange.start + 1);
                        break;
                    default:
                        if (direction > 0) {
                            rangeToRemove = new ve.Range(rangeToRemove.start,nodeRange.end);
                        } else {
                            rangeToRemove = new ve.Range(nodeRange.start,rangeToRemove.start - 1);
                        }
                    }
                }
            }
        }
        surface.getModel().getLinearFragment(rangeToRemove, true).delete(direction).select();
        surface.focus();
        surface.surfaceObserver.clear();
        e.preventDefault();
        return true;
    }
    ;
    ve.ce.keyDownHandlerFactory.register(ve.ce.LinearDeleteKeyDownHandler);
    ve.ce.LinearEnterKeyDownHandler = function VeCeLinearEnterKeyDownHandler() {}
    ;
    OO.inheritClass(ve.ce.LinearEnterKeyDownHandler, ve.ce.KeyDownHandler);
    ve.ce.LinearEnterKeyDownHandler.static.name = 'linearEnter';
    ve.ce.LinearEnterKeyDownHandler.static.keys = [OO.ui.Keys.ENTER];
    ve.ce.LinearEnterKeyDownHandler.static.supportedSelections = ['linear'];
    ve.ce.LinearEnterKeyDownHandler.static.execute = function(surface, e) {
        var txRemove, txInsert, outerParent, outerChildrenCount, container, prevContentOffset, insertEmptyParagraph, node, focusedNode, splitData, range = surface.model.getSelection().getRange(), cursor = range.from, documentModel = surface.model.getDocument(), emptyParagraph = [{
            type: 'paragraph'
        }, {
            type: '/paragraph'
        }], advanceCursor = !0, outermostNode = null, nodeModel = null, nodeModelRange = null;
        e.preventDefault();
        if (e.ctrlKey || e.metaKey) {
            return false;
        }
        focusedNode = surface.getFocusedNode();
        if (focusedNode) {
            if (focusedNode.getModel().isEditable()) {
                focusedNode.executeCommand();
            }
            return true;
        }
        if (surface.isReadOnly()) {
            return true;
        }
        node = surface.getDocument().getBranchNodeFromOffset(range.from);
        if (!node.isMultiline()) {
            return true;
        }
        if (!range.isCollapsed()) {
            txRemove = ve.dm.TransactionBuilder.static.newFromRemoval(documentModel, range);
            range = txRemove.translateRange(range);
            surface.model.change(txRemove, new ve.dm.LinearSelection(range));
            node = surface.getDocument().getBranchNodeFromOffset(range.from);
        }
        if (node !== null) {
            nodeModel = node.getModel();
            nodeModelRange = nodeModel.getRange();
        }
        if (node === null) {
            throw new Error('node === null');
        } else if (nodeModel.getType() !== 'paragraph' && (cursor === nodeModelRange.from || cursor === nodeModelRange.to)) {
            if (cursor === nodeModelRange.to) {
                txInsert = ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, nodeModel.getOuterRange().to, emptyParagraph);
            } else if (cursor === nodeModelRange.from) {
                txInsert = ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, nodeModel.getOuterRange().from, emptyParagraph);
                advanceCursor = !1;
            }
        } else if (e.shiftKey && nodeModel.hasSignificantWhitespace()) {
            txInsert = ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, range.from, '\n');
        } else if (!node.splitOnEnter()) {
            insertEmptyParagraph = !1;
            if (documentModel.hasSlugAtOffset(range.from)) {
                insertEmptyParagraph = !0;
            } else {
                prevContentOffset = documentModel.data.getNearestContentOffset(cursor, -1);
                if (prevContentOffset === -1) {
                    insertEmptyParagraph = !0;
                }
            }
            if (insertEmptyParagraph) {
                txInsert = ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, cursor, emptyParagraph);
            } else {
                cursor = prevContentOffset;
                node = surface.documentView.getBranchNodeFromOffset(cursor);
                txInsert = undefined;
            }
            insertEmptyParagraph = undefined;
        }
        function getSplitData(node) {
            var stack = [];
            node.traverseUpstream(function(node) {
                if (!node.splitOnEnter()) {
                    return false;
                }
                stack.splice(stack.length / 2, 0, {
                    type: '/' + node.type
                }, node.getModel().getClonedElement());
                outermostNode = node;
                if (e.shiftKey) {
                    return false;
                } else {
                    return true;
                }
            });
            return stack;
        }
        if (txInsert === undefined) {
            splitData = getSplitData(node);
            outerParent = outermostNode.getParent();
            outerChildrenCount = outerParent.getChildren().length;
            if (outerParent.removeEmptyLastChildOnEnter() && outerParent.getChildren()[outerChildrenCount - 1] === outermostNode && ((outermostNode.children.length === 1 && node.getModel().length === 0) || (outermostNode.canContainContent() && outermostNode.getModel().length === 0))) {
                container = outerParent.getParent();
                advanceCursor = !1;
                if (outerChildrenCount === 1) {
                    txInsert = ve.dm.TransactionBuilder.static.newFromRemoval(documentModel, outerParent.getOuterRange());
                } else {
                    txInsert = ve.dm.TransactionBuilder.static.newFromRemoval(documentModel, outermostNode.getOuterRange());
                }
                surface.model.change(txInsert);
                range = txInsert.translateRange(range);
                if (container.splitOnEnter()) {
                    splitData = getSplitData(container).concat(emptyParagraph);
                    txInsert = ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, container.getOuterRange().to - 1, splitData);
                } else if (outerParent.getChildren().length) {
                    txInsert = ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, outerParent.getOuterRange().to, emptyParagraph);
                } else {
                    txInsert = null;
                }
                advanceCursor = !0;
            } else {
                txInsert = ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, range.from, splitData);
            }
        }
        if (txInsert) {
            surface.model.change(txInsert);
            range = txInsert.translateRange(range);
        }
        if (advanceCursor) {
            cursor = documentModel.data.getRelativeContentOffset(range.from, 1);
        } else {
            cursor = documentModel.data.getNearestContentOffset(range.from);
        }
        if (cursor === -1) {
            surface.model.change(ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, range.from, emptyParagraph));
            surface.model.setLinearSelection(new ve.Range(range.from + 1));
        } else {
            surface.model.setLinearSelection(new ve.Range(cursor));
        }
        surface.surfaceObserver.clear();
        setTimeout(function() {
            surface.checkSequences();
        });
        return true;
    }
    ;
    ve.ce.keyDownHandlerFactory.register(ve.ce.LinearEnterKeyDownHandler);
    ve.ce.LinearEscapeKeyDownHandler = function VeCeLinearEscapeKeyDownHandler() {}
    ;
    OO.inheritClass(ve.ce.LinearEscapeKeyDownHandler, ve.ce.KeyDownHandler);
    ve.ce.LinearEscapeKeyDownHandler.static.name = 'linearEscape';
    ve.ce.LinearEscapeKeyDownHandler.static.keys = [OO.ui.Keys.ESCAPE];
    ve.ce.LinearEscapeKeyDownHandler.static.supportedSelections = ['linear'];
    ve.ce.LinearEscapeKeyDownHandler.static.execute = function(surface, e) {
        var activeTableNode = surface.getActiveNode() && surface.getActiveNode().findParent(ve.ce.TableNode);
        if (activeTableNode) {
            e.preventDefault();
            e.stopPropagation();
            activeTableNode.setEditing(false);
            surface.getModel().setSelection(surface.getModel().getSelection().collapseToStart());
            return true;
        }
        return false;
    }
    ;
    ve.ce.keyDownHandlerFactory.register(ve.ce.LinearEscapeKeyDownHandler);
    ve.ce.TableArrowKeyDownHandler = function VeCeTableArrowKeyDownHandler() {}
    ;
    OO.inheritClass(ve.ce.TableArrowKeyDownHandler, ve.ce.KeyDownHandler);
    ve.ce.TableArrowKeyDownHandler.static.name = 'tableArrow';
    ve.ce.TableArrowKeyDownHandler.static.keys = [OO.ui.Keys.UP, OO.ui.Keys.DOWN, OO.ui.Keys.LEFT, OO.ui.Keys.RIGHT, OO.ui.Keys.HOME, OO.ui.Keys.END, OO.ui.Keys.PAGEUP, OO.ui.Keys.PAGEDOWN, OO.ui.Keys.TAB];
    ve.ce.TableArrowKeyDownHandler.static.supportedSelections = ['table'];
    ve.ce.TableArrowKeyDownHandler.static.execute = function(surface, e) {
        var wrap = !1
          , checkDir = !1
          , colOffset = 0
          , rowOffset = 0
          , expand = e.shiftKey;
        if (e.ctrlKey || e.altKey || e.metaKey) {
            return;
        }
        switch (e.keyCode) {
        case OO.ui.Keys.LEFT:
            colOffset = -1;
            checkDir = !0;
            break;
        case OO.ui.Keys.RIGHT:
            colOffset = 1;
            checkDir = !0;
            break;
        case OO.ui.Keys.UP:
            rowOffset = -1;
            break;
        case OO.ui.Keys.DOWN:
            rowOffset = 1;
            break;
        case OO.ui.Keys.HOME:
            colOffset = -Infinity;
            break;
        case OO.ui.Keys.END:
            colOffset = Infinity;
            break;
        case OO.ui.Keys.PAGEUP:
            rowOffset = -Infinity;
            break;
        case OO.ui.Keys.PAGEDOWN:
            rowOffset = Infinity;
            break;
        case OO.ui.Keys.TAB:
            colOffset = e.shiftKey ? -1 : 1;
            expand = !1;
            wrap = !0;
            break;
        }
        e.preventDefault();
        this.moveTableSelection(surface, rowOffset, colOffset, checkDir, expand, wrap);
        return true;
    }
    ;
    ve.ce.TableArrowKeyDownHandler.static.moveTableSelection = function(surface, rowOffset, colOffset, checkDir, expand, wrap) {
        var tableNode, newSelection, documentModel, captionNode, selection = surface.getModel().getSelection();
        if (colOffset && checkDir) {
            tableNode = surface.documentView.getBranchNodeFromOffset(selection.tableRange.start + 1);
            if (tableNode.$element.css('direction') !== 'ltr') {
                colOffset *= -1;
            }
        }
        if (!expand) {
            selection = selection.collapseToFrom();
        }
        function adjust() {
            newSelection = selection.newFromAdjustment(surface.getModel().getDocument(), expand ? 0 : colOffset, expand ? 0 : rowOffset, colOffset, rowOffset, wrap);
        }
        adjust();
        if (wrap && colOffset > 0 && selection.equals(newSelection)) {
            surface.getSurface().execute('table', 'insert', 'row', 'after');
            selection = surface.getModel().getSelection();
            adjust();
        }
        if ((rowOffset !== 0 || (rowOffset === 0 && colOffset === -1 && wrap)) && selection.equals(newSelection)) {
            documentModel = surface.getModel().getDocument();
            if ((rowOffset === -1 || (colOffset === -1 && wrap)) && (captionNode = selection.getTableNode(documentModel).getCaptionNode())) {
                newSelection = new ve.dm.LinearSelection(documentModel.getRelativeRange(new ve.Range(captionNode.getRange().start), 1));
            } else {
                newSelection = new ve.dm.LinearSelection(documentModel.getRelativeRange(selection.tableRange, rowOffset || colOffset));
            }
        }
        surface.getModel().setSelection(newSelection);
    }
    ;
    ve.ce.keyDownHandlerFactory.register(ve.ce.TableArrowKeyDownHandler);
    ve.ce.TableDeleteKeyDownHandler = function VeCeTableDeleteKeyDownHandler() {}
    ;
    OO.inheritClass(ve.ce.TableDeleteKeyDownHandler, ve.ce.KeyDownHandler);
    ve.ce.TableDeleteKeyDownHandler.static.name = 'tableDelete';
    ve.ce.TableDeleteKeyDownHandler.static.keys = [OO.ui.Keys.BACKSPACE, OO.ui.Keys.DELETE];
    ve.ce.TableDeleteKeyDownHandler.static.supportedSelections = ['table'];
    ve.ce.TableDeleteKeyDownHandler.static.execute = function(surface, e) {
        var i, l, surfaceModel = surface.getModel(), documentModel = surfaceModel.getDocument(), fragments = [], cells = surfaceModel.getSelection().getMatrixCells(documentModel);
        if (e) {
            e.preventDefault();
        }
        if (surface.isReadOnly()) {
            return true;
        }
        for (i = 0,
        l = cells.length; i < l; i++) {
            if (cells[i].node.isCellEditable()) {
                fragments.push(surfaceModel.getLinearFragment(cells[i].node.getRange(), true));
            }
        }
        for (i = 0,
        l = fragments.length; i < l; i++) {
            fragments[i].insertContent([{
                type: 'paragraph',
                internal: {
                    generated: 'wrapper'
                }
            }, {
                type: '/paragraph'
            }]);
        }
        return true;
    }
    ;
    ve.ce.keyDownHandlerFactory.register(ve.ce.TableDeleteKeyDownHandler);
    ve.ce.LinearTabKeyDownHandler = function VeCeLinearTabKeyDownHandler() {}
    ;
    OO.inheritClass(ve.ce.LinearTabKeyDownHandler, ve.ce.KeyDownHandler);
    ve.ce.LinearTabKeyDownHandler.static.name = 'linearTab';
    ve.ce.LinearTabKeyDownHandler.static.keys = [OO.ui.Keys.TAB];
    ve.ce.LinearTabKeyDownHandler.static.supportedSelections = ['linear'];
    ve.ce.LinearTabKeyDownHandler.static.execute = function(surface, e) {
        var activeTableNode = surface.getActiveNode() && surface.getActiveNode().findParent(ve.ce.TableNode)
          , activeTableCaptionNode = surface.getActiveNode() && surface.getActiveNode().findParent(ve.ce.TableCaptionNode)
          , documentModel = surface.getModel().getDocument();
        if (activeTableNode) {
            if (e.ctrlKey || e.altKey || e.metaKey) {
                return;
            }
            if (activeTableNode.editingFragment) {
                e.preventDefault();
                e.stopPropagation();
                activeTableNode.setEditing(false);
                surface.getModel().setSelection(surface.getModel().getSelection().collapseToStart());
                ve.ce.TableArrowKeyDownHandler.static.moveTableSelection(surface, 0, e.shiftKey ? -1 : 1, false, false, true);
                if (surface.getModel().getSelection()instanceof ve.dm.TableSelection) {
                    activeTableNode.setEditing(true);
                }
                return true;
            } else if (activeTableCaptionNode) {
                e.preventDefault();
                e.stopPropagation();
                if (e.shiftKey) {
                    surface.getModel().setSelection(new ve.dm.LinearSelection(documentModel.getRelativeRange(activeTableNode.getRange(), -1)));
                } else {
                    surface.getModel().setSelection(new ve.dm.TableSelection(activeTableNode.getOuterRange(),0,0));
                }
                return true;
            }
        }
        return false;
    }
    ;
    ve.ce.keyDownHandlerFactory.register(ve.ce.LinearTabKeyDownHandler);
    ve.ce.GeneratedContentNode = function VeCeGeneratedContentNode() {
        this.generatingPromise = null;
        this.generatedContentsInvalid = null;
        this.model.connect(this, {
            update: 'onGeneratedContentNodeUpdate'
        });
        this.connect(this, {
            teardown: 'abortGenerating'
        });
        this.update();
    }
    ;
    OO.initClass(ve.ce.GeneratedContentNode);
    ve.ce.GeneratedContentNode.static.renderHtmlAttributes = !1;
    ve.ce.GeneratedContentNode.static.awaitGeneratedContent = function(view) {
        var promises = [];
        function queueNode(node) {
            var promise;
            if (typeof node.generateContents === 'function') {
                if (node.isGenerating()) {
                    promise = ve.createDeferred();
                    node.once('rerender', promise.resolve);
                    promises.push(promise);
                }
            }
        }
        if (view instanceof ve.ce.BranchNode) {
            view.traverse(queueNode);
        } else {
            queueNode(view);
        }
        return ve.promiseAll(promises);
    }
    ;
    ve.ce.GeneratedContentNode.prototype.generateContents = null;
    ve.ce.GeneratedContentNode.prototype.onGeneratedContentNodeUpdate = function(staged) {
        this.update(undefined, staged);
    }
    ;
    ve.ce.GeneratedContentNode.prototype.getRenderedDomElements = function(domElements) {
        var rendering, doc = this.getElementDocument();
        rendering = this.filterRenderedDomElements(ve.copyDomElements(domElements, doc));
        if (rendering.length) {
            rendering = rendering.map(function(node) {
                var span;
                if (node.nodeType === Node.TEXT_NODE) {
                    span = document.createElement('span');
                    span.appendChild(node);
                    return span;
                }
                return node;
            });
        } else {
            rendering = [document.createElement('span')];
        }
        ve.resolveAttributes(rendering, domElements[0].ownerDocument, ve.dm.Converter.static.computedAttributes);
        return rendering;
    }
    ;
    ve.ce.GeneratedContentNode.prototype.filterRenderedDomElements = function(domElements) {
        return ve.filterMetaElements(domElements);
    }
    ;
    ve.ce.GeneratedContentNode.prototype.render = function(generatedContents, staged) {
        var $newElements, lengthChange, node = this;
        if (this.live) {
            this.emit('teardown');
        }
        $newElements = $(this.getRenderedDomElements(ve.copyDomElements(generatedContents)));
        this.generatedContentsInvalid = !this.validateGeneratedContents($(generatedContents));
        if (!staged || !this.generatedContentsInvalid) {
            if (!this.$element[0].parentNode) {
                this.$element = $newElements;
            } else {
                lengthChange = this.$element.length !== $newElements.length;
                this.$element.first().replaceWith($newElements);
                this.$element.remove();
                this.$element = $newElements;
                if (lengthChange) {
                    setTimeout(function() {
                        if (node.getRoot() && node.getRoot().getSurface()) {
                            node.getRoot().getSurface().showModelSelection();
                        }
                    });
                }
            }
        } else {
            this.generatedContentsValid = !1;
            this.model.emit('generatedContentsError', $newElements);
        }
        if (this.$focusable) {
            this.$focusable = this.getFocusableElement();
            this.$bounding = this.getBoundingElement();
        }
        if (this.$resizable) {
            this.$resizable = this.getResizableElement();
        }
        this.initialize();
        if (this.live) {
            this.emit('setup');
        }
        this.afterRender();
    }
    ;
    ve.ce.GeneratedContentNode.prototype.afterRender = function() {
        this.emit('rerender');
    }
    ;
    ve.ce.GeneratedContentNode.prototype.validateGeneratedContents = function() {
        return true;
    }
    ;
    ve.ce.GeneratedContentNode.prototype.update = function(config, staged) {
        var store = this.model.doc.getStore()
          , contents = store.value(store.hashOfValue(null, OO.getHash([this.model.getHashObjectForRendering(), config])));
        if (contents) {
            this.render(contents, staged);
        } else {
            this.forceUpdate(config, staged);
        }
    }
    ;
    ve.ce.GeneratedContentNode.prototype.forceUpdate = function(config, staged) {
        var promise, node = this;
        if (this.generatingPromise) {
            this.abortGenerating();
        } else {
            this.startGenerating();
        }
        promise = this.generatingPromise = this.generateContents(config);
        promise.done(function(generatedContents) {
            if (node.generatingPromise === promise) {
                node.doneGenerating(generatedContents, config, staged);
            }
        }).fail(function() {
            if (node.generatingPromise === promise) {
                node.failGenerating();
            }
        });
    }
    ;
    ve.ce.GeneratedContentNode.prototype.startGenerating = function() {
        this.$element.addClass('ve-ce-generatedContentNode-generating');
    }
    ;
    ve.ce.GeneratedContentNode.prototype.abortGenerating = function() {
        var promise = this.generatingPromise;
        if (promise) {
            this.generatingPromise = null;
            if (typeof promise.abort === 'function') {
                promise.abort();
            }
        }
        this.$element.removeClass('ve-ce-generatedContentNode-generating');
    }
    ;
    ve.ce.GeneratedContentNode.prototype.doneGenerating = function(generatedContents, config, staged) {
        var store, hash;
        this.$element.removeClass('ve-ce-generatedContentNode-generating');
        this.generatingPromise = null;
        if (this.model && this.model.doc) {
            store = this.model.doc.getStore();
            hash = OO.getHash([this.model.getHashObjectForRendering(), config]);
            store.hash(generatedContents, hash);
            this.render(generatedContents, staged);
        }
    }
    ;
    ve.ce.GeneratedContentNode.prototype.failGenerating = function() {
        this.$element.removeClass('ve-ce-generatedContentNode-generating');
        this.generatingPromise = null;
    }
    ;
    ve.ce.GeneratedContentNode.prototype.isGenerating = function() {
        return !!this.generatingPromise;
    }
    ;
    ve.ce.GeneratedContentNode.prototype.getFocusableElement = function() {
        return this.$element;
    }
    ;
    ve.ce.GeneratedContentNode.prototype.getBoundingElement = function() {
        return this.$element;
    }
    ;
    ve.ce.GeneratedContentNode.prototype.getResizableElement = function() {
        return this.$element;
    }
    ;
    ve.ce.ContentEditableNode = function VeCeContentEditableNode() {
        this.ceSurface = null;
        this.setContentEditable(true);
        this.setReadOnly(false);
        this.connect(this, {
            setup: 'onContentEditableSetup',
            teardown: 'onContentEditableTeardown'
        });
    }
    ;
    OO.initClass(ve.ce.ContentEditableNode);
    ve.ce.ContentEditableNode.prototype.onContentEditableSetup = function() {
        if (this.ceSurface || !this.root) {
            return;
        }
        this.ceSurface = this.root.getSurface().getSurface();
        this.ceSurface.connect(this, {
            readOnly: 'onSurfaceReadOnly'
        });
        this.setReadOnly(this.ceSurface.isReadOnly());
    }
    ;
    ve.ce.ContentEditableNode.prototype.onContentEditableTeardown = function() {
        if (!this.ceSurface) {
            return;
        }
        this.ceSurface.disconnect(this, {
            readOnly: 'onSurfaceReadOnly'
        });
        this.ceSurface = null;
    }
    ;
    ve.ce.ContentEditableNode.prototype.onSurfaceReadOnly = function(readOnly) {
        this.setReadOnly(readOnly);
    }
    ;
    ve.ce.ContentEditableNode.prototype.setReadOnly = function(readOnly) {
        this.$element.prop('spellcheck', !readOnly);
    }
    ;
    ve.ce.ContentEditableNode.prototype.setContentEditable = function(enabled) {
        this.$element.prop('contentEditable', (!!enabled).toString());
    }
    ;
    ve.ce.ContentEditableNode.prototype.isContentEditable = function() {
        return this.$element.prop('contentEditable') === 'true';
    }
    ;
    ve.ce.ActiveNode = function VeCeActiveNode() {
        ve.ce.ContentEditableNode.call(this);
        this.activeNodeSurface = null;
        this.isActiveNodeSetup = !1;
        this.connect(this, {
            setup: 'onActiveNodeSetup',
            teardown: 'onActiveNodeTeardown'
        });
        this.$element.addClass('ve-ce-activeNode');
    }
    ;
    OO.mixinClass(ve.ce.ActiveNode, ve.ce.ContentEditableNode);
    ve.ce.ActiveNode.prototype.onActiveNodeSetup = function() {
        if (this.isActiveNodeSetup || !this.root) {
            return;
        }
        this.activeNodeSurface = this.getRoot().getSurface();
        this.activeNodeSurface.getModel().connect(this, {
            select: 'onActiveNodeSurfaceModelSelect'
        });
        this.isActiveNodeSetup = !0;
    }
    ;
    ve.ce.ActiveNode.prototype.onActiveNodeTeardown = function() {
        var surface = this.activeNodeSurface;
        surface.getModel().disconnect(this);
        if (surface.getActiveNode() === this) {
            surface.setActiveNode(null);
        }
        this.isActiveNodeSetup = !1;
    }
    ;
    ve.ce.ActiveNode.prototype.onActiveNodeSurfaceModelSelect = function(selection) {
        var coveringRange = selection.getCoveringRange()
          , surface = this.activeNodeSurface
          , activeNode = this;
        if (coveringRange && this.model.getRange().containsRange(new ve.Range(coveringRange.from))) {
            if (!surface.getActiveNode() || !surface.getActiveNode().traverseUpstream(function(node) {
                return node !== activeNode;
            })) {
                surface.setActiveNode(this);
            }
            this.$element.addClass('ve-ce-activeNode-active');
        } else {
            if (surface.getActiveNode() === this) {
                surface.setActiveNode(null);
            }
            if (!selection.isNull()) {
                this.$element.removeClass('ve-ce-activeNode-active');
            }
        }
    }
    ;
    ve.ce.AlienNode = function VeCeAlienNode() {
        ve.ce.AlienNode.super.apply(this, arguments);
        this.$element = $(ve.copyDomElements(this.model.getOriginalDomElements(this.model.getDocument().getStore()), document));
        ve.ce.FocusableNode.call(this, this.$element, {
            classes: ['ve-ce-alienNode-highlights']
        });
        this.initialize();
    }
    ;
    OO.inheritClass(ve.ce.AlienNode, ve.ce.LeafNode);
    OO.mixinClass(ve.ce.AlienNode, ve.ce.FocusableNode);
    ve.ce.AlienNode.static.name = 'alien';
    ve.ce.AlienNode.static.iconWhenInvisible = 'puzzle';
    ve.ce.AlienNode.static.getDescription = function() {
        return ve.msg('visualeditor-aliennode-tooltip');
    }
    ;
    ve.ce.AlienBlockNode = function VeCeAlienBlockNode() {
        ve.ce.AlienBlockNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ce.AlienBlockNode, ve.ce.AlienNode);
    ve.ce.AlienBlockNode.static.name = 'alienBlock';
    ve.ce.nodeFactory.register(ve.ce.AlienBlockNode);
    ve.ce.AlienInlineNode = function VeCeAlienInlineNode() {
        ve.ce.AlienInlineNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ce.AlienInlineNode, ve.ce.AlienNode);
    ve.ce.AlienInlineNode.static.name = 'alienInline';
    ve.ce.nodeFactory.register(ve.ce.AlienInlineNode);
    ve.ce.AlienTableCellNode = function VeCeAlienTableCellNode() {
        ve.ce.AlienTableCellNode.super.apply(this, arguments);
        ve.ce.TableCellableNode.call(this);
    }
    ;
    OO.inheritClass(ve.ce.AlienTableCellNode, ve.ce.AlienNode);
    OO.mixinClass(ve.ce.AlienTableCellNode, ve.ce.TableCellableNode);
    ve.ce.AlienTableCellNode.static.name = 'alienTableCell';
    ve.ce.nodeFactory.register(ve.ce.AlienTableCellNode);
    ve.ce.ArticleNode = function VeCeArticleNode() {
        ve.ce.ArticleNode.super.apply(this, arguments);
        this.$element.addClass('ve-ce-articleNode').prop('contentEditable', 'false');
    }
    ;
    OO.inheritClass(ve.ce.ArticleNode, ve.ce.BranchNode);
    ve.ce.ArticleNode.static.name = 'article';
    ve.ce.ArticleNode.static.tagName = 'article';
    ve.ce.nodeFactory.register(ve.ce.ArticleNode);
    ve.ce.BlockquoteNode = function VeCeBlockquoteNode() {
        ve.ce.BlockquoteNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ce.BlockquoteNode, ve.ce.BranchNode);
    ve.ce.BlockquoteNode.static.name = 'blockquote';
    ve.ce.BlockquoteNode.static.tagName = 'blockquote';
    ve.ce.BlockquoteNode.static.removeEmptyLastChildOnEnter = !0;
    ve.ce.nodeFactory.register(ve.ce.BlockquoteNode);
    ve.ce.BreakNode = function VeCeBreakNode() {
        ve.ce.BreakNode.super.apply(this, arguments);
        this.$element.addClass('ve-ce-breakNode');
    }
    ;
    OO.inheritClass(ve.ce.BreakNode, ve.ce.LeafNode);
    ve.ce.BreakNode.static.name = 'break';
    ve.ce.BreakNode.static.tagName = 'br';
    ve.ce.nodeFactory.register(ve.ce.BreakNode);
    ve.ce.CenterNode = function VeCeCenterNode() {
        ve.ce.CenterNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ce.CenterNode, ve.ce.BranchNode);
    ve.ce.CenterNode.static.name = 'center';
    ve.ce.CenterNode.static.tagName = 'center';
    ve.ce.nodeFactory.register(ve.ce.CenterNode);
    ve.ce.CommentNode = function VeCeCommentNode(model, config) {
        ve.ce.CommentNode.super.call(this, model, config);
        ve.ce.FocusableNode.call(this, this.$element, config);
        this.model.connect(this, {
            attributeChange: 'onAttributeChange'
        });
        this.$element.addClass('ve-ce-commentNode');
    }
    ;
    OO.inheritClass(ve.ce.CommentNode, ve.ce.LeafNode);
    OO.mixinClass(ve.ce.CommentNode, ve.ce.FocusableNode);
    ve.ce.CommentNode.static.name = 'comment';
    ve.ce.CommentNode.static.primaryCommandName = 'comment';
    ve.ce.CommentNode.static.iconWhenInvisible = 'notice';
    ve.ce.CommentNode.static.getDescription = function(model) {
        return model.getAttribute('text');
    }
    ;
    ve.ce.CommentNode.prototype.onAttributeChange = function(key) {
        if (key === 'text') {
            this.updateInvisibleIconLabel();
        }
    }
    ;
    ve.ce.CommentNode.prototype.hasRendering = function() {
        return false;
    }
    ;
    ve.ce.nodeFactory.register(ve.ce.CommentNode);
    ve.ce.DefinitionListItemNode = function VeCeDefinitionListItemNode() {
        ve.ce.DefinitionListItemNode.super.apply(this, arguments);
        this.model.connect(this, {
            update: 'onUpdate'
        });
    }
    ;
    OO.inheritClass(ve.ce.DefinitionListItemNode, ve.ce.BranchNode);
    OO.mixinClass(ve.ce.DefinitionListItemNode, ve.ce.ContentEditableNode);
    ve.ce.DefinitionListItemNode.static.name = 'definitionListItem';
    ve.ce.DefinitionListItemNode.static.splitOnEnter = !0;
    ve.ce.DefinitionListItemNode.prototype.getTagName = function() {
        var style = this.model.getAttribute('style')
          , types = {
            definition: 'dd',
            term: 'dt'
        };
        if (!Object.prototype.hasOwnProperty.call(types, style)) {
            throw new Error('Invalid style');
        }
        return types[style];
    }
    ;
    ve.ce.DefinitionListItemNode.prototype.onUpdate = function() {
        this.updateTagName();
    }
    ;
    ve.ce.nodeFactory.register(ve.ce.DefinitionListItemNode);
    ve.ce.DefinitionListNode = function VeCeDefinitionListNode() {
        ve.ce.DefinitionListNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ce.DefinitionListNode, ve.ce.BranchNode);
    ve.ce.DefinitionListNode.static.name = 'definitionList';
    ve.ce.DefinitionListNode.static.tagName = 'dl';
    ve.ce.DefinitionListNode.static.removeEmptyLastChildOnEnter = !0;
    ve.ce.nodeFactory.register(ve.ce.DefinitionListNode);
    ve.ce.DivNode = function VeCeDivNode() {
        ve.ce.DivNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ce.DivNode, ve.ce.BranchNode);
    ve.ce.DivNode.static.name = 'div';
    ve.ce.nodeFactory.register(ve.ce.DivNode);
    ve.ce.DocumentNode = function VeCeDocumentNode(model, surface, config) {
        this.surface = surface;
        ve.ce.DocumentNode.super.call(this, model, config);
        ve.ce.ContentEditableNode.call(this);
        this.setRoot(this);
        this.$element.addClass('ve-ce-documentNode ve-ce-attachedRootNode ve-ce-rootNode').attr('tabindex', 0);
        this.$element.attr('data-gramm', 'false');
        this.$element.attr('role', 'textbox');
    }
    ;
    OO.inheritClass(ve.ce.DocumentNode, ve.ce.BranchNode);
    OO.mixinClass(ve.ce.DocumentNode, ve.ce.ContentEditableNode);
    ve.ce.DocumentNode.static.name = 'document';
    ve.ce.DocumentNode.prototype.getOuterLength = function() {
        return this.length;
    }
    ;
    ve.ce.DocumentNode.prototype.getSurface = function() {
        return this.surface;
    }
    ;
    ve.ce.nodeFactory.register(ve.ce.DocumentNode);
    ve.ce.HeadingNode = function VeCeHeadingNode() {
        ve.ce.HeadingNode.super.apply(this, arguments);
        this.model.connect(this, {
            update: 'onUpdate'
        });
    }
    ;
    OO.inheritClass(ve.ce.HeadingNode, ve.ce.ContentBranchNode);
    ve.ce.HeadingNode.static.name = 'heading';
    ve.ce.HeadingNode.prototype.getTagName = function() {
        var level = this.model.getAttribute('level')
          , types = {
            1: 'h1',
            2: 'h2',
            3: 'h3',
            4: 'h4',
            5: 'h5',
            6: 'h6'
        };
        if (!Object.prototype.hasOwnProperty.call(types, level)) {
            throw new Error('Invalid level');
        }
        return types[level];
    }
    ;
    ve.ce.HeadingNode.prototype.onUpdate = function() {
        this.updateTagName();
    }
    ;
    ve.ce.nodeFactory.register(ve.ce.HeadingNode);
    ve.ce.HorizontalRuleNode = function VeCeHorizontalRuleNode() {
        ve.ce.HorizontalRuleNode.super.apply(this, arguments);
        this.$element = $('<div>').append(this.$element);
        ve.ce.FocusableNode.call(this);
        this.$element.addClass('ve-ce-horizontalRuleNode');
    }
    ;
    OO.inheritClass(ve.ce.HorizontalRuleNode, ve.ce.LeafNode);
    OO.mixinClass(ve.ce.HorizontalRuleNode, ve.ce.FocusableNode);
    ve.ce.HorizontalRuleNode.static.name = 'horizontalRule';
    ve.ce.HorizontalRuleNode.static.tagName = 'hr';
    ve.ce.nodeFactory.register(ve.ce.HorizontalRuleNode);
    ve.ce.InternalItemNode = function VeCeInternalItemNode() {
        ve.ce.InternalItemNode.super.apply(this, arguments);
        this.$element.addClass('ve-ce-internalItemNode');
    }
    ;
    OO.inheritClass(ve.ce.InternalItemNode, ve.ce.BranchNode);
    ve.ce.InternalItemNode.static.name = 'internalItem';
    ve.ce.InternalItemNode.static.tagName = 'span';
    ve.ce.nodeFactory.register(ve.ce.InternalItemNode);
    ve.ce.InternalListNode = function VeCeInternalListNode() {
        ve.ce.InternalListNode.super.apply(this, arguments);
        this.$element = $([]);
    }
    ;
    OO.inheritClass(ve.ce.InternalListNode, ve.ce.BranchNode);
    ve.ce.InternalListNode.static.name = 'internalList';
    ve.ce.InternalListNode.prototype.onSplice = function() {}
    ;
    ve.ce.nodeFactory.register(ve.ce.InternalListNode);
    ve.ce.ListItemNode = function VeCeListItemNode() {
        ve.ce.ListItemNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ce.ListItemNode, ve.ce.BranchNode);
    OO.mixinClass(ve.ce.ListItemNode, ve.ce.ContentEditableNode);
    ve.ce.ListItemNode.static.name = 'listItem';
    ve.ce.ListItemNode.static.tagName = 'li';
    ve.ce.ListItemNode.static.splitOnEnter = !0;
    ve.ce.nodeFactory.register(ve.ce.ListItemNode);
    ve.ce.ListNode = function VeCeListNode() {
        ve.ce.ListNode.super.apply(this, arguments);
        this.model.connect(this, {
            update: 'onUpdate'
        });
    }
    ;
    OO.inheritClass(ve.ce.ListNode, ve.ce.BranchNode);
    ve.ce.ListNode.static.name = 'list';
    ve.ce.ListNode.static.removeEmptyLastChildOnEnter = !0;
    ve.ce.ListNode.prototype.getTagName = function() {
        var style = this.model.getAttribute('style')
          , types = {
            bullet: 'ul',
            number: 'ol'
        };
        if (!Object.prototype.hasOwnProperty.call(types, style)) {
            throw new Error('Invalid style');
        }
        return types[style];
    }
    ;
    ve.ce.ListNode.prototype.onUpdate = function() {
        this.updateTagName();
    }
    ;
    ve.ce.nodeFactory.register(ve.ce.ListNode);
    ve.ce.ParagraphNode = function VeCeParagraphNode() {
        ve.ce.ParagraphNode.super.apply(this, arguments);
        this.$element.addClass('ve-ce-paragraphNode');
        if (this.model.getElement().internal && this.model.getElement().internal.generated === 'wrapper') {
            this.$element.addClass('ve-ce-generated-wrapper');
        }
    }
    ;
    OO.inheritClass(ve.ce.ParagraphNode, ve.ce.ContentBranchNode);
    ve.ce.ParagraphNode.static.name = 'paragraph';
    ve.ce.ParagraphNode.static.tagName = 'p';
    ve.ce.nodeFactory.register(ve.ce.ParagraphNode);
    ve.ce.PreformattedNode = function VeCePreformattedNode() {
        ve.ce.PreformattedNode.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ce.PreformattedNode, ve.ce.ContentBranchNode);
    ve.ce.PreformattedNode.static.name = 'preformatted';
    ve.ce.PreformattedNode.static.tagName = 'pre';
    ve.ce.nodeFactory.register(ve.ce.PreformattedNode);
    ve.ce.SectionNode = function VeCeSectionNode() {
        ve.ce.SectionNode.super.apply(this, arguments);
        this.model.connect(this, {
            update: 'onUpdate'
        });
        ve.ce.ActiveNode.call(this);
        this.$element.addClass('ve-ce-sectionNode');
    }
    ;
    OO.inheritClass(ve.ce.SectionNode, ve.ce.BranchNode);
    OO.mixinClass(ve.ce.SectionNode, ve.ce.ActiveNode);
    ve.ce.SectionNode.static.name = 'section';
    ve.ce.SectionNode.prototype.getTagName = function() {
        var style = this.model.getAttribute('style');
        if (this.model.constructor.static.matchTagNames.indexOf(style) === -1) {
            throw new Error('Invalid style');
        }
        return style;
    }
    ;
    ve.ce.SectionNode.prototype.onUpdate = function() {
        this.updateTagName();
    }
    ;
    ve.ce.nodeFactory.register(ve.ce.SectionNode);
    ve.ce.TableCaptionNode = function VeCeTableCaptionNode() {
        ve.ce.TableCaptionNode.super.apply(this, arguments);
        ve.ce.ActiveNode.call(this);
        this.$element.addClass('ve-ce-tableCaptionNode');
    }
    ;
    OO.inheritClass(ve.ce.TableCaptionNode, ve.ce.BranchNode);
    OO.mixinClass(ve.ce.TableCaptionNode, ve.ce.ActiveNode);
    ve.ce.TableCaptionNode.static.name = 'tableCaption';
    ve.ce.TableCaptionNode.static.tagName = 'caption';
    ve.ce.nodeFactory.register(ve.ce.TableCaptionNode);
    ve.ce.TableCellNode = function VeCeTableCellNode() {
        ve.ce.TableCellNode.super.apply(this, arguments);
        ve.ce.TableCellableNode.call(this);
        ve.ce.ContentEditableNode.call(this);
        this.setEditing(false);
        this.model.connect(this, {
            update: 'onUpdate',
            attributeChange: 'onAttributeChange'
        });
        this.connect(this, {
            teardown: 'onTableCellTeardown'
        });
    }
    ;
    OO.inheritClass(ve.ce.TableCellNode, ve.ce.BranchNode);
    OO.mixinClass(ve.ce.TableCellNode, ve.ce.TableCellableNode);
    OO.mixinClass(ve.ce.TableCellNode, ve.ce.ContentEditableNode);
    ve.ce.TableCellNode.static.name = 'tableCell';
    ve.ce.TableCellNode.static.trapsCursor = !0;
    ve.ce.TableCellNode.prototype.initialize = function() {
        var rowspan, colspan;
        ve.ce.TableCellNode.super.prototype.initialize.call(this);
        rowspan = this.model.getRowspan();
        colspan = this.model.getColspan();
        this.$element.addClass('ve-ce-tableCellNode ve-ce-tableCellNode-' + this.model.getAttribute('style'));
        if (rowspan > 1) {
            this.$element.attr('rowspan', rowspan);
        }
        if (colspan > 1) {
            this.$element.attr('colspan', colspan);
        }
        this.$element.attr('title', ve.msg('visualeditor-tablecell-tooltip'));
    }
    ;
    ve.ce.TableCellNode.prototype.setEditing = function(enable) {
        this.editing = enable;
        this.$element.toggleClass('ve-ce-tableCellNode-editing', enable);
        this.setContentEditable();
        if (this.getRoot()) {
            this.getRoot().getSurface().setActiveNode(enable ? this : null);
        }
        if (enable) {
            this.$element.removeAttr('title');
        } else {
            this.$element.attr('title', ve.msg('visualeditor-tablecell-tooltip'));
        }
    }
    ;
    ve.ce.TableCellNode.prototype.onTableCellTeardown = function() {
        var surface;
        if (this.getRoot()) {
            surface = this.getRoot().getSurface();
            if (surface.getActiveNode() === this) {
                surface.setActiveNode(null);
            }
        }
    }
    ;
    ve.ce.TableCellNode.prototype.setContentEditable = function() {
        return ve.ce.ContentEditableNode.prototype.setContentEditable.call(this, this.editing);
    }
    ;
    ve.ce.TableCellNode.prototype.onUpdate = function() {
        this.updateTagName();
    }
    ;
    ve.ce.TableCellNode.prototype.onAttributeChange = function(key, from, to) {
        switch (key) {
        case 'colspan':
        case 'rowspan':
            if (to > 1) {
                this.$element.attr(key, to);
            } else {
                this.$element.removeAttr(key);
            }
            break;
        case 'style':
            this.$element.removeClass('ve-ce-tableCellNode-' + from).addClass('ve-ce-tableCellNode-' + to);
            this.updateTagName();
            break;
        }
    }
    ;
    ve.ce.nodeFactory.register(ve.ce.TableCellNode);
    ve.ce.TableNode = function VeCeTableNode() {
        ve.ce.TableNode.super.apply(this, arguments);
        this.surface = null;
        this.active = !1;
        this.startCell = null;
        this.endCell = null;
        this.editingFragment = null;
        this.$element.addClass('ve-ce-tableNode').prop('contentEditable', 'false');
    }
    ;
    OO.inheritClass(ve.ce.TableNode, ve.ce.BranchNode);
    ve.ce.TableNode.prototype.onSetup = function() {
        ve.ce.TableNode.super.prototype.onSetup.call(this);
        if (this.isSetup || !this.root) {
            return;
        }
        this.surface = this.getRoot().getSurface();
        this.$selectionBox = $('<div>').addClass('ve-ce-tableNodeOverlay-selection-box');
        this.$selectionBoxAnchor = $('<div>').addClass('ve-ce-tableNodeOverlay-selection-box-anchor');
        if (OO.ui.isMobile()) {
            this.nodeContext = new ve.ui.TableLineContext(this,'table');
        } else {
            this.nodeContext = null;
        }
        this.colContext = new ve.ui.TableLineContext(this,'col');
        this.rowContext = new ve.ui.TableLineContext(this,'row');
        this.$overlay = $('<div>').addClass('ve-ce-tableNodeOverlay oo-ui-element-hidden').append([this.$selectionBox, this.$selectionBoxAnchor, this.nodeContext ? this.nodeContext.$element : undefined, this.colContext.$element, this.rowContext.$element, this.$rowBracket, this.$colBracket]);
        this.surface.surface.$blockers.append(this.$overlay);
        this.$element.on({
            'mousedown.ve-ce-tableNode': this.onTableMouseDown.bind(this),
            'dblclick.ve-ce-tableNode': this.onTableDblClick.bind(this)
        });
        this.$overlay.on({
            'mousedown.ve-ce-tableNode': this.onTableMouseDown.bind(this),
            'dblclick.ve-ce-tableNode': this.onTableDblClick.bind(this)
        });
        this.onTableMouseUpHandler = this.onTableMouseUp.bind(this);
        this.onTableMouseMoveHandler = this.onTableMouseMove.bind(this);
        this.updateOverlayDebounced = ve.debounce(this.updateOverlay.bind(this));
        this.surface.getModel().connect(this, {
            select: 'onSurfaceModelSelect'
        });
        this.surface.connect(this, {
            position: this.updateOverlayDebounced,
            activation: 'onSurfaceActivation'
        });
    }
    ;
    ve.ce.TableNode.prototype.onTeardown = function() {
        ve.ce.TableNode.super.prototype.onTeardown.call(this);
        this.$element.off('.ve-ce-tableNode');
        this.$overlay.off('.ve-ce-tableNode');
        this.surface.getModel().disconnect(this);
        this.surface.disconnect(this);
        this.$overlay.remove();
    }
    ;
    ve.ce.TableNode.prototype.onTableDblClick = function(e) {
        var offset;
        if (!this.getCellNodeFromEvent(e)) {
            return;
        }
        if (this.surface.getModel().getSelection()instanceof ve.dm.TableSelection) {
            this.setEditing(true, true);
            offset = this.surface.getOffsetFromEventCoords(e.originalEvent);
            if (offset !== -1) {
                this.surface.getModel().setLinearSelection(new ve.Range(offset));
            } else {
                this.setEditing(true);
            }
        }
    }
    ;
    ve.ce.TableNode.prototype.onTableMouseDown = function(e) {
        var cellNode, startCell, endCell, selection, newSelection, node = this;
        cellNode = this.getCellNodeFromEvent(e);
        if (!cellNode) {
            return;
        }
        endCell = this.getModel().getMatrix().lookupCell(cellNode.getModel());
        if (!endCell) {
            e.preventDefault();
            return;
        }
        selection = this.surface.getModel().getSelection();
        if (e.shiftKey && this.active) {
            if (selection instanceof ve.dm.TableSelection) {
                startCell = {
                    col: selection.fromCol,
                    row: selection.fromRow
                };
            } else {
                startCell = this.getModel().getMatrix().lookupCell(this.getActiveCellNode().getModel());
            }
        } else if ((e.which === OO.ui.MouseButtons.RIGHT || this.surface.isDeactivated()) && selection instanceof ve.dm.TableSelection && selection.containsCell(endCell)) {
            newSelection = selection;
            startCell = this.startCell || endCell;
        } else {
            startCell = endCell;
        }
        if (!newSelection) {
            newSelection = new ve.dm.TableSelection(this.getModel().getOuterRange(),startCell.col,startCell.row,endCell.col,endCell.row);
            newSelection = newSelection.expand(this.getModel().getDocument());
        }
        if (this.editingFragment) {
            if (newSelection.equals(this.editingFragment.getSelection())) {
                return;
            } else {
                this.setEditing(false, true);
            }
        }
        this.surface.getModel().setSelection(newSelection);
        this.surface.activate();
        if (e.which === OO.ui.MouseButtons.RIGHT && !this.getActiveCellNode()) {
            cellNode.$element.prop('contentEditable', true);
            ve.selectElement(cellNode.$element[0]);
            setTimeout(function() {
                cellNode.$element.prop('contentEditable', 'false');
                node.surface.onModelSelect();
            });
            return;
        }
        this.startCell = startCell;
        this.endCell = endCell;
        if (!(selection instanceof ve.dm.TableSelection) && OO.ui.isMobile()) {
            this.onTableDblClick(e);
        } else {
            this.surface.$document.on({
                'mouseup touchend': this.onTableMouseUpHandler,
                'mousemove touchmove': this.onTableMouseMoveHandler
            });
        }
        e.preventDefault();
    }
    ;
    ve.ce.TableNode.prototype.getCellNodeFromEvent = function(e) {
        var touch;
        if (e.type === 'touchstart' && e.originalEvent.touches.length > 1) {
            return null;
        } else if (e.type === 'touchmove') {
            if (e.originalEvent.touches.length > 1) {
                return null;
            }
            touch = e.originalEvent.touches[0];
            return this.getCellNodeFromPoint(touch.clientX, touch.clientY);
        } else {
            return this.getNearestCellNode(e.target);
        }
    }
    ;
    ve.ce.TableNode.prototype.getCellNodeFromPoint = function(x, y) {
        return this.getNearestCellNode(this.surface.getElementDocument().elementFromPoint(x, y));
    }
    ;
    ve.ce.TableNode.prototype.getNearestCellNode = function(element) {
        var $element = $(element)
          , $table = $element.closest('table');
        if (!this.$element.is($table)) {
            return null;
        }
        return $element.closest('td, th').data('view');
    }
    ;
    ve.ce.TableNode.prototype.onTableMouseMove = function(e) {
        var endCellNode, endCell, selection;
        endCellNode = this.getCellNodeFromEvent(e);
        if (!endCellNode) {
            return;
        }
        endCell = this.getModel().matrix.lookupCell(endCellNode.getModel());
        if (!endCell || endCell === this.endCell) {
            return;
        }
        this.endCell = endCell;
        selection = new ve.dm.TableSelection(this.getModel().getOuterRange(),this.startCell.col,this.startCell.row,endCell.col,endCell.row);
        selection = selection.expand(this.getModel().getDocument());
        this.surface.getModel().setSelection(selection);
    }
    ;
    ve.ce.TableNode.prototype.onTableMouseUp = function() {
        this.startCell = null;
        this.endCell = null;
        this.surface.$document.off({
            'mouseup touchend': this.onTableMouseUpHandler,
            'mousemove touchmove': this.onTableMouseMoveHandler
        });
    }
    ;
    ve.ce.TableNode.prototype.setEditing = function(isEditing, noSelect) {
        var cell, offset, cellRange, profile, activeCellNode, surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument(), selection = surfaceModel.getSelection();
        if (isEditing) {
            if (!selection.isSingleCell(documentModel)) {
                selection = selection.collapseToFrom();
                this.surface.getModel().setSelection(selection);
            }
            cell = this.getCellNodesFromSelection(selection)[0];
            if (!cell.isCellEditable()) {
                return;
            }
            this.editingFragment = this.surface.getModel().getFragment(selection);
            cell.setEditing(true);
            if (!noSelect) {
                cellRange = cell.getModel().getRange();
                offset = surfaceModel.getDocument().data.getNearestContentOffset(cellRange.end, -1);
                if (offset > cellRange.start) {
                    surfaceModel.setLinearSelection(new ve.Range(offset));
                }
            }
        } else {
            if ((activeCellNode = this.getActiveCellNode())) {
                activeCellNode.setEditing(false);
                if (!noSelect) {
                    surfaceModel.setSelection(this.editingFragment.getSelection());
                }
            }
            this.editingFragment = null;
        }
        this.$element.toggleClass('ve-ce-tableNode-editing', isEditing);
        profile = $.client.profile();
        if (profile.layout === 'gecko' && profile.versionBase === '39') {
            this.$element.prop('contentEditable', isEditing.toString());
        }
        this.$overlay.toggleClass('ve-ce-tableNodeOverlay-editing', isEditing);
    }
    ;
    ve.ce.TableNode.prototype.onSurfaceModelSelect = function(selection) {
        var active = (this.editingFragment !== null && selection instanceof ve.dm.LinearSelection && this.editingFragment.getSelection().getRanges(this.editingFragment.getDocument())[0].containsRange(selection.getRange())) || (selection instanceof ve.dm.TableSelection && selection.tableRange.equalsSelection(this.getModel().getOuterRange()));
        if (active) {
            if (!this.active) {
                this.$overlay.removeClass('oo-ui-element-hidden');
                this.$element.on('touchstart.ve-ce-tableNode', this.onTableMouseDown.bind(this));
            }
            if (selection instanceof ve.dm.TableSelection) {
                if (this.editingFragment) {
                    this.setEditing(false, true);
                }
                this.updateOverlayDebounced();
            }
        } else if (!active && this.active) {
            this.$overlay.addClass('oo-ui-element-hidden');
            if (this.editingFragment) {
                this.setEditing(false, true);
            }
            if (this.getActiveCellNode()) {
                this.surface.setActiveNode(null);
            }
            this.$element.off('touchstart.ve-ce-tableNode');
        }
        this.$element.toggleClass('ve-ce-tableNode-active', active);
        this.active = active;
    }
    ;
    ve.ce.TableNode.prototype.getActiveCellNode = function() {
        var activeNode = this.surface.getActiveNode()
          , tableNodeOfActiveCellNode = activeNode && activeNode instanceof ve.ce.TableCellNode && activeNode.findParent(ve.ce.TableNode);
        return tableNodeOfActiveCellNode === this ? activeNode : null;
    }
    ;
    ve.ce.TableNode.prototype.onSurfaceActivation = function() {
        this.$overlay.toggleClass('ve-ce-tableNodeOverlay-deactivated', !!this.surface.isShownAsDeactivated());
    }
    ;
    ve.ce.TableNode.prototype.updateOverlay = function() {
        var anchorOffset, selectionOffset, selection, documentModel, selectionRect, tableOffset, surfaceOffset;
        if (!this.active || !this.root || !this.surface.surface.$blockers[0].parentNode) {
            return;
        }
        selection = this.editingFragment ? this.editingFragment.getSelection() : this.surface.getModel().getSelection();
        documentModel = this.editingFragment ? this.editingFragment.getDocument() : this.surface.getModel().getDocument();
        tableOffset = this.getFirstSectionNode().$element[0].getBoundingClientRect();
        surfaceOffset = this.surface.getSurface().$element[0].getBoundingClientRect();
        if (!tableOffset) {
            return;
        }
        selectionRect = this.surface.getSelection(selection).getSelectionBoundingRect();
        if (!selectionRect) {
            return;
        }
        selectionOffset = ve.translateRect(selectionRect, surfaceOffset.left - tableOffset.left, surfaceOffset.top - tableOffset.top);
        if (selection.isSingleCell(documentModel)) {
            anchorOffset = selectionOffset;
        } else {
            anchorOffset = ve.translateRect(this.surface.getSelection(selection.collapseToFrom()).getSelectionBoundingRect(), surfaceOffset.left - tableOffset.left, surfaceOffset.top - tableOffset.top);
        }
        this.$selectionBox.css({
            top: selectionOffset.top,
            left: selectionOffset.left,
            width: selectionOffset.width,
            height: selectionOffset.height
        });
        this.$selectionBoxAnchor.css({
            top: anchorOffset.top,
            left: anchorOffset.left,
            width: anchorOffset.width,
            height: anchorOffset.height
        });
        this.$overlay.css({
            top: tableOffset.top - surfaceOffset.top,
            left: tableOffset.left - surfaceOffset.left,
            width: tableOffset.width
        });
        this.colContext.icon.$element.css({
            left: selectionOffset.left,
            width: selectionOffset.width
        });
        this.rowContext.icon.$element.css({
            top: selectionOffset.top,
            height: selectionOffset.height
        });
        if (this.nodeContext) {
            this.nodeContext.$element.toggleClass('oo-ui-element-hidden', this.surface.isReadOnly());
        }
        this.colContext.$element.toggleClass('oo-ui-element-hidden', this.surface.isReadOnly());
        this.rowContext.$element.toggleClass('oo-ui-element-hidden', this.surface.isReadOnly());
        this.$selectionBox.toggleClass('ve-ce-tableNodeOverlay-selection-box-notEditable', !selection.isEditable(documentModel));
    }
    ;
    ve.ce.TableNode.prototype.getFirstSectionNode = function() {
        var i = 0;
        while (!(this.children[i]instanceof ve.ce.TableSectionNode)) {
            i++;
        }
        return this.children[i];
    }
    ;
    ve.ce.TableNode.prototype.getCellNodesFromSelection = function(selection) {
        var i, l, cellModel, cellView, cells = selection.getMatrixCells(this.getModel().getDocument()), nodes = [];
        for (i = 0,
        l = cells.length; i < l; i++) {
            cellModel = cells[i].node;
            cellView = this.getNodeFromOffset(cellModel.getOffset() - this.model.getOffset());
            nodes.push(cellView);
        }
        return nodes;
    }
    ;
    ve.ce.TableNode.static.name = 'table';
    ve.ce.TableNode.static.tagName = 'table';
    ve.ce.nodeFactory.register(ve.ce.TableNode);
    ve.ce.TableRowNode = function VeCeTableRowNode() {
        ve.ce.TableRowNode.super.apply(this, arguments);
        this.$missingCell = null;
    }
    ;
    OO.inheritClass(ve.ce.TableRowNode, ve.ce.BranchNode);
    ve.ce.TableRowNode.static.name = 'tableRow';
    ve.ce.TableRowNode.static.tagName = 'tr';
    ve.ce.TableRowNode.prototype.onSetup = function() {
        ve.ce.TableRowNode.super.prototype.onSetup.apply(this, arguments);
        this.setupMissingCell();
    }
    ;
    ve.ce.TableRowNode.prototype.onSplice = function() {
        var node = this;
        ve.ce.TableRowNode.super.prototype.onSplice.apply(this, arguments);
        setTimeout(function() {
            if (node.getRoot()) {
                node.setupMissingCell();
            }
        });
    }
    ;
    ve.ce.TableRowNode.prototype.setupMissingCell = function() {
        var row, slugButton, matrix = this.findParent(ve.ce.TableNode).getModel().getMatrix(), maxColCount = matrix.getMaxColCount();
        row = matrix.getRowNodes().indexOf(this.model);
        if (maxColCount > matrix.getColCount(row)) {
            if (!this.$missingCell) {
                this.$missingCell = $('<td>').prop('contentEditable', 'false').addClass('ve-ce-branchNode-slug ve-ce-branchNode-blockSlug ve-ce-tableNode-missingCell');
                slugButton = new ve.ui.NoFocusButtonWidget({
                    icon: 'add',
                    framed: !1
                }).on('click', this.onMissingCellClick.bind(this));
                this.$missingCell.append(slugButton.$element);
            }
            this.$element.append(this.$missingCell);
        } else {
            this.removeSlugs();
        }
    }
    ;
    ve.ce.TableRowNode.prototype.removeSlugs = function() {
        if (this.$missingCell) {
            this.$missingCell.detach();
        }
    }
    ;
    ve.ce.TableRowNode.prototype.onMissingCellClick = function() {
        var row, col, surfaceModel = this.getRoot().getSurface().getModel(), documentModel = surfaceModel.getDocument(), tableModel = this.findParent(ve.ce.TableNode).getModel(), matrix = tableModel.getMatrix();
        surfaceModel.change(ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, this.getModel().getRange().end, ve.dm.TableCellNode.static.createData()));
        row = matrix.getRowNodes().indexOf(this.model);
        col = matrix.getColCount(row) - 1;
        surfaceModel.setSelection(new ve.dm.TableSelection(tableModel.getOuterRange(),col,row));
    }
    ;
    ve.ce.nodeFactory.register(ve.ce.TableRowNode);
    ve.ce.TableSectionNode = function VeCeTableSectionNode() {
        ve.ce.TableSectionNode.super.apply(this, arguments);
        this.model.connect(this, {
            update: 'onUpdate'
        });
    }
    ;
    OO.inheritClass(ve.ce.TableSectionNode, ve.ce.BranchNode);
    ve.ce.TableSectionNode.static.name = 'tableSection';
    ve.ce.TableSectionNode.prototype.getTagName = function() {
        var style = this.model.getAttribute('style')
          , types = {
            header: 'thead',
            body: 'tbody',
            footer: 'tfoot'
        };
        if (!Object.prototype.hasOwnProperty.call(types, style)) {
            throw new Error('Invalid style');
        }
        return types[style];
    }
    ;
    ve.ce.TableSectionNode.prototype.onUpdate = function() {
        this.updateTagName();
    }
    ;
    ve.ce.nodeFactory.register(ve.ce.TableSectionNode);
    ve.ce.TextNode = function VeCeTextNode() {
        ve.ce.TextNode.super.apply(this, arguments);
        this.$element = $([]);
    }
    ;
    OO.inheritClass(ve.ce.TextNode, ve.ce.LeafNode);
    ve.ce.TextNode.static.name = 'text';
    ve.ce.TextNode.static.splitOnEnter = !0;
    ve.ce.TextNode.static.whitespaceHtmlCharacters = ve.visibleWhitespaceCharacters;
    ve.ce.TextNode.prototype.getAnnotatedHtml = function() {
        var i, chr, data = this.model.getDocument().getDataFromNode(this.model), whitespaceHtmlChars = ve.visibleWhitespaceCharacters, significantWhitespace = this.getModel().getParent().hasSignificantWhitespace();
        function setChar(chr, index, data) {
            if (Array.isArray(data[index])) {
                data[index] = data[index].slice(0);
                data[index][0] = chr;
            } else {
                data[index] = chr;
            }
        }
        function getChar(index, data) {
            if (Array.isArray(data[index])) {
                return data[index][0];
            } else {
                return data[index];
            }
        }
        if (!significantWhitespace) {
            for (i = 0; i < data.length; i++) {
                chr = getChar(i, data);
                if (Object.prototype.hasOwnProperty.call(whitespaceHtmlChars, chr)) {
                    setChar(whitespaceHtmlChars[chr], i, data);
                }
            }
        }
        return data;
    }
    ;
    ve.ce.nodeFactory.register(ve.ce.TextNode);
    ve.ce.UnrenderedNode = function VeCeUnrenderedNode() {
        ve.ce.UnrenderedNode.super.apply(this, arguments);
        this.$element = $([]);
    }
    ;
    OO.inheritClass(ve.ce.UnrenderedNode, ve.ce.LeafNode);
    ve.ce.UnrenderedNode.static.name = 'unrendered';
    ve.ce.ImageNode = function VeCeImageNode($figure, $image, config) {
        config = ve.extendObject({
            enforceMax: !1,
            minDimensions: {
                width: 1,
                height: 1
            },
            $bounding: this.$element
        }, config);
        this.$figure = $figure;
        this.$image = $image || $figure;
        ve.ce.FocusableNode.call(this, this.$figure, config);
        ve.ce.ResizableNode.call(this, this.$image, config);
        this.$image.on('load', this.onLoad.bind(this));
        this.model.connect(this, {
            attributeChange: 'onAttributeChange'
        });
        this.$element.addClass('ve-ce-imageNode');
    }
    ;
    OO.mixinClass(ve.ce.ImageNode, ve.ce.FocusableNode);
    OO.mixinClass(ve.ce.ImageNode, ve.ce.ResizableNode);
    ve.ce.ImageNode.static.getDescription = function(model) {
        return model.getAttribute('src');
    }
    ;
    ve.ce.ImageNode.prototype.onAttributeChange = function(key, from, to) {
        switch (key) {
        case 'src':
            this.$image.prop('src', this.getResolvedAttribute('src'));
            break;
        case 'width':
        case 'height':
            this.$image.css(key, to !== null ? to : '');
            break;
        }
    }
    ;
    ve.ce.ImageNode.prototype.onLoad = function() {
        if (!this.model) {
            return;
        }
        this.setOriginalDimensions({
            width: this.$image.prop('naturalWidth'),
            height: this.$image.prop('naturalHeight')
        });
    }
    ;
    ve.ce.BlockImageNode = function VeCeBlockImageNode(model, config) {
        config = ve.extendObject({
            minDimensions: {
                width: 1,
                height: 1
            }
        }, config);
        ve.ce.BlockImageNode.super.call(this, model, config);
        this.$image = $('<img>').prop('src', this.getResolvedAttribute('src')).prependTo(this.$element);
        ve.ce.ImageNode.call(this, this.$image, this.$image, config);
        ve.ce.AlignableNode.call(this, this.$element, config);
        this.$element.addClass('ve-ce-blockImageNode');
        this.$image.prop({
            alt: this.model.getAttribute('alt'),
            src: this.getResolvedAttribute('src')
        }).css({
            width: this.model.getAttribute('width'),
            height: this.model.getAttribute('height')
        });
    }
    ;
    OO.inheritClass(ve.ce.BlockImageNode, ve.ce.BranchNode);
    OO.mixinClass(ve.ce.BlockImageNode, ve.ce.ImageNode);
    OO.mixinClass(ve.ce.BlockImageNode, ve.ce.ClassAttributeNode);
    OO.mixinClass(ve.ce.BlockImageNode, ve.ce.AlignableNode);
    ve.ce.BlockImageNode.static.name = 'blockImage';
    ve.ce.BlockImageNode.static.tagName = 'figure';
    ve.ce.nodeFactory.register(ve.ce.BlockImageNode);
    ve.ce.BlockImageCaptionNode = function VeCeBlockImageCaptionNode() {
        ve.ce.BlockImageCaptionNode.super.apply(this, arguments);
        ve.ce.ActiveNode.call(this);
    }
    ;
    OO.inheritClass(ve.ce.BlockImageCaptionNode, ve.ce.BranchNode);
    OO.mixinClass(ve.ce.BlockImageCaptionNode, ve.ce.ActiveNode);
    ve.ce.BlockImageCaptionNode.static.name = 'imageCaption';
    ve.ce.BlockImageCaptionNode.static.tagName = 'figcaption';
    ve.ce.BlockImageCaptionNode.static.isMultiline = !1;
    ve.ce.nodeFactory.register(ve.ce.BlockImageCaptionNode);
    ve.ce.InlineImageNode = function VeCeInlineImageNode(model, config) {
        config = ve.extendObject({
            minDimensions: {
                width: 1,
                height: 1
            }
        }, config);
        ve.ce.InlineImageNode.super.call(this, model, config);
        ve.ce.ImageNode.call(this, this.$element, null, config);
        this.$element.addClass('ve-ce-inlineImageNode').prop({
            alt: this.model.getAttribute('alt'),
            src: this.getResolvedAttribute('src')
        }).css({
            width: this.model.getAttribute('width'),
            height: this.model.getAttribute('height')
        });
    }
    ;
    OO.inheritClass(ve.ce.InlineImageNode, ve.ce.LeafNode);
    OO.mixinClass(ve.ce.InlineImageNode, ve.ce.ImageNode);
    ve.ce.InlineImageNode.static.name = 'inlineImage';
    ve.ce.InlineImageNode.static.tagName = 'img';
    ve.ce.nodeFactory.register(ve.ce.InlineImageNode);
    ve.ce.NailedAnnotation = function VeCeNailedAnnotation() {
        this.contentFragment = document.createDocumentFragment();
        this.$element.addClass('ve-ce-nailedAnnotation');
    }
    ;
    OO.initClass(ve.ce.NailedAnnotation);
    ve.ce.NailedAnnotation.static.canBeActive = !0;
    ve.ce.NailedAnnotation.static.makeNail = function(type) {
        var nail = document.createElement('img');
        if ($.client.profile().layout === 'gecko' || ve.inputDebug) {
            nail.src = ve.inputDebug ? ve.ce.nailImgDataUri : ve.ce.minImgDataUri;
        }
        nail.className = 've-ce-nail ve-ce-nail-' + type + (ve.inputDebug ? ' ve-ce-nail-debug' : '');
        return nail;
    }
    ;
    ve.ce.NailedAnnotation.prototype.getContentContainer = function() {
        return this.contentFragment;
    }
    ;
    ve.ce.NailedAnnotation.prototype.attachContents = function() {
        var element = this.$element[0];
        element.appendChild(this.constructor.static.makeNail('post-open'));
        element.appendChild(this.contentFragment);
        element.appendChild(this.constructor.static.makeNail('pre-close'));
    }
    ;
    ve.ce.NailedAnnotation.prototype.appendTo = function(node) {
        node.appendChild(this.constructor.static.makeNail('pre-open'));
        node.appendChild(this.$element[0]);
        node.appendChild(this.constructor.static.makeNail('post-close'));
    }
    ;
    ve.ce.LinkAnnotation = function VeCeLinkAnnotation(model, parentNode, config) {
        ve.ce.LinkAnnotation.super.call(this, model, parentNode, ve.extendObject({
            $element: $('<a>')
        }, config));
        ve.ce.NailedAnnotation.call(this);
        this.$element.addClass('ve-ce-linkAnnotation').prop({
            href: ve.resolveUrl(this.model.getHref(), this.getModelHtmlDocument()),
            title: this.constructor.static.getDescription(this.model)
        });
        this.$element.on('click', this.onClick.bind(this));
        this.$anchor = this.$element;
    }
    ;
    OO.inheritClass(ve.ce.LinkAnnotation, ve.ce.Annotation);
    OO.mixinClass(ve.ce.LinkAnnotation, ve.ce.NailedAnnotation);
    ve.ce.LinkAnnotation.static.name = 'link';
    ve.ce.LinkAnnotation.static.tagName = 'span';
    ve.ce.LinkAnnotation.static.getDescription = function(model) {
        return model.getHref();
    }
    ;
    ve.ce.LinkAnnotation.prototype.onClick = function(e) {
        if (e.which === OO.ui.MouseButtons.LEFT && (e.ctrlKey || e.metaKey)) {
            window.open(this.$element.prop('href'));
            e.preventDefault();
        }
    }
    ;
    ve.ce.annotationFactory.register(ve.ce.LinkAnnotation);
    ve.ce.TextStyleAnnotation = function VeCeTextStyleAnnotation() {
        ve.ce.TextStyleAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-textStyleAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.TextStyleAnnotation, ve.ce.Annotation);
    ve.ce.TextStyleAnnotation.static.name = 'textStyle';
    ve.ce.TextStyleAnnotation.prototype.getTagName = function() {
        return this.getModel().getAttribute('nodeName') || this.constructor.static.tagName;
    }
    ;
    ve.ce.annotationFactory.register(ve.ce.TextStyleAnnotation);
    ve.ce.AbbreviationAnnotation = function VeCeAbbreviationAnnotation() {
        ve.ce.AbbreviationAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-abbreviationAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.AbbreviationAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.AbbreviationAnnotation.static.name = 'textStyle/abbreviation';
    ve.ce.AbbreviationAnnotation.static.tagName = 'abbr';
    ve.ce.annotationFactory.register(ve.ce.AbbreviationAnnotation);
    ve.ce.BidiAnnotation = function VeCeBidiAnnotation() {
        ve.ce.BidiAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-bidiAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.BidiAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.BidiAnnotation.static.name = 'textStyle/bidi';
    ve.ce.BidiAnnotation.static.tagName = 'bdi';
    ve.ce.annotationFactory.register(ve.ce.BidiAnnotation);
    ve.ce.BigAnnotation = function VeCeBigAnnotation() {
        ve.ce.BigAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-bigAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.BigAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.BigAnnotation.static.name = 'textStyle/big';
    ve.ce.BigAnnotation.static.tagName = 'big';
    ve.ce.annotationFactory.register(ve.ce.BigAnnotation);
    ve.ce.BoldAnnotation = function VeCeBoldAnnotation() {
        ve.ce.BoldAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-boldAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.BoldAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.BoldAnnotation.static.name = 'textStyle/bold';
    ve.ce.BoldAnnotation.static.tagName = 'b';
    ve.ce.annotationFactory.register(ve.ce.BoldAnnotation);
    ve.ce.CodeAnnotation = function VeCeCodeAnnotation() {
        ve.ce.CodeAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-codeAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.CodeAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.CodeAnnotation.static.name = 'textStyle/code';
    ve.ce.CodeAnnotation.static.tagName = 'code';
    ve.ce.annotationFactory.register(ve.ce.CodeAnnotation);
    ve.ce.CodeSampleAnnotation = function VeCeCodeSampleAnnotation() {
        ve.ce.CodeSampleAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-codeSampleAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.CodeSampleAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.CodeSampleAnnotation.static.name = 'textStyle/codeSample';
    ve.ce.CodeSampleAnnotation.static.tagName = 'samp';
    ve.ce.annotationFactory.register(ve.ce.CodeSampleAnnotation);
    ve.ce.DatetimeAnnotation = function VeCeDatetimeAnnotation() {
        ve.ce.DatetimeAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-datetimeAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.DatetimeAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.DatetimeAnnotation.static.name = 'textStyle/datetime';
    ve.ce.DatetimeAnnotation.static.tagName = 'time';
    ve.ce.annotationFactory.register(ve.ce.DatetimeAnnotation);
    ve.ce.DefinitionAnnotation = function VeCeDefinitionAnnotation() {
        ve.ce.DefinitionAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-definitionAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.DefinitionAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.DefinitionAnnotation.static.name = 'textStyle/definition';
    ve.ce.DefinitionAnnotation.static.tagName = 'dfn';
    ve.ce.annotationFactory.register(ve.ce.DefinitionAnnotation);
    ve.ce.DeleteAnnotation = function VeCeDeleteAnnotation() {
        ve.ce.DeleteAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-deleteAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.DeleteAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.DeleteAnnotation.static.name = 'textStyle/delete';
    ve.ce.DeleteAnnotation.static.tagName = 'del';
    ve.ce.annotationFactory.register(ve.ce.DeleteAnnotation);
    ve.ce.FontAnnotation = function VeCeFontAnnotation() {
        ve.ce.FontAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-fontAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.FontAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.FontAnnotation.static.name = 'textStyle/font';
    ve.ce.FontAnnotation.static.tagName = 'font';
    ve.ce.annotationFactory.register(ve.ce.FontAnnotation);
    ve.ce.HighlightAnnotation = function VeCeHighlightAnnotation() {
        ve.ce.HighlightAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-highlightAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.HighlightAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.HighlightAnnotation.static.name = 'textStyle/highlight';
    ve.ce.HighlightAnnotation.static.tagName = 'mark';
    ve.ce.annotationFactory.register(ve.ce.HighlightAnnotation);
    ve.ce.InsertAnnotation = function VeCeInsertAnnotation() {
        ve.ce.InsertAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-insertAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.InsertAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.InsertAnnotation.static.name = 'textStyle/insert';
    ve.ce.InsertAnnotation.static.tagName = 'ins';
    ve.ce.annotationFactory.register(ve.ce.InsertAnnotation);
    ve.ce.ItalicAnnotation = function VeCeItalicAnnotation() {
        ve.ce.ItalicAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-italicAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.ItalicAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.ItalicAnnotation.static.name = 'textStyle/italic';
    ve.ce.ItalicAnnotation.static.tagName = 'i';
    ve.ce.annotationFactory.register(ve.ce.ItalicAnnotation);
    ve.ce.QuotationAnnotation = function VeCeQuotationAnnotation() {
        ve.ce.QuotationAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-quotationAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.QuotationAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.QuotationAnnotation.static.name = 'textStyle/quotation';
    ve.ce.QuotationAnnotation.static.tagName = 'q';
    ve.ce.annotationFactory.register(ve.ce.QuotationAnnotation);
    ve.ce.SmallAnnotation = function VeCeSmallAnnotation() {
        ve.ce.SmallAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-smallAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.SmallAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.SmallAnnotation.static.name = 'textStyle/small';
    ve.ce.SmallAnnotation.static.tagName = 'small';
    ve.ce.annotationFactory.register(ve.ce.SmallAnnotation);
    ve.ce.SpanAnnotation = function VeCeSpanAnnotation() {
        ve.ce.SpanAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-spanAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.SpanAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.SpanAnnotation.static.name = 'textStyle/span';
    ve.ce.SpanAnnotation.static.tagName = 'span';
    ve.ce.annotationFactory.register(ve.ce.SpanAnnotation);
    ve.ce.StrikethroughAnnotation = function VeCeStrikethroughAnnotation() {
        ve.ce.StrikethroughAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-strikethroughAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.StrikethroughAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.StrikethroughAnnotation.static.name = 'textStyle/strikethrough';
    ve.ce.StrikethroughAnnotation.static.tagName = 's';
    ve.ce.annotationFactory.register(ve.ce.StrikethroughAnnotation);
    ve.ce.SubscriptAnnotation = function VeCeSubscriptAnnotation() {
        ve.ce.SubscriptAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-subscriptAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.SubscriptAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.SubscriptAnnotation.static.name = 'textStyle/subscript';
    ve.ce.SubscriptAnnotation.static.tagName = 'sub';
    ve.ce.annotationFactory.register(ve.ce.SubscriptAnnotation);
    ve.ce.SuperscriptAnnotation = function VeCeSuperscriptAnnotation() {
        ve.ce.SuperscriptAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-superscriptAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.SuperscriptAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.SuperscriptAnnotation.static.name = 'textStyle/superscript';
    ve.ce.SuperscriptAnnotation.static.tagName = 'sup';
    ve.ce.annotationFactory.register(ve.ce.SuperscriptAnnotation);
    ve.ce.UnderlineAnnotation = function VeCeUnderlineAnnotation() {
        ve.ce.UnderlineAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-underlineAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.UnderlineAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.UnderlineAnnotation.static.name = 'textStyle/underline';
    ve.ce.UnderlineAnnotation.static.tagName = 'u';
    ve.ce.annotationFactory.register(ve.ce.UnderlineAnnotation);
    ve.ce.UserInputAnnotation = function VeCeUserInputAnnotation() {
        ve.ce.UserInputAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-userInputAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.UserInputAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.UserInputAnnotation.static.name = 'textStyle/userInput';
    ve.ce.UserInputAnnotation.static.tagName = 'kbd';
    ve.ce.annotationFactory.register(ve.ce.UserInputAnnotation);
    ve.ce.VariableAnnotation = function VeCeVariableAnnotation() {
        ve.ce.VariableAnnotation.super.apply(this, arguments);
        this.$element.addClass('ve-ce-variableAnnotation');
    }
    ;
    OO.inheritClass(ve.ce.VariableAnnotation, ve.ce.TextStyleAnnotation);
    ve.ce.VariableAnnotation.static.name = 'textStyle/variable';
    ve.ce.VariableAnnotation.static.tagName = 'var';
    ve.ce.annotationFactory.register(ve.ce.VariableAnnotation);
    ve.ui = {
        windowFactory: new OO.Factory()
    };
    ve.ui.windowFactory.register(OO.ui.MessageDialog);
    ve.ui.Overlay = function VeUiOverlay() {
        ve.ui.Overlay.super.apply(this, arguments);
        this.$element.addClass('ve-ui-overlay');
    }
    ;
    OO.inheritClass(ve.ui.Overlay, OO.ui.Element);
    ve.ui.Surface = function VeUiSurface(dataOrDocOrSurface, config) {
        var documentModel;
        config = config || {};
        ve.ui.Surface.super.call(this, config);
        this.$scrollContainer = config.$scrollContainer || $(this.getClosestScrollableElementContainer());
        this.inDialog = config.inDialog || '';
        this.mode = config.mode;
        this.globalOverlay = new ve.ui.Overlay({
            classes: ['ve-ui-overlay-global', 've-ui-overlay-global-' + (OO.ui.isMobile() ? 'mobile' : 'desktop')]
        });
        this.localOverlay = new ve.ui.Overlay({
            classes: ['ve-ui-overlay-local']
        });
        this.$selections = $('<div>');
        this.$blockers = $('<div>');
        this.$controls = $('<div>');
        this.$menus = $('<div>');
        this.$placeholder = $('<div>').addClass('ve-ui-surface-placeholder');
        this.commandRegistry = config.commandRegistry || ve.ui.commandRegistry;
        this.sequenceRegistry = config.sequenceRegistry || ve.ui.sequenceRegistry;
        this.dataTransferHandlerFactory = config.dataTransferHandlerFactory || ve.ui.dataTransferHandlerFactory;
        this.commands = OO.simpleArrayDifference(config.includeCommands || this.commandRegistry.getNames(), config.excludeCommands || []);
        this.triggerListener = new ve.TriggerListener(this.commands,this.commandRegistry);
        if (dataOrDocOrSurface instanceof ve.dm.Surface) {
            this.model = dataOrDocOrSurface;
        } else {
            if (dataOrDocOrSurface instanceof ve.dm.Document) {
                documentModel = dataOrDocOrSurface;
            } else if (dataOrDocOrSurface instanceof ve.dm.ElementLinearData || Array.isArray(dataOrDocOrSurface)) {
                documentModel = new ve.dm.Document(dataOrDocOrSurface);
            } else {
                documentModel = ve.dm.converter.getModelFromDom(dataOrDocOrSurface);
            }
            this.model = this.createModel(documentModel, config.attachedRoot);
        }
        this.view = this.createView(this.model);
        this.dialogs = this.createDialogWindowManager();
        this.importRules = config.importRules || {};
        this.multiline = config.multiline !== !1;
        this.context = this.createContext({
            $popupContainer: config.$overlayContainer
        });
        this.progresses = [];
        this.showProgressDebounced = ve.debounce(this.showProgress.bind(this));
        this.scrollSelectionIntoViewDebounced = ve.debounce(this.scrollSelectionIntoView.bind(this), 500);
        this.debugBar = null;
        this.placeholder = null;
        this.placeholderVisible = !1;
        this.setPlaceholder(config.placeholder);
        this.setReadOnly(!!config.readOnly);
        this.nullSelectionOnBlur = config.nullSelectionOnBlur !== !1;
        this.completion = new ve.ui.CompletionWidget(this);
        this.toolbarHeight = 0;
        this.padding = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        };
        this.toolbarDialogs = new ve.ui.ToolbarDialogWindowManager(this,{
            factory: ve.ui.windowFactory,
            modal: !1
        });
        this.getModel().connect(this, {
            select: 'onModelSelect',
            blur: 'onModelBlur',
            focus: 'onModelFocus'
        });
        this.getModel().getDocument().connect(this, {
            transact: 'onDocumentTransact'
        });
        this.getView().connect(this, {
            position: 'onViewPosition',
            activation: 'onViewActivation'
        });
        this.getContext().connect(this, {
            resize: 'onContextResize'
        });
        this.$menus.append(this.context.$element, this.completion.$element);
        this.$element.addClass('ve-ui-surface ve-ui-surface-' + this.mode).append(this.view.$element);
        this.view.$element.after(this.localOverlay.$element);
        this.localOverlay.$element.append(this.$selections, this.$blockers, this.$controls, this.$menus);
        this.globalOverlay.$element.append(this.dialogs.$element);
    }
    ;
    OO.inheritClass(ve.ui.Surface, OO.ui.Widget);
    ve.ui.Surface.prototype.destroy = function() {
        this.context.destroy();
        this.dialogs.destroy();
        this.toolbarDialogs.destroy();
        this.view.destroy();
        if (this.debugBar) {
            this.debugBar.destroy();
        }
        this.dialogs.disconnect(this);
        this.context.getInspectors().disconnect(this);
        this.$element.remove();
        this.globalOverlay.$element.remove();
        this.emit('destroy');
        return this;
    }
    ;
    ve.ui.Surface.prototype.initialize = function() {
        $(document.body).append(this.globalOverlay.$element);
        if (ve.debug) {
            this.setupDebugBar();
        }
        this.$element.addClass('ve-ui-surface-dir-' + this.getDir());
        this.getView().initialize();
        this.getModel().initialize();
        this.emit('ready');
        return this;
    }
    ;
    ve.ui.Surface.prototype.getDom = function() {
        return this.getModel().getDom();
    }
    ;
    ve.ui.Surface.prototype.getHtml = function() {
        return this.getModel().getHtml();
    }
    ;
    ve.ui.Surface.prototype.getMode = function() {
        return this.mode;
    }
    ;
    ve.ui.Surface.prototype.createContext = function(config) {
        return OO.ui.isMobile() ? new ve.ui.MobileContext(this,config) : new ve.ui.DesktopContext(this,config);
    }
    ;
    ve.ui.Surface.prototype.createDialogWindowManager = function() {
        return OO.ui.isMobile() ? new ve.ui.MobileWindowManager(this,{
            factory: ve.ui.windowFactory,
            overlay: this.globalOverlay
        }) : new ve.ui.SurfaceWindowManager(this,{
            factory: ve.ui.windowFactory
        });
    }
    ;
    ve.ui.Surface.prototype.createModel = function(doc, attachedRoot) {
        return new ve.dm.Surface(doc,attachedRoot,{
            sourceMode: this.getMode() === 'source'
        });
    }
    ;
    ve.ui.Surface.prototype.createView = function(model) {
        return new ve.ce.Surface(model,this);
    }
    ;
    ve.ui.Surface.prototype.setupDebugBar = function() {
        this.debugBar = new ve.ui.DebugBar(this);
        this.$element.append(this.debugBar.$element);
    }
    ;
    ve.ui.Surface.prototype.getBoundingClientRect = function() {
        return this.$element[0].getClientRects()[0] || null;
    }
    ;
    ve.ui.Surface.prototype.getViewportDimensions = function() {
        var top, bottom, rect = this.getBoundingClientRect();
        if (!rect) {
            return null;
        }
        top = Math.max(this.padding.top - rect.top, 0);
        bottom = $(this.getElementWindow()).height() - rect.top;
        return {
            top: top,
            left: rect.left,
            bottom: bottom,
            height: bottom - top
        };
    }
    ;
    ve.ui.Surface.prototype.isEnabled = function() {
        return !this.isDisabled();
    }
    ;
    ve.ui.Surface.prototype.getModel = function() {
        return this.model;
    }
    ;
    ve.ui.Surface.prototype.getView = function() {
        return this.view;
    }
    ;
    ve.ui.Surface.prototype.getContext = function() {
        return this.context;
    }
    ;
    ve.ui.Surface.prototype.getDialogs = function() {
        return this.dialogs;
    }
    ;
    ve.ui.Surface.prototype.getToolbarDialogs = function() {
        return this.toolbarDialogs;
    }
    ;
    ve.ui.Surface.prototype.getLocalOverlay = function() {
        return this.localOverlay;
    }
    ;
    ve.ui.Surface.prototype.getGlobalOverlay = function() {
        return this.globalOverlay;
    }
    ;
    ve.ui.Surface.prototype.setDisabled = function(disabled) {
        if (disabled) {
            OO.ui.warnDeprecation('Surfaces can\'t be disabled, only set to readOnly');
        }
    }
    ;
    ve.ui.Surface.prototype.setReadOnly = function(readOnly) {
        this.readOnly = !!readOnly;
        this.model.setReadOnly(readOnly);
        this.view.setReadOnly(readOnly);
        this.emit('readOnly', readOnly);
    }
    ;
    ve.ui.Surface.prototype.isReadOnly = function() {
        return this.readOnly;
    }
    ;
    ve.ui.Surface.prototype.focus = function() {
        this.getView().focus();
    }
    ;
    ve.ui.Surface.prototype.onDocumentTransact = function() {
        if (this.placeholder) {
            this.updatePlaceholder();
        }
    }
    ;
    ve.ui.Surface.prototype.onModelSelect = function() {
        if (this.getView().dragging ^ OO.ui.isMobile()) {
            return;
        }
        this.scrollSelectionIntoViewDebounced();
    }
    ;
    ve.ui.Surface.prototype.scrollSelectionIntoView = function() {
        var profile, clientRect, surfaceRect, padding, animate = !0, view = this.getView(), selection = view.getSelection(), surface = this;
        clientRect = selection.getSelectionFocusRect();
        surfaceRect = this.getBoundingClientRect();
        if (!clientRect || !surfaceRect) {
            return;
        }
        clientRect = ve.translateRect(clientRect, surfaceRect.left, surfaceRect.top);
        padding = ve.copy(this.padding);
        if (selection.isNativeCursor()) {
            animate = !1;
            if (OO.ui.isMobile() && !this.getModel().getSelection().isCollapsed()) {
                profile = $.client.profile();
                if (profile.name === 'android' && profile.versionNumber >= 6) {
                    padding.top += 60;
                }
                if (profile.name === 'android' || profile.name === 'firefox') {
                    padding.bottom += 30;
                }
            }
            clientRect.top -= 5;
            clientRect.bottom += 5;
        }
        ve.scrollIntoView(clientRect, {
            animate: animate,
            scrollContainer: this.$scrollContainer[0],
            padding: padding
        }).then(function() {
            if (selection.isNativeCursor()) {
                surface.emit('scroll');
            }
        });
    }
    ;
    ve.ui.Surface.prototype.scrollCursorIntoView = ve.ui.Surface.prototype.scrollSelectionIntoView;
    ve.ui.Surface.prototype.setPlaceholder = function(placeholder) {
        this.placeholder = placeholder;
        if (this.placeholder) {
            this.$placeholder.prependTo(this.$element);
            this.updatePlaceholder();
        } else {
            this.$placeholder.detach();
            this.placeholderVisible = !1;
            this.getView().$element.css('min-height', '');
        }
    }
    ;
    ve.ui.Surface.prototype.updatePlaceholder = function() {
        var firstNode, $wrapper, hasContent = this.getModel().getDocument().data.hasContent();
        this.$placeholder.toggleClass('oo-ui-element-hidden', hasContent);
        this.placeholderVisible = !hasContent;
        if (!hasContent) {
            firstNode = this.getView().attachedRoot.children[0];
            if (firstNode) {
                $wrapper = firstNode.$element.clone();
                if (ve.debug) {
                    $wrapper.removeAttr('style');
                }
            } else {
                $wrapper = $('<p>');
            }
            this.$placeholder.empty().append($wrapper.text(this.placeholder));
        } else {
            this.getView().$element.css('min-height', '');
        }
    }
    ;
    ve.ui.Surface.prototype.onViewPosition = function() {
        if (this.placeholderVisible) {
            this.getView().$element.css('min-height', this.$placeholder.outerHeight());
        }
    }
    ;
    ve.ui.Surface.prototype.getCommands = function() {
        return this.commands;
    }
    ;
    ve.ui.Surface.prototype.execute = function(triggerOrAction, method) {
        var command, obj, ret;
        if (triggerOrAction instanceof ve.ui.Trigger) {
            command = this.triggerListener.getCommandByTrigger(triggerOrAction.toString());
            if (command) {
                return command.execute(this);
            }
        } else if (typeof triggerOrAction === 'string' && typeof method === 'string') {
            if (ve.ui.actionFactory.doesActionSupportMethod(triggerOrAction, method)) {
                obj = ve.ui.actionFactory.create(triggerOrAction, this);
                ret = obj[method].apply(obj, Array.prototype.slice.call(arguments, 2));
                return ret === undefined || !!ret;
            }
        }
        return false;
    }
    ;
    ve.ui.Surface.prototype.executeCommand = function(commandName) {
        var command = this.commandRegistry.lookup(commandName);
        if (command) {
            return command.execute(this);
        }
        return false;
    }
    ;
    ve.ui.Surface.prototype.setToolbarHeight = function(toolbarHeight) {
        this.setPadding({
            top: toolbarHeight
        });
    }
    ;
    ve.ui.Surface.prototype.setPadding = function(padding) {
        ve.extendObject(this.padding, padding);
        this.toolbarHeight = this.padding.top;
    }
    ;
    ve.ui.Surface.prototype.onContextResize = function() {
        this.setPadding({
            bottom: this.context.$element[0].clientHeight
        });
        this.adjustVisiblePadding();
        this.scrollSelectionIntoView();
    }
    ;
    ve.ui.Surface.prototype.onModelBlur = function() {
        this.adjustVisiblePadding();
    }
    ;
    ve.ui.Surface.prototype.onModelFocus = function() {
        this.adjustVisiblePadding();
    }
    ;
    ve.ui.Surface.prototype.onViewActivation = function() {
        this.adjustVisiblePadding();
    }
    ;
    ve.ui.Surface.prototype.adjustVisiblePadding = function() {
        var bottom, keyboardShown;
        if (OO.ui.isMobile() && !this.getInDialog()) {
            keyboardShown = this.getView().getSelection().isNativeCursor() && !this.getView().isShownAsDeactivated();
            if (ve.init.platform.constructor.static.isIos() && keyboardShown) {
                bottom = $(window).height() - this.padding.top;
            } else {
                bottom = this.padding.bottom;
            }
            this.getView().$attachedRootNode.css('padding-bottom', bottom);
            this.scrollSelectionIntoView();
        }
    }
    ;
    ve.ui.Surface.prototype.createProgress = function(progressCompletePromise, label, nonCancellable) {
        var progressBarDeferred = ve.createDeferred();
        this.progresses.push({
            label: label,
            cancellable: !nonCancellable,
            progressCompletePromise: progressCompletePromise,
            progressBarDeferred: progressBarDeferred
        });
        this.showProgressDebounced();
        return progressBarDeferred.promise();
    }
    ;
    ve.ui.Surface.prototype.showProgress = function() {
        var progresses = this.progresses;
        this.dialogs.openWindow('progress', {
            progresses: progresses,
            $returnFocusTo: null
        });
        this.progresses = [];
    }
    ;
    ve.ui.Surface.prototype.getImportRules = function() {
        return this.importRules;
    }
    ;
    ve.ui.Surface.prototype.isMultiline = function() {
        return this.multiline;
    }
    ;
    ve.ui.Surface.prototype.getDir = function() {
        return this.$element.css('direction');
    }
    ;
    ve.ui.Surface.prototype.getInDialog = function() {
        return this.inDialog;
    }
    ;
    ve.ui.Context = function VeUiContext(surface, config) {
        ve.ui.Context.super.call(this, config);
        OO.EventEmitter.call(this);
        OO.ui.mixin.GroupElement.call(this, config);
        this.surface = surface;
        this.visible = !1;
        this.choosing = !1;
        this.$focusTrapBefore = $('<div>').prop('tabIndex', 0);
        this.$focusTrapAfter = $('<div>').prop('tabIndex', 0);
        this.$focusTrapBefore.add(this.$focusTrapAfter).on('focus', function() {
            surface.getView().activate();
        });
        this.$group.addClass('ve-ui-context-menu');
        this.$element.addClass('ve-ui-context ve-ui-context-hidden').append(this.$focusTrapBefore, this.$group, this.$focusTrapAfter);
    }
    ;
    OO.inheritClass(ve.ui.Context, OO.ui.Element);
    OO.mixinClass(ve.ui.Context, OO.EventEmitter);
    OO.mixinClass(ve.ui.Context, OO.ui.mixin.GroupElement);
    ve.ui.Context.static.isMobile = !1;
    ve.ui.Context.prototype.isMobile = function() {
        return this.constructor.static.isMobile;
    }
    ;
    ve.ui.Context.prototype.isVisible = function() {
        return this.visible;
    }
    ;
    ve.ui.Context.prototype.getRelatedSources = null;
    ve.ui.Context.prototype.getSurface = function() {
        return this.surface;
    }
    ;
    ve.ui.Context.prototype.toggleMenu = function(show) {
        show = show === undefined ? !this.choosing : !!show;
        if (show !== this.choosing) {
            this.choosing = show;
            this.$element.toggleClass('ve-ui-context-choosing', show);
            if (show) {
                this.setupMenuItems();
            } else {
                this.teardownMenuItems();
            }
        }
        return this;
    }
    ;
    ve.ui.Context.prototype.setupMenuItems = function() {
        var i, len, source, sources = this.getRelatedSources(), items = [];
        for (i = 0,
        len = sources.length; i < len; i++) {
            source = sources[i];
            if (source.type === 'item') {
                items.push(ve.ui.contextItemFactory.create(sources[i].name, this, sources[i].model));
            } else if (source.type === 'tool') {
                items.push(new ve.ui.ToolContextItem(this,sources[i].model,ve.ui.toolFactory.lookup(sources[i].name)));
            }
        }
        this.addItems(items);
        for (i = 0,
        len = items.length; i < len; i++) {
            items[i].connect(this, {
                command: 'onContextItemCommand'
            });
            items[i].setup();
        }
        return this;
    }
    ;
    ve.ui.Context.prototype.teardownMenuItems = function() {
        var i, len;
        for (i = 0,
        len = this.items.length; i < len; i++) {
            this.items[i].teardown();
        }
        this.clearItems();
        return this;
    }
    ;
    ve.ui.Context.prototype.onContextItemCommand = function() {}
    ;
    ve.ui.Context.prototype.toggle = function(show) {
        show = show === undefined ? !this.visible : !!show;
        if (show !== this.visible) {
            this.visible = show;
            this.$element.toggleClass('ve-ui-context-hidden', !this.visible);
        }
        this.emit('resize');
        return ve.createDeferred().resolve().promise();
    }
    ;
    ve.ui.Context.prototype.updateDimensions = function() {
        this.emit('resize');
        return this;
    }
    ;
    ve.ui.Context.prototype.destroy = function() {
        this.surface.getModel().disconnect(this);
        this.$element.remove();
        return this;
    }
    ;
    ve.ui.LinearContext = function VeUiLinearContext() {
        ve.ui.LinearContext.super.apply(this, arguments);
        this.inspector = null;
        this.inspectors = this.createInspectorWindowManager();
        this.isOpening = !1;
        this.lastSelectedNode = null;
        this.afterContextChangeTimeout = null;
        this.afterContextChangeHandler = this.afterContextChange.bind(this);
        this.updateDimensionsDebounced = ve.debounce(this.updateDimensions.bind(this));
        this.surface.getModel().connect(this, {
            contextChange: 'onContextChange',
            documentUpdate: 'onDocumentUpdate'
        });
        this.inspectors.connect(this, {
            opening: 'onInspectorOpening'
        });
    }
    ;
    OO.inheritClass(ve.ui.LinearContext, ve.ui.Context);
    ve.ui.LinearContext.static.showDeleteButton = !1;
    ve.ui.LinearContext.prototype.showDeleteButton = function() {
        return this.constructor.static.showDeleteButton;
    }
    ;
    ve.ui.LinearContext.prototype.onContextChange = function() {
        if (this.inspector && (this.inspector.isOpening() || this.inspector.isClosing())) {
            clearTimeout(this.afterContextChangeTimeout);
            this.afterContextChangeTimeout = null;
            this.lastSelectedNode = this.surface.getModel().getSelectedNode();
        } else {
            if (this.afterContextChangeTimeout === null) {
                this.afterContextChangeTimeout = setTimeout(this.afterContextChangeHandler);
            }
        }
        this.relatedSources = null;
    }
    ;
    ve.ui.LinearContext.prototype.onDocumentUpdate = function() {
        if (this.isVisible() && !this.isEmpty()) {
            this.onContextChange();
        }
    }
    ;
    ve.ui.LinearContext.prototype.afterContextChange = function() {
        var selectedNode = this.surface.getModel().getSelectedNode();
        this.afterContextChangeTimeout = null;
        if (this.isVisible()) {
            if (!this.isEmpty()) {
                if (this.isInspectable()) {
                    this.teardownMenuItems();
                    this.setupMenuItems();
                    this.updateDimensionsDebounced();
                } else {
                    this.toggleMenu(false);
                    this.toggle(false);
                }
            } else if (this.inspector && (!selectedNode || (selectedNode !== this.lastSelectedNode))) {
                this.inspector.close();
            }
        } else {
            if (this.isInspectable()) {
                this.toggleMenu(true);
                this.toggle(true);
            }
        }
        this.lastSelectedNode = selectedNode;
    }
    ;
    ve.ui.LinearContext.prototype.onInspectorOpening = function(win, opening) {
        var context = this
          , observer = this.surface.getView().surfaceObserver;
        this.isOpening = !0;
        this.inspector = win;
        observer.pollOnce();
        observer.stopTimerLoop();
        opening.progress(function(data) {
            context.isOpening = !1;
            if (data.state === 'setup') {
                if (!context.isVisible()) {
                    context.toggle(true);
                }
                if (!context.isEmpty()) {
                    context.toggleMenu(false);
                }
            }
            context.updateDimensionsDebounced();
        }).then(function(opened) {
            opened.then(function(closed) {
                closed.always(function() {
                    if (context.isOpening) {
                        return;
                    }
                    context.inspector = null;
                    observer.startTimerLoop();
                    if (context.isInspectable()) {
                        context.toggleMenu(true);
                        context.updateDimensionsDebounced();
                    } else {
                        context.toggle(false);
                    }
                });
            });
        });
    }
    ;
    ve.ui.LinearContext.prototype.isVisible = function() {
        return this.visible;
    }
    ;
    ve.ui.LinearContext.prototype.isInspectable = function() {
        return !!this.getRelatedSources().length;
    }
    ;
    ve.ui.LinearContext.prototype.getRelatedSources = function() {
        var surfaceModel = this.surface.getModel()
          , selection = surfaceModel.getSelection()
          , selectedModels = [];
        if (!this.relatedSources) {
            this.relatedSources = [];
            if (selection instanceof ve.dm.LinearSelection) {
                selectedModels = this.surface.getView().getSelectedModels();
            } else if (selection instanceof ve.dm.TableSelection) {
                selectedModels = [surfaceModel.getSelectedNode()];
            }
            if (selectedModels.length) {
                this.relatedSources = this.getRelatedSourcesFromModels(selectedModels);
            }
        }
        return this.relatedSources;
    }
    ;
    ve.ui.LinearContext.prototype.getRelatedSourcesFromModels = function(selectedModels) {
        var i, len, toolClass, tools, selectedNode, models = [], relatedSources = [], items = ve.ui.contextItemFactory.getRelatedItems(selectedModels);
        for (i = 0,
        len = items.length; i < len; i++) {
            if (!items[i].model.isInspectable()) {
                continue;
            }
            if (ve.ui.contextItemFactory.isExclusive(items[i].name)) {
                models.push(items[i].model);
            }
            relatedSources.push({
                type: 'item',
                embeddable: ve.ui.contextItemFactory.isEmbeddable(items[i].name),
                name: items[i].name,
                model: items[i].model
            });
        }
        tools = ve.ui.toolFactory.getRelatedItems(selectedModels);
        for (i = 0,
        len = tools.length; i < len; i++) {
            if (!tools[i].model.isInspectable()) {
                continue;
            }
            if (models.indexOf(tools[i].model) === -1) {
                toolClass = ve.ui.toolFactory.lookup(tools[i].name);
                relatedSources.push({
                    type: 'tool',
                    embeddable: !toolClass || toolClass.static.makesEmbeddableContextItem,
                    name: tools[i].name,
                    model: tools[i].model
                });
            }
        }
        if (!relatedSources.length) {
            selectedNode = this.surface.getModel().getSelectedNode();
            if (selectedNode && selectedNode.isFocusable() && this.showDeleteButton()) {
                relatedSources.push({
                    type: 'item',
                    embeddable: ve.ui.contextItemFactory.isEmbeddable('alien'),
                    name: 'alien',
                    model: selectedNode
                });
            }
        }
        return relatedSources;
    }
    ;
    ve.ui.LinearContext.prototype.getInspectors = function() {
        return this.inspectors;
    }
    ;
    ve.ui.LinearContext.prototype.createInspectorWindowManager = null;
    ve.ui.LinearContext.prototype.destroy = function() {
        this.surface.getModel().disconnect(this);
        this.inspectors.disconnect(this);
        this.inspectors.destroy();
        clearTimeout(this.afterContextChangeTimeout);
        return ve.ui.LinearContext.super.prototype.destroy.call(this);
    }
    ;
    ve.ui.TableLineContext = function VeUiTableLineContext(tableNode, itemGroup, config) {
        var labels;
        config = config || {};
        ve.ui.TableLineContext.super.call(this, tableNode.surface.getSurface(), config);
        this.tableNode = tableNode;
        this.itemGroup = itemGroup;
        this.icon = new OO.ui.IconWidget({
            icon: this.constructor.static.icons[itemGroup]
        });
        this.popup = new OO.ui.PopupWidget({
            classes: ['ve-ui-tableLineContext-menu'],
            $container: this.surface.$element,
            $floatableContainer: this.icon.$element,
            position: this.constructor.static.positions[this.itemGroup],
            width: null
        });
        this.icon.$element.on('mousedown', this.onIconMouseDown.bind(this));
        this.onDocumentMouseDownHandler = this.onDocumentMouseDown.bind(this);
        labels = {
            col: ve.msg('visualeditor-table-context-col'),
            row: ve.msg('visualeditor-table-context-row'),
            table: ve.msg('visualeditor-toolbar-table')
        };
        this.icon.$element.attr('role', 'button').attr('aria-label', labels[itemGroup]);
        this.popup.$body.append(this.$group);
        this.$element.addClass('ve-ui-tableLineContext ve-ui-tableLineContext-' + itemGroup).append(this.icon.$element, this.popup.$element);
        this.toggle(true);
    }
    ;
    OO.inheritClass(ve.ui.TableLineContext, ve.ui.Context);
    ve.ui.TableLineContext.static.groups = {
        col: ['insertColumnBefore', 'insertColumnAfter', 'moveColumnBefore', 'moveColumnAfter', 'deleteColumn'],
        row: ['insertRowBefore', 'insertRowAfter', 'moveRowBefore', 'moveRowAfter', 'deleteRow'],
        table: ['tableProperties', 'toggleTableEditing', 'deleteTable']
    };
    ve.ui.TableLineContext.static.icons = {
        col: 'expand',
        row: 'next',
        table: 'table'
    };
    ve.ui.TableLineContext.static.positions = {
        col: 'below',
        row: 'after',
        table: 'after'
    };
    ve.ui.TableLineContext.prototype.getRelatedSources = function() {
        var i, l, items = this.constructor.static.groups[this.itemGroup];
        if (!this.relatedSources) {
            this.relatedSources = [];
            for (i = 0,
            l = items.length; i < l; i++) {
                this.relatedSources.push({
                    type: 'item',
                    name: items[i]
                });
            }
        }
        return this.relatedSources;
    }
    ;
    ve.ui.TableLineContext.prototype.onContextItemCommand = function() {
        this.toggleMenu(false);
    }
    ;
    ve.ui.TableLineContext.prototype.onIconMouseDown = function(e) {
        e.preventDefault();
        this.toggleMenu(undefined, true);
    }
    ;
    ve.ui.TableLineContext.prototype.onDocumentMouseDown = function(e) {
        if (!$(e.target).closest(this.$element).length) {
            this.toggleMenu(false, true);
        }
    }
    ;
    ve.ui.TableLineContext.prototype.onModelSelect = function() {
        this.toggleMenu();
    }
    ;
    ve.ui.TableLineContext.prototype.toggleMenu = function(show, restoreEditing) {
        var dir, surfaceModel, surfaceView;
        show = show === undefined ? !this.popup.isVisible() : !!show;
        surfaceModel = this.surface.getModel();
        surfaceView = this.surface.getView();
        this.wasEditing = !!this.tableNode.editingFragment;
        if (this.itemGroup !== 'table') {
            if (show) {
                this.tableNode.setEditing(false);
            } else if (restoreEditing && surfaceModel.getSelection()instanceof ve.dm.TableSelection) {
                this.tableNode.setEditing(this.wasEditing);
            }
        }
        if (show) {
            surfaceModel.connect(this, {
                select: 'onModelSelect'
            });
            surfaceView.$document.on('mousedown', this.onDocumentMouseDownHandler);
            surfaceView.deactivate();
            dir = surfaceView.getSelectionDirectionality();
            this.$element.removeClass('ve-ui-dir-block-rtl ve-ui-dir-block-ltr').addClass('ve-ui-dir-block-' + dir);
        } else {
            surfaceModel.disconnect(this);
            surfaceView.$document.off('mousedown', this.onDocumentMouseDownHandler);
            surfaceView.activate();
        }
        ve.ui.TableLineContext.super.prototype.toggleMenu.call(this, show);
        this.popup.toggle(show);
    }
    ;
    ve.ui.ModeledFactory = function VeUiModeledFactory() {}
    ;
    OO.initClass(ve.ui.ModeledFactory);
    ve.ui.ModeledFactory.prototype.getRelatedItems = function(models) {
        var i, iLen, j, jLen, name, classes, model, registry = this.registry, names = {}, matches = [];
        function collect(model) {
            var i, len, name, candidate, add, candidates = [];
            for (name in registry) {
                candidate = registry[name];
                if (candidate.static.isCompatibleWith(model)) {
                    add = !0;
                    for (i = 0,
                    len = candidates.length; i < len; i++) {
                        if (candidate.prototype instanceof candidates[i]) {
                            candidates.splice(i, 1, candidate);
                            add = !1;
                            break;
                        } else if (candidates[i].prototype instanceof candidate) {
                            add = !1;
                            break;
                        }
                    }
                    if (add) {
                        candidates.push(candidate);
                    }
                }
            }
            return candidates;
        }
        for (i = 0,
        iLen = models.length; i < iLen; i++) {
            model = models[i];
            classes = collect(model);
            for (j = 0,
            jLen = classes.length; j < jLen; j++) {
                name = classes[j].static.name;
                if (!names[name]) {
                    matches.push({
                        name: name,
                        model: model
                    });
                }
                names[name] = !0;
            }
        }
        return matches;
    }
    ;
    ve.ui.ContextItem = function VeUiContextItem(context, model, config) {
        ve.ui.ContextItem.super.call(this, config);
        this.context = context;
        this.model = model;
        this.fragment = null;
        this.$element.on('mousedown', function() {
            context.getSurface().getView().deactivate();
        });
        this.$element.on('keydown', function(e) {
            if (e.keyCode === OO.ui.Keys.ESCAPE && context.getSurface().getView().isDeactivated()) {
                context.getSurface().getView().activate();
                return false;
            }
        });
        this.$element.addClass('ve-ui-contextItem');
    }
    ;
    OO.inheritClass(ve.ui.ContextItem, OO.ui.Widget);
    ve.ui.ContextItem.static.exclusive = !0;
    ve.ui.ContextItem.static.commandName = null;
    ve.ui.ContextItem.static.modelClasses = [];
    ve.ui.ContextItem.static.isCompatibleWith = function(model) {
        return ve.isInstanceOfAny(model, this.modelClasses);
    }
    ;
    ve.ui.ContextItem.prototype.isNode = function() {
        return this.model && this.model instanceof ve.dm.Node;
    }
    ;
    ve.ui.ContextItem.prototype.getCommand = function() {
        return this.context.getSurface().commandRegistry.lookup(this.constructor.static.commandName);
    }
    ;
    ve.ui.ContextItem.prototype.getFragment = function() {
        var surfaceModel;
        if (!this.fragment) {
            surfaceModel = this.context.getSurface().getModel();
            this.fragment = this.isNode() ? surfaceModel.getLinearFragment(this.model.getOuterRange()) : surfaceModel.getFragment();
        }
        return this.fragment;
    }
    ;
    ve.ui.ContextItem.prototype.isReadOnly = function() {
        return this.context.getSurface().isReadOnly();
    }
    ;
    ve.ui.ContextItem.prototype.setup = function() {
        return this;
    }
    ;
    ve.ui.ContextItem.prototype.teardown = function() {
        return this;
    }
    ;
    ve.ui.ContextItemFactory = function VeUiContextItemFactory() {
        ve.ui.ContextItemFactory.super.call(this);
        ve.ui.ModeledFactory.call(this);
    }
    ;
    OO.inheritClass(ve.ui.ContextItemFactory, OO.Factory);
    OO.mixinClass(ve.ui.ContextItemFactory, ve.ui.ModeledFactory);
    ve.ui.ContextItemFactory.prototype.isEmbeddable = function(name) {
        if (Object.prototype.hasOwnProperty.call(this.registry, name)) {
            return !!this.registry[name].static.embeddable;
        }
        throw new Error('Unrecognized symbolic name: ' + name);
    }
    ;
    ve.ui.ContextItemFactory.prototype.isExclusive = function(name) {
        if (Object.prototype.hasOwnProperty.call(this.registry, name)) {
            return !!this.registry[name].static.exclusive;
        }
        throw new Error('Unrecognized symbolic name: ' + name);
    }
    ;
    ve.ui.contextItemFactory = new ve.ui.ContextItemFactory();
    ve.ui.Tool = function VeUiTool() {
        ve.ui.Tool.super.apply(this, arguments);
        this.setDisabled(true);
    }
    ;
    OO.inheritClass(ve.ui.Tool, OO.ui.Tool);
    ve.ui.Tool.static.commandName = null;
    ve.ui.Tool.static.deactivateOnSelect = !0;
    ve.ui.Tool.static.makesEmbeddableContextItem = !0;
    ve.ui.Tool.static.getCommandName = function() {
        return this.commandName;
    }
    ;
    ve.ui.Tool.static.getCommand = function(surface) {
        var commandName = this.getCommandName();
        if (commandName === null) {
            return null;
        }
        return surface.commandRegistry.lookup(commandName);
    }
    ;
    ve.ui.Tool.prototype.onUpdateState = function(fragment) {
        var command = this.getCommand();
        if (command !== null) {
            this.setDisabled(!command || !fragment || !command.isExecutable(fragment) || (command.supportedSelections && fragment.getSurface() && fragment.getSurface().isReadOnly()));
        }
    }
    ;
    ve.ui.Tool.prototype.onSelect = function() {
        var contextClosePromise, command = this.getCommand(), surface = this.toolbar.getSurface(), tool = this;
        if (command instanceof ve.ui.Command) {
            if (surface.context.inspector) {
                contextClosePromise = surface.context.inspector.close().closed;
            } else {
                contextClosePromise = ve.createDeferred().resolve().promise();
            }
        }
        if (this.constructor.static.deactivateOnSelect) {
            this.setActive(false);
        }
        if (contextClosePromise) {
            contextClosePromise.done(function() {
                if (!command.execute(surface, undefined, 'tool')) {
                    tool.setActive(false);
                }
            });
        }
    }
    ;
    ve.ui.Tool.prototype.getCommand = function() {
        return this.constructor.static.getCommand(this.toolbar.getSurface());
    }
    ;
    ve.ui.Toolbar = function VeUiToolbar(config) {
        config = config || {};
        ve.ui.Toolbar.super.call(this, ve.ui.toolFactory, ve.ui.toolGroupFactory, config);
        this.updateToolStateDebounced = ve.debounce(this.updateToolState.bind(this));
        this.groups = null;
        this.contextDirection = {
            inline: 'ltr',
            block: 'ltr'
        };
        this.$element.addClass('ve-ui-toolbar').addClass('ve-ui-dir-inline-' + this.contextDirection.inline).addClass('ve-ui-dir-block-' + this.contextDirection.block);
    }
    ;
    OO.inheritClass(ve.ui.Toolbar, OO.ui.Toolbar);
    ve.ui.Toolbar.prototype.setup = function(groups, surface) {
        var oldSurface, surfaceChange = !1;
        this.detach();
        if (surface !== this.surface) {
            oldSurface = this.surface;
            this.surface = surface;
            surfaceChange = !0;
        }
        if (groups !== this.groups) {
            groups = groups.map(function(group) {
                if (group.name) {
                    group.classes = group.classes || [];
                    group.classes.push('ve-ui-toolbar-group-' + group.name);
                } else {
                    OO.ui.warnDeprecation('No name: ' + JSON.stringify(group));
                }
                return group;
            });
            ve.ui.Toolbar.super.prototype.setup.call(this, groups);
        }
        this.groups = groups;
        if (surfaceChange) {
            this.emit('surfaceChange', oldSurface, surface);
        }
        this.getSurface().getModel().connect(this, {
            contextChange: 'onContextChange'
        });
        this.getSurface().getDialogs().connect(this, {
            opening: 'onInspectorOrDialogOpeningOrClosing',
            closing: 'onInspectorOrDialogOpeningOrClosing'
        });
        this.getSurface().getToolbarDialogs().connect(this, {
            opening: 'onInspectorOrDialogOpeningOrClosing',
            closing: 'onInspectorOrDialogOpeningOrClosing'
        });
        this.getSurface().getContext().getInspectors().connect(this, {
            opening: 'onInspectorOrDialogOpeningOrClosing',
            closing: 'onInspectorOrDialogOpeningOrClosing'
        });
    }
    ;
    ve.ui.Toolbar.prototype.isToolAvailable = function(name) {
        var commandName, tool;
        if (!ve.ui.Toolbar.super.prototype.isToolAvailable.apply(this, arguments)) {
            return false;
        }
        tool = this.getToolFactory().lookup(name);
        if (!tool) {
            return false;
        }
        commandName = tool.static.commandName;
        return !commandName || this.getCommands().indexOf(commandName) !== -1;
    }
    ;
    ve.ui.Toolbar.prototype.onInspectorOrDialogOpeningOrClosing = function(win, openingOrClosing) {
        var toolbar = this;
        openingOrClosing.then(function() {
            toolbar.updateToolStateDebounced();
        });
    }
    ;
    ve.ui.Toolbar.prototype.onContextChange = function() {
        this.updateToolStateDebounced();
    }
    ;
    ve.ui.Toolbar.prototype.updateToolState = function() {
        var dirInline, dirBlock, fragmentAnnotation, activeDialogs, fragment;
        if (!this.getSurface()) {
            this.emit('updateState', null, null);
            return;
        }
        fragment = this.getSurface().getModel().getFragment();
        dirInline = dirBlock = this.surface.getView().getSelectionDirectionality();
        fragmentAnnotation = fragment.getAnnotations();
        if (fragmentAnnotation.hasAnnotationWithName('meta/language')) {
            dirInline = fragmentAnnotation.getAnnotationsByName('meta/language').get(0).getAttribute('dir');
        }
        if (dirInline !== this.contextDirection.inline) {
            this.$element.removeClass('ve-ui-dir-inline-rtl ve-ui-dir-inline-ltr');
            this.$element.addClass('ve-ui-dir-inline-' + dirInline);
            this.contextDirection.inline = dirInline;
        }
        if (dirBlock !== this.contextDirection.block) {
            this.$element.removeClass('ve-ui-dir-block-rtl ve-ui-dir-block-ltr');
            this.$element.addClass('ve-ui-dir-block-' + dirBlock);
            this.contextDirection.block = dirBlock;
        }
        activeDialogs = [this.surface.getDialogs(), this.surface.getContext().getInspectors(), this.surface.getToolbarDialogs()].map(function(windowManager) {
            if (windowManager.getCurrentWindow()) {
                return windowManager.getCurrentWindow().constructor.static.name;
            }
            return null;
        }).filter(function(name) {
            return name !== null;
        });
        this.emit('updateState', fragment, this.contextDirection, activeDialogs);
    }
    ;
    ve.ui.Toolbar.prototype.getTriggers = function(name) {
        return this.getSurface().triggerListener.getTriggers(name);
    }
    ;
    ve.ui.Toolbar.prototype.getCommands = function() {
        return this.getSurface().getCommands();
    }
    ;
    ve.ui.Toolbar.prototype.getToolAccelerator = function(name) {
        var messages = ve.ui.triggerRegistry.getMessages(name);
        return messages ? messages.join(', ') : undefined;
    }
    ;
    ve.ui.Toolbar.prototype.getSurface = function() {
        return this.surface;
    }
    ;
    ve.ui.Toolbar.prototype.detach = function() {
        if (this.getSurface()) {
            this.getSurface().getModel().disconnect(this);
            this.surface = null;
        }
    }
    ;
    ve.ui.Toolbar.prototype.destroy = function() {
        ve.ui.Toolbar.super.prototype.destroy.call(this);
        this.detach();
    }
    ;
    ve.ui.TargetToolbar = function VeUiTargetToolbar(target, config) {
        ve.ui.TargetToolbar.super.call(this, config);
        this.$element.addClass('ve-ui-targetToolbar');
        if (OO.ui.isMobile()) {
            this.$element.addClass('ve-ui-targetToolbar-mobile');
        }
        this.target = target;
    }
    ;
    OO.inheritClass(ve.ui.TargetToolbar, ve.ui.Toolbar);
    ve.ui.TargetToolbar.prototype.getTarget = function() {
        return this.target;
    }
    ;
    ve.ui.TargetToolbar.prototype.getTriggers = function(name) {
        var triggers = ve.ui.TargetToolbar.super.prototype.getTriggers.apply(this, arguments);
        return triggers || this.getTarget().targetTriggerListener.getTriggers(name) || this.getTarget().documentTriggerListener.getTriggers(name);
    }
    ;
    ve.ui.TargetToolbar.prototype.getCommands = function() {
        return ve.ui.TargetToolbar.super.prototype.getCommands.apply(this, arguments).concat(this.getTarget().targetTriggerListener.getCommands(), this.getTarget().documentTriggerListener.getCommands());
    }
    ;
    ve.ui.PositionedTargetToolbar = function VeUiPositionedTargetToolbar(target, config) {
        config = config || {};
        ve.ui.PositionedTargetToolbar.super.apply(this, arguments);
        if (!config.$overlay) {
            this.$overlay = this.$bar.append(this.$popups);
        }
        this.floating = !1;
        this.floatable = !!config.floatable;
        this.$window = $(this.getElementWindow());
        this.elementOffset = null;
        this.onWindowScrollThrottled = ve.throttle(this.onWindowScroll.bind(this), 250);
        this.$element.addClass('ve-ui-positionedTargetToolbar');
    }
    ;
    OO.inheritClass(ve.ui.PositionedTargetToolbar, ve.ui.TargetToolbar);
    ve.ui.PositionedTargetToolbar.prototype.setup = function(groups, surface) {
        var toolbarDialogs = surface.getToolbarDialogs();
        ve.ui.PositionedTargetToolbar.super.prototype.setup.apply(this, arguments);
        if (this.position === 'bottom') {
            this.$bar.prepend(toolbarDialogs.$element);
        } else {
            this.$bar.append(toolbarDialogs.$element);
        }
        toolbarDialogs.connect(this, {
            opening: 'onToolbarDialogsOpeningOrClosing',
            closing: 'onToolbarDialogsOpeningOrClosing'
        });
        if (this.isFloatable()) {
            ve.addPassiveEventListener(this.$window[0], 'scroll', this.onWindowScrollThrottled);
        }
    }
    ;
    ve.ui.PositionedTargetToolbar.prototype.detach = function() {
        this.unfloat();
        if (this.getSurface()) {
            this.getSurface().getToolbarDialogs().disconnect(this);
            this.getSurface().getToolbarDialogs().clearWindows();
        }
        ve.removePassiveEventListener(this.$window[0], 'scroll', this.onWindowScrollThrottled);
        ve.ui.PositionedTargetToolbar.super.prototype.detach.apply(this, arguments);
    }
    ;
    ve.ui.PositionedTargetToolbar.prototype.onWindowResize = function() {
        ve.ui.Toolbar.super.prototype.onWindowResize.call(this);
        this.calculateOffset();
        if (this.floating) {
            this.$bar.css({
                left: this.elementOffset.left,
                right: this.elementOffset.right
            });
        }
        this.onViewportResize();
    }
    ;
    ve.ui.PositionedTargetToolbar.prototype.calculateOffset = function() {
        this.elementOffset = this.$element.offset();
        this.elementOffset.right = document.documentElement.clientWidth - this.$element[0].offsetWidth - this.elementOffset.left;
    }
    ;
    ve.ui.PositionedTargetToolbar.prototype.getHeight = function() {
        return this.height;
    }
    ;
    ve.ui.PositionedTargetToolbar.prototype.getElementOffset = function() {
        if (!this.elementOffset) {
            this.calculateOffset();
        }
        return this.elementOffset;
    }
    ;
    ve.ui.PositionedTargetToolbar.prototype.float = function() {
        if (!this.floating) {
            this.height = this.$element[0].offsetHeight;
            this.$element.css('height', this.height).addClass('ve-ui-toolbar-floating');
            this.$bar.css({
                left: this.elementOffset.left,
                right: this.elementOffset.right
            });
            this.floating = !0;
            this.emit('resize');
            this.onViewportResize();
        }
    }
    ;
    ve.ui.PositionedTargetToolbar.prototype.unfloat = function() {
        if (this.floating) {
            this.height = 0;
            this.$element.css('height', '').removeClass('ve-ui-toolbar-floating');
            this.$bar.css({
                left: '',
                right: ''
            });
            this.floating = !1;
            this.emit('resize');
            this.onViewportResize();
        }
    }
    ;
    ve.ui.PositionedTargetToolbar.prototype.isFloating = function() {
        return this.floating;
    }
    ;
    ve.ui.PositionedTargetToolbar.prototype.isFloatable = function() {
        return this.floatable;
    }
    ;
    ve.ui.PositionedTargetToolbar.prototype.onToolbarDialogsOpeningOrClosing = function(win, openingOrClosing) {
        var width, margin, $surface = this.getSurface().$element, transitionDuration = OO.ui.theme.getDialogTransitionDuration(), toolbar = this;
        if (win.constructor.static.position === 'side' && win.isOpened()) {
            $surface.css($surface.css('direction') === 'rtl' ? 'margin-left' : 'margin-right', '');
            win.$element.css('width', '');
        }
        openingOrClosing.then(function() {
            var originalMargin;
            if (win.constructor.static.position === 'side') {
                if (win.isOpened()) {
                    margin = $surface.css('direction') === 'rtl' ? 'margin-left' : 'margin-right';
                    originalMargin = parseFloat($surface.css(margin));
                    width = win.getSizeProperties().width;
                    toolbar.getSurface().$element.addClass('ve-ui-surface-toolbarDialog-side').css(margin, width + originalMargin);
                    win.$element.css('width', width);
                } else {
                    toolbar.getSurface().$element.removeClass('ve-ui-surface-toolbarDialog-side');
                }
                toolbar.onViewportResize();
                setTimeout(function() {
                    toolbar.onViewportResize();
                    toolbar.getSurface().getView().emit('position');
                }, transitionDuration);
                toolbar.getSurface().getView().emit('position');
            }
            setTimeout(function() {
                if (toolbar.floating) {
                    toolbar.unfloat();
                    toolbar.float();
                }
            }, transitionDuration);
        });
    }
    ;
    ve.ui.PositionedTargetToolbar.prototype.onViewportResize = function() {
        var win, viewportDimensions, toolbarDialogs, surface = this.getSurface();
        if (!surface) {
            return;
        }
        toolbarDialogs = surface.getToolbarDialogs();
        win = toolbarDialogs.getCurrentWindow();
        if (win && win.constructor.static.position === 'side') {
            viewportDimensions = surface.getViewportDimensions();
            if (viewportDimensions) {
                toolbarDialogs.getCurrentWindow().$frame.css('height', Math.min(surface.getBoundingClientRect().height, viewportDimensions.height));
            }
        }
    }
    ;
    ve.ui.PositionedTargetToolbar.prototype.onWindowScroll = function() {
        if (!this.floating) {
            this.onViewportResize();
        }
    }
    ;
    ve.ui.ToolFactory = function VeUiToolFactory() {
        ve.ui.ToolFactory.super.call(this);
        ve.ui.ModeledFactory.call(this);
    }
    ;
    OO.inheritClass(ve.ui.ToolFactory, OO.ui.ToolFactory);
    OO.mixinClass(ve.ui.ToolFactory, ve.ui.ModeledFactory);
    ve.ui.toolFactory = new ve.ui.ToolFactory();
    ve.ui.toolGroupFactory = new OO.ui.ToolGroupFactory();
    ve.ui.Command = function VeUiCommand(name, action, method, options) {
        options = options || {};
        this.name = name;
        this.action = action;
        this.method = method;
        this.supportedSelections = options.supportedSelections || null;
        this.args = options.args || [];
    }
    ;
    ve.ui.Command.prototype.execute = function(surface, args, source) {
        var action = this.action;
        args = args || this.args;
        if (this.isExecutable(surface.getModel().getFragment())) {
            if (this.method === 'open') {
                if (typeof args[0] === 'string') {
                    action = args[0];
                }
                ve.track('activity.' + action, {
                    action: 'window-open-from-' + (source || 'command')
                });
            }
            return surface.execute.apply(surface, [this.action, this.method].concat(args));
        } else {
            return false;
        }
    }
    ;
    ve.ui.Command.prototype.isExecutable = function(fragment) {
        return !this.supportedSelections || this.supportedSelections.indexOf(fragment.getSelection().getName()) !== -1;
    }
    ;
    ve.ui.Command.prototype.getAction = function() {
        return this.action;
    }
    ;
    ve.ui.Command.prototype.getMethod = function() {
        return this.method;
    }
    ;
    ve.ui.Command.prototype.getName = function() {
        return this.name;
    }
    ;
    ve.ui.Command.prototype.getArgs = function() {
        return this.args;
    }
    ;
    ve.ui.CommandRegistry = function VeUiCommandRegistry() {
        ve.ui.CommandRegistry.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.CommandRegistry, OO.Registry);
    ve.ui.CommandRegistry.prototype.register = function(command) {
        if (!(command instanceof ve.ui.Command)) {
            throw new Error('command must be an instance of ve.ui.Command, cannot be a ' + typeof command);
        }
        ve.ui.CommandRegistry.super.prototype.register.call(this, command.getName(), command);
    }
    ;
    ve.ui.CommandRegistry.prototype.getCommandForNode = function(node) {
        return this.lookup(node.constructor.static.primaryCommandName);
    }
    ;
    ve.ui.CommandRegistry.prototype.getNames = function() {
        return Object.keys(this.registry);
    }
    ;
    ve.ui.commandRegistry = new ve.ui.CommandRegistry();
    ve.ui.commandRegistry.register(new ve.ui.Command('bold','annotation','toggle',{
        args: ['textStyle/bold'],
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('italic','annotation','toggle',{
        args: ['textStyle/italic'],
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('code','annotation','toggle',{
        args: ['textStyle/code'],
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('strikethrough','annotation','toggle',{
        args: ['textStyle/strikethrough'],
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('underline','annotation','toggle',{
        args: ['textStyle/underline'],
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('subscript','annotation','toggle',{
        args: ['textStyle/subscript'],
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('superscript','annotation','toggle',{
        args: ['textStyle/superscript'],
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('big','annotation','toggle',{
        args: ['textStyle/big'],
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('small','annotation','toggle',{
        args: ['textStyle/small'],
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('link','window','open',{
        args: ['link'],
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('linkNoExpand','window','open',{
        args: ['link', {
            noExpand: !0
        }],
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('specialCharacter','window','toggle',{
        args: ['specialCharacter'],
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('table','window','open',{
        args: ['table'],
        supportedSelections: ['table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('number','list','toggle',{
        args: ['number'],
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('bullet','list','toggle',{
        args: ['bullet'],
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('numberWrapOnce','list','wrapOnce',{
        args: ['number', true],
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('bulletWrapOnce','list','wrapOnce',{
        args: ['bullet', true],
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('commandHelp','window','open',{
        args: ['commandHelp']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('findAndReplace','window','open',{
        args: ['findAndReplace', null, 'findFirst']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('findNext','window','open',{
        args: ['findAndReplace', null, 'findNext']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('findPrevious','window','open',{
        args: ['findAndReplace', null, 'findPrevious']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('changeDirectionality','content','changeDirectionality'));
    ve.ui.commandRegistry.register(new ve.ui.Command('language','window','open',{
        args: ['language'],
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('paragraph','format','convert',{
        args: ['paragraph'],
        supportedSelections: ['linear']
    }));
    (function() {
        var level;
        for (level = 1; level <= 6; level++) {
            ve.ui.commandRegistry.register(new ve.ui.Command('heading' + level,'format','convert',{
                args: ['heading', {
                    level: level
                }],
                supportedSelections: ['linear']
            }));
        }
    }());
    ve.ui.commandRegistry.register(new ve.ui.Command('preformatted','format','convert',{
        args: ['preformatted'],
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('blockquote','blockquote','toggle',{
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('blockquoteWrap','blockquote','wrap',{
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('autolinkUrl','link','autolinkUrl',{
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('pasteSpecial','content','pasteSpecial',{
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('selectAll','content','selectAll',{
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('delete','content','remove',{
        args: ['delete'],
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('backspace','content','remove',{
        args: ['backspace'],
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('submit','content','submit',{
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('focusContext','content','focusContext',{
        supportedSelections: ['linear', 'table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('comment','window','open',{
        args: ['comment'],
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('insertHorizontalRule','content','insert',{
        args: [[{
            type: 'horizontalRule'
        }, {
            type: '/horizontalRule'
        }, {
            type: 'paragraph'
        }], false, true],
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('insertTable','table','create',{
        args: [{
            header: !0,
            rows: 3,
            cols: 4
        }],
        supportedSelections: ['linear']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('deleteTable','table','delete',{
        args: ['table'],
        supportedSelections: ['linear', 'table']
    }));
    (function() {
        var modes = ['row', 'col']
          , sides = ['before', 'after']
          , modeNames = {
            row: 'Row',
            col: 'Column'
        }
          , sideNames = {
            before: 'Before',
            after: 'After'
        };
        modes.forEach(function(mode) {
            var modeName = modeNames[mode];
            sides.forEach(function(side) {
                var sideName = sideNames[side];
                ve.ui.commandRegistry.register(new ve.ui.Command('insert' + modeName + sideName,'table','insert',{
                    args: [mode, side],
                    supportedSelections: ['table']
                }));
                ve.ui.commandRegistry.register(new ve.ui.Command('move' + modeName + sideName,'table','moveRelative',{
                    args: [mode, side],
                    supportedSelections: ['table']
                }));
            });
            ve.ui.commandRegistry.register(new ve.ui.Command('delete' + modeName,'table','delete',{
                args: [mode],
                supportedSelections: ['table']
            }));
        });
    }());
    ve.ui.commandRegistry.register(new ve.ui.Command('tableCellHeader','table','changeCellStyle',{
        args: ['header'],
        supportedSelections: ['table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('tableCellData','table','changeCellStyle',{
        args: ['data'],
        supportedSelections: ['table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('enterTableCell','table','enterTableCell',{
        supportedSelections: ['table']
    }));
    ve.ui.commandRegistry.register(new ve.ui.Command('exitTableCell','table','exitTableCell',{
        supportedSelections: ['linear']
    }));
    ve.ui.CommandHelpRegistry = function VeUiCommandHelpRegistry() {
        OO.Registry.call(this);
    }
    ;
    OO.inheritClass(ve.ui.CommandHelpRegistry, OO.Registry);
    ve.ui.CommandHelpRegistry.prototype.register = function(groupName, commandHelpName, details) {
        var existingCommand, i, shortcut, platform = ve.getSystemPlatform(), platformKey = platform === 'mac' ? 'mac' : 'pc';
        existingCommand = this.registry[commandHelpName];
        if (existingCommand) {
            if (details.sequences) {
                details = ve.copy(details);
                details.sequences = (existingCommand.sequences || []).concat(details.sequences);
            }
            details = ve.extendObject(existingCommand, details);
        }
        if (details.shortcuts) {
            for (i = 0; i < details.shortcuts.length; i++) {
                shortcut = details.shortcuts[i];
                if (ve.isPlainObject(shortcut)) {
                    details.shortcuts[i] = shortcut[platformKey];
                }
            }
        }
        details.group = groupName;
        OO.Registry.prototype.register.call(this, commandHelpName, details);
    }
    ;
    ve.ui.CommandHelpRegistry.prototype.lookupByGroup = function(groupName) {
        var commandHelpName, matches = {};
        for (commandHelpName in this.registry) {
            if (groupName === this.registry[commandHelpName].group) {
                matches[commandHelpName] = this.registry[commandHelpName];
            }
        }
        return matches;
    }
    ;
    ve.ui.commandHelpRegistry = new ve.ui.CommandHelpRegistry();
    ve.ui.commandHelpRegistry.register('textStyle', 'bold', {
        trigger: 'bold',
        label: OO.ui.deferMsg('visualeditor-annotationbutton-bold-tooltip')
    });
    ve.ui.commandHelpRegistry.register('textStyle', 'italic', {
        trigger: 'italic',
        label: OO.ui.deferMsg('visualeditor-annotationbutton-italic-tooltip')
    });
    ve.ui.commandHelpRegistry.register('textStyle', 'link', {
        trigger: 'link',
        label: OO.ui.deferMsg('visualeditor-annotationbutton-link-tooltip')
    });
    ve.ui.commandHelpRegistry.register('textStyle', 'superscript', {
        trigger: 'superscript',
        label: OO.ui.deferMsg('visualeditor-annotationbutton-superscript-tooltip')
    });
    ve.ui.commandHelpRegistry.register('textStyle', 'subscript', {
        trigger: 'subscript',
        label: OO.ui.deferMsg('visualeditor-annotationbutton-subscript-tooltip')
    });
    ve.ui.commandHelpRegistry.register('textStyle', 'underline', {
        trigger: 'underline',
        label: OO.ui.deferMsg('visualeditor-annotationbutton-underline-tooltip')
    });
    ve.ui.commandHelpRegistry.register('textStyle', 'code', {
        trigger: 'code',
        label: OO.ui.deferMsg('visualeditor-annotationbutton-code-tooltip')
    });
    ve.ui.commandHelpRegistry.register('textStyle', 'strikethrough', {
        trigger: 'strikethrough',
        label: OO.ui.deferMsg('visualeditor-annotationbutton-strikethrough-tooltip')
    });
    ve.ui.commandHelpRegistry.register('textStyle', 'clear', {
        trigger: 'clear',
        label: OO.ui.deferMsg('visualeditor-clearbutton-tooltip')
    });
    ve.ui.commandHelpRegistry.register('clipboard', 'cut', {
        trigger: 'cut',
        ignoreCommand: !0,
        label: OO.ui.deferMsg('visualeditor-clipboard-cut')
    });
    ve.ui.commandHelpRegistry.register('clipboard', 'copy', {
        trigger: 'copy',
        ignoreCommand: !0,
        label: OO.ui.deferMsg('visualeditor-clipboard-copy')
    });
    ve.ui.commandHelpRegistry.register('clipboard', 'paste', {
        trigger: 'paste',
        ignoreCommand: !0,
        label: OO.ui.deferMsg('visualeditor-clipboard-paste')
    });
    ve.ui.commandHelpRegistry.register('clipboard', 'pasteSpecial', {
        trigger: 'pasteSpecial',
        label: OO.ui.deferMsg('visualeditor-clipboard-paste-special')
    });
    ve.ui.commandHelpRegistry.register('dialog', 'dialogCancel', {
        shortcuts: ['escape'],
        label: OO.ui.deferMsg('visualeditor-command-dialog-cancel')
    });
    ve.ui.commandHelpRegistry.register('dialog', 'dialogConfirm', {
        shortcuts: [{
            mac: 'cmd+enter',
            pc: 'ctrl+enter'
        }],
        label: OO.ui.deferMsg('visualeditor-command-dialog-confirm')
    });
    ve.ui.commandHelpRegistry.register('dialog', 'focusContext', {
        trigger: 'focusContext',
        label: OO.ui.deferMsg('visualeditor-command-dialog-focus-context')
    });
    ve.ui.commandHelpRegistry.register('formatting', 'paragraph', {
        trigger: 'paragraph',
        label: OO.ui.deferMsg('visualeditor-formatdropdown-format-paragraph')
    });
    ve.ui.commandHelpRegistry.register('formatting', 'heading', {
        shortcuts: ['ctrl+1-6'],
        label: OO.ui.deferMsg('visualeditor-formatdropdown-format-heading-label')
    });
    ve.ui.commandHelpRegistry.register('formatting', 'pre', {
        trigger: 'preformatted',
        label: OO.ui.deferMsg('visualeditor-formatdropdown-format-preformatted')
    });
    ve.ui.commandHelpRegistry.register('formatting', 'blockquote', {
        trigger: 'blockquote',
        label: OO.ui.deferMsg('visualeditor-formatdropdown-format-blockquote')
    });
    ve.ui.commandHelpRegistry.register('formatting', 'indentIn', {
        trigger: 'indent',
        label: OO.ui.deferMsg('visualeditor-indentationbutton-indent-tooltip')
    });
    ve.ui.commandHelpRegistry.register('formatting', 'indentOut', {
        trigger: 'outdent',
        label: OO.ui.deferMsg('visualeditor-indentationbutton-outdent-tooltip')
    });
    ve.ui.commandHelpRegistry.register('formatting', 'listBullet', {
        sequences: ['bulletStar'],
        label: OO.ui.deferMsg('visualeditor-listbutton-bullet-tooltip')
    });
    ve.ui.commandHelpRegistry.register('formatting', 'listNumber', {
        sequences: ['numberDot'],
        label: OO.ui.deferMsg('visualeditor-listbutton-number-tooltip')
    });
    ve.ui.commandHelpRegistry.register('history', 'undo', {
        trigger: 'undo',
        label: OO.ui.deferMsg('visualeditor-historybutton-undo-tooltip')
    });
    ve.ui.commandHelpRegistry.register('history', 'redo', {
        trigger: 'redo',
        label: OO.ui.deferMsg('visualeditor-historybutton-redo-tooltip')
    });
    ve.ui.commandHelpRegistry.register('other', 'findAndReplace', {
        trigger: 'findAndReplace',
        label: OO.ui.deferMsg('visualeditor-find-and-replace-title')
    });
    ve.ui.commandHelpRegistry.register('other', 'findNext', {
        trigger: 'findNext',
        label: OO.ui.deferMsg('visualeditor-find-and-replace-next-button')
    });
    ve.ui.commandHelpRegistry.register('other', 'findPrevious', {
        trigger: 'findPrevious',
        label: OO.ui.deferMsg('visualeditor-find-and-replace-previous-button')
    });
    ve.ui.commandHelpRegistry.register('other', 'selectAll', {
        trigger: 'selectAll',
        label: OO.ui.deferMsg('visualeditor-content-select-all')
    });
    ve.ui.commandHelpRegistry.register('other', 'changeDirectionality', {
        trigger: 'changeDirectionality',
        label: OO.ui.deferMsg('visualeditor-changedir')
    });
    ve.ui.commandHelpRegistry.register('other', 'commandHelp', {
        trigger: 'commandHelp',
        label: OO.ui.deferMsg('visualeditor-dialog-command-help-title')
    });
    ve.ui.commandHelpRegistry.register('insert', 'horizontalRule', {
        sequences: ['horizontalRule'],
        label: OO.ui.deferMsg('visualeditor-horizontalrule-tooltip')
    });
    ve.ui.Trigger = function VeUiTrigger(e, allowInvalidPrimary) {
        var i, len, key, parts, keyAliases = ve.ui.Trigger.static.keyAliases, primaryKeys = ve.ui.Trigger.static.primaryKeys, primaryKeyMap = ve.ui.Trigger.static.primaryKeyMap;
        this.modifiers = {
            meta: !1,
            ctrl: !1,
            alt: !1,
            shift: !1
        };
        this.primary = !1;
        if (e instanceof $.Event) {
            this.modifiers.meta = e.metaKey || !1;
            this.modifiers.ctrl = e.ctrlKey || !1;
            this.modifiers.alt = e.altKey || !1;
            this.modifiers.shift = e.shiftKey || !1;
            this.primary = primaryKeyMap[e.which] || !1;
        } else if (typeof e === 'string') {
            parts = e.replace(/\s*/g, '').toLowerCase().split('+');
            for (i = 0,
            len = parts.length; i < len; i++) {
                key = parts[i];
                if (Object.prototype.hasOwnProperty.call(keyAliases, key)) {
                    key = keyAliases[key];
                }
                if (Object.prototype.hasOwnProperty.call(this.modifiers, key)) {
                    this.modifiers[key] = !0;
                } else if (primaryKeys.indexOf(key) !== -1 || allowInvalidPrimary) {
                    this.primary = key;
                }
            }
        }
    }
    ;
    OO.initClass(ve.ui.Trigger);
    ve.ui.Trigger.static.modifierKeys = ['meta', 'ctrl', 'alt', 'shift'];
    ve.ui.Trigger.static.primaryKeys = ['backspace', 'tab', 'enter', 'escape', 'space', 'page-up', 'page-down', 'end', 'home', 'left', 'up', 'right', 'down', 'insert', 'delete', 'clear', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'multiply', 'add', 'subtract', 'decimal', 'divide', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', ';', '=', ',', '-', '.', '/', '`', '[', '\\', ']', '\''];
    ve.ui.Trigger.static.platformMapping = {
        mac: {
            alt: '',
            backspace: '',
            ctrl: '^',
            delete: '',
            down: '',
            end: '',
            enter: '',
            escape: '',
            home: '',
            left: '',
            meta: '',
            'page-down': '',
            'page-up': '',
            right: '',
            shift: '',
            space: '',
            tab: '',
            up: ''
        }
    };
    ve.ui.Trigger.static.platformStringJoiners = {
        default: '+',
        mac: ''
    };
    ve.ui.Trigger.static.translatableKeys = ['alt', 'backspace', 'ctrl', 'delete', 'down', 'end', 'enter', 'escape', 'home', 'insert', 'left', 'meta', 'page-down', 'page-up', 'right', 'shift', 'space', 'tab', 'up'];
    ve.ui.Trigger.static.keyAliases = {
        command: 'meta',
        apple: 'meta',
        windows: 'meta',
        option: 'alt',
        return: 'enter',
        esc: 'escape',
        cmd: 'meta',
        del: 'delete',
        control: 'ctrl',
        alternate: 'alt',
        '': 'meta',
        '': 'alt',
        '': 'shift',
        '': 'enter',
        '': 'backspace',
        '': 'escape'
    };
    ve.ui.Trigger.static.primaryKeyMap = {
        8: 'backspace',
        9: 'tab',
        12: 'clear',
        13: 'enter',
        27: 'escape',
        32: 'space',
        33: 'page-up',
        34: 'page-down',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        45: 'insert',
        46: 'delete',
        48: '0',
        49: '1',
        50: '2',
        51: '3',
        52: '4',
        53: '5',
        54: '6',
        55: '7',
        56: '8',
        57: '9',
        59: ';',
        61: '=',
        65: 'a',
        66: 'b',
        67: 'c',
        68: 'd',
        69: 'e',
        70: 'f',
        71: 'g',
        72: 'h',
        73: 'i',
        74: 'j',
        75: 'k',
        76: 'l',
        77: 'm',
        78: 'n',
        79: 'o',
        80: 'p',
        81: 'q',
        82: 'r',
        83: 's',
        84: 't',
        85: 'u',
        86: 'v',
        87: 'w',
        88: 'x',
        89: 'y',
        90: 'z',
        96: '0',
        97: '1',
        98: '2',
        99: '3',
        100: '4',
        101: '5',
        102: '6',
        103: '7',
        104: '8',
        105: '9',
        106: 'multiply',
        107: 'add',
        109: 'subtract',
        110: 'decimal',
        111: 'divide',
        112: 'f1',
        113: 'f2',
        114: 'f3',
        115: 'f4',
        116: 'f5',
        117: 'f6',
        118: 'f7',
        119: 'f8',
        120: 'f9',
        121: 'f10',
        122: 'f11',
        123: 'f12',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: '\''
    };
    ve.ui.Trigger.prototype.isComplete = function() {
        return this.primary !== !1;
    }
    ;
    ve.ui.Trigger.prototype.toString = function() {
        var i, len, modifierKeys = ve.ui.Trigger.static.modifierKeys, keys = [];
        for (i = 0,
        len = modifierKeys.length; i < len; i++) {
            if (this.modifiers[modifierKeys[i]]) {
                keys.push(modifierKeys[i]);
            }
        }
        if (this.primary) {
            keys.push(this.primary);
            return keys.join('+');
        }
        return '';
    }
    ;
    ve.ui.Trigger.prototype.getMessage = function(explode) {
        var joiners, joiner, keys = this.toString().split('+'), hasOwn = Object.prototype.hasOwnProperty, translatableKeys = this.constructor.static.translatableKeys, platformMapping = this.constructor.static.platformMapping, platform = ve.getSystemPlatform();
        if (hasOwn.call(platformMapping, platform)) {
            keys = keys.map(function(key) {
                return hasOwn.call(platformMapping[platform], key) ? platformMapping[platform][key] : key;
            });
        }
        keys = keys.map(function(key) {
            return translatableKeys.indexOf(key) !== -1 ? ve.msg('visualeditor-key-' + key) : key.toUpperCase();
        });
        if (explode) {
            return keys;
        } else {
            joiners = this.constructor.static.platformStringJoiners;
            joiner = hasOwn.call(joiners, platform) ? joiners[platform] : joiners.default;
            return keys.join(joiner);
        }
    }
    ;
    ve.ui.TriggerRegistry = function VeUiTriggerRegistry() {
        ve.ui.TriggerRegistry.super.call(this);
        this.triggersByString = {};
    }
    ;
    OO.inheritClass(ve.ui.TriggerRegistry, OO.Registry);
    ve.ui.TriggerRegistry.prototype.register = function(name, triggers) {
        var i, l, triggerList, trigger, platform = ve.getSystemPlatform(), platformKey = platform === 'mac' ? 'mac' : 'pc';
        if (ve.isPlainObject(triggers)) {
            if (Object.prototype.hasOwnProperty.call(triggers, platformKey)) {
                triggerList = Array.isArray(triggers[platformKey]) ? triggers[platformKey] : [triggers[platformKey]];
            } else {
                return;
            }
        } else {
            triggerList = Array.isArray(triggers) ? triggers : [triggers];
        }
        for (i = 0,
        l = triggerList.length; i < l; i++) {
            trigger = triggerList[i];
            if (!(triggerList[i]instanceof ve.ui.Trigger)) {
                throw new Error('Trigger must be an instance of ve.ui.Trigger');
            }
            if (!triggerList[i].isComplete()) {
                throw new Error('Incomplete trigger');
            }
            this.triggersByString[trigger.toString()] = name;
        }
        ve.ui.TriggerRegistry.super.prototype.register.call(this, name, triggerList);
    }
    ;
    ve.ui.TriggerRegistry.prototype.getNameByTrigger = function(triggerString) {
        return this.triggersByString[triggerString];
    }
    ;
    ve.ui.TriggerRegistry.prototype.getMessages = function(name) {
        return (this.lookup(name) || []).map(function(trigger) {
            return trigger.getMessage();
        });
    }
    ;
    ve.ui.triggerRegistry = new ve.ui.TriggerRegistry();
    ve.ui.triggerRegistry.register('undo', {
        mac: new ve.ui.Trigger('cmd+z'),
        pc: new ve.ui.Trigger('ctrl+z')
    });
    ve.ui.triggerRegistry.register('redo', {
        mac: [new ve.ui.Trigger('cmd+shift+z'), new ve.ui.Trigger('cmd+y')],
        pc: [new ve.ui.Trigger('ctrl+shift+z'), new ve.ui.Trigger('ctrl+y')]
    });
    ve.ui.triggerRegistry.register('bold', {
        mac: new ve.ui.Trigger('cmd+b'),
        pc: new ve.ui.Trigger('ctrl+b')
    });
    ve.ui.triggerRegistry.register('italic', {
        mac: new ve.ui.Trigger('cmd+i'),
        pc: new ve.ui.Trigger('ctrl+i')
    });
    ve.ui.triggerRegistry.register('link', {
        mac: new ve.ui.Trigger('cmd+k'),
        pc: new ve.ui.Trigger('ctrl+k')
    });
    ve.ui.triggerRegistry.register('clear', {
        mac: [new ve.ui.Trigger('cmd+\\')],
        pc: [new ve.ui.Trigger('ctrl+\\'), new ve.ui.Trigger('ctrl+m')]
    });
    ve.ui.triggerRegistry.register('underline', {
        mac: new ve.ui.Trigger('cmd+u'),
        pc: new ve.ui.Trigger('ctrl+u')
    });
    ve.ui.triggerRegistry.register('code', {
        mac: new ve.ui.Trigger('cmd+shift+6'),
        pc: new ve.ui.Trigger('ctrl+shift+6')
    });
    ve.ui.triggerRegistry.register('strikethrough', {
        mac: new ve.ui.Trigger('cmd+shift+5'),
        pc: new ve.ui.Trigger('ctrl+shift+5')
    });
    ve.ui.triggerRegistry.register('subscript', {
        mac: new ve.ui.Trigger('cmd+,'),
        pc: new ve.ui.Trigger('ctrl+,')
    });
    ve.ui.triggerRegistry.register('superscript', {
        mac: new ve.ui.Trigger('cmd+.'),
        pc: new ve.ui.Trigger('ctrl+.')
    });
    ve.ui.triggerRegistry.register('indent', {
        mac: [new ve.ui.Trigger('tab'), new ve.ui.Trigger('cmd+]')],
        pc: [new ve.ui.Trigger('tab'), new ve.ui.Trigger('ctrl+]')]
    });
    ve.ui.triggerRegistry.register('outdent', {
        mac: [new ve.ui.Trigger('shift+tab'), new ve.ui.Trigger('cmd+[')],
        pc: [new ve.ui.Trigger('shift+tab'), new ve.ui.Trigger('ctrl+[')]
    });
    ve.ui.triggerRegistry.register('commandHelp', {
        mac: [new ve.ui.Trigger('cmd+/'), new ve.ui.Trigger('cmd+shift+/')],
        pc: [new ve.ui.Trigger('ctrl+/'), new ve.ui.Trigger('ctrl+shift+/')]
    });
    ve.ui.triggerRegistry.register('paragraph', new ve.ui.Trigger('ctrl+0'));
    ve.ui.triggerRegistry.register('heading1', new ve.ui.Trigger('ctrl+1'));
    ve.ui.triggerRegistry.register('heading2', new ve.ui.Trigger('ctrl+2'));
    ve.ui.triggerRegistry.register('heading3', new ve.ui.Trigger('ctrl+3'));
    ve.ui.triggerRegistry.register('heading4', new ve.ui.Trigger('ctrl+4'));
    ve.ui.triggerRegistry.register('heading5', new ve.ui.Trigger('ctrl+5'));
    ve.ui.triggerRegistry.register('heading6', new ve.ui.Trigger('ctrl+6'));
    ve.ui.triggerRegistry.register('preformatted', new ve.ui.Trigger('ctrl+7'));
    ve.ui.triggerRegistry.register('blockquote', new ve.ui.Trigger('ctrl+8'));
    ve.ui.triggerRegistry.register('selectAll', {
        mac: new ve.ui.Trigger('cmd+a'),
        pc: new ve.ui.Trigger('ctrl+a')
    });
    ve.ui.triggerRegistry.register('delete', {
        mac: new ve.ui.Trigger('ctrl+d')
    });
    ve.ui.triggerRegistry.register('pasteSpecial', {
        mac: new ve.ui.Trigger('cmd+option+shift+v'),
        pc: new ve.ui.Trigger('ctrl+shift+v')
    });
    ve.ui.triggerRegistry.register('cut', {
        mac: new ve.ui.Trigger('cmd+x'),
        pc: new ve.ui.Trigger('ctrl+x')
    });
    ve.ui.triggerRegistry.register('copy', {
        mac: new ve.ui.Trigger('cmd+c'),
        pc: new ve.ui.Trigger('ctrl+c')
    });
    ve.ui.triggerRegistry.register('paste', {
        mac: new ve.ui.Trigger('cmd+v'),
        pc: new ve.ui.Trigger('ctrl+v')
    });
    ve.ui.triggerRegistry.register('findAndReplace', {
        mac: new ve.ui.Trigger('cmd+f'),
        pc: new ve.ui.Trigger('ctrl+f')
    });
    ve.ui.triggerRegistry.register('changeDirectionality', {
        mac: new ve.ui.Trigger('cmd+shift+x'),
        pc: new ve.ui.Trigger('ctrl+shift+x')
    });
    ve.ui.triggerRegistry.register('findNext', {
        mac: new ve.ui.Trigger('cmd+g'),
        pc: [new ve.ui.Trigger('ctrl+g'), new ve.ui.Trigger('f3')]
    });
    ve.ui.triggerRegistry.register('findPrevious', {
        mac: new ve.ui.Trigger('cmd+shift+g'),
        pc: [new ve.ui.Trigger('shift+ctrl+g'), new ve.ui.Trigger('shift+f3')]
    });
    ve.ui.triggerRegistry.register('enterTableCell', [new ve.ui.Trigger('enter'), new ve.ui.Trigger('shift+enter'), new ve.ui.Trigger('f2')]);
    ve.ui.triggerRegistry.register('submit', {
        mac: new ve.ui.Trigger('cmd+enter'),
        pc: new ve.ui.Trigger('ctrl+enter')
    });
    ve.ui.triggerRegistry.register('focusContext', {
        mac: new ve.ui.Trigger('cmd+shift+enter'),
        pc: new ve.ui.Trigger('ctrl+shift+enter')
    });
    ve.ui.Sequence = function VeUiSequence(name, commandName, data, strip, setSelection, delayed, checkOnPaste, checkOnDelete) {
        this.name = name;
        this.commandName = commandName;
        this.data = data;
        this.strip = strip;
        this.setSelection = setSelection;
        this.delayed = delayed;
        this.checkOnPaste = checkOnPaste;
        this.checkOnDelete = checkOnDelete;
    }
    ;
    OO.initClass(ve.ui.Sequence);
    ve.ui.Sequence.prototype.match = function(data, offset, plaintext) {
        var i, j = offset - 1;
        if (this.data instanceof RegExp) {
            i = plaintext.search(this.data);
            return (i < 0) ? null : new ve.Range(offset - plaintext.length + i,offset);
        }
        for (i = this.data.length - 1; i >= 0; i--,
        j--) {
            if (typeof this.data[i] === 'string') {
                if (this.data[i] !== data.getCharacterData(j)) {
                    return null;
                }
            } else if (!ve.compare(this.data[i], data.getData(j), true)) {
                return null;
            }
        }
        return new ve.Range(offset - this.data.length,offset);
    }
    ;
    ve.ui.Sequence.prototype.execute = function(surface, range) {
        var command, stripRange, executed, stripFragment, originalSelectionFragment, args, surfaceModel = surface.getModel();
        if (surface.getCommands().indexOf(this.getCommandName()) === -1) {
            return false;
        }
        command = surface.commandRegistry.lookup(this.getCommandName());
        if (!command) {
            return false;
        }
        if (this.strip) {
            stripRange = surfaceModel.getSelection().getRange();
            stripFragment = surfaceModel.getLinearFragment(new ve.Range(stripRange.end,stripRange.end - this.strip), true, true);
        }
        surfaceModel.breakpoint();
        originalSelectionFragment = surfaceModel.getFragment();
        if (this.setSelection) {
            surfaceModel.setLinearSelection(range);
        }
        if (command.getAction() === 'window' && command.getMethod() === 'open') {
            args = ve.copy(command.args);
            args[1] = args[1] || {};
            args[1].strippedSequence = !!this.strip;
        }
        if (stripFragment) {
            stripFragment.removeContent();
        }
        executed = command.execute(surface, args, 'sequence');
        if (!executed || this.delayed) {
            originalSelectionFragment.select();
        }
        if (stripFragment && !executed) {
            surfaceModel.undo();
            surfaceModel.truncateUndoStack();
            surfaceModel.emit('history');
        }
        return executed;
    }
    ;
    ve.ui.Sequence.prototype.getName = function() {
        return this.name;
    }
    ;
    ve.ui.Sequence.prototype.getCommandName = function() {
        return this.commandName;
    }
    ;
    ve.ui.Sequence.prototype.getMessage = function(explode) {
        var data;
        if (typeof this.data === 'string') {
            data = this.data.split('');
        } else if (this.data instanceof RegExp) {
            data = [this.data.toString()];
        } else {
            data = this.data.filter(function(key) {
                return !ve.isPlainObject(key);
            });
        }
        return explode ? data : data.join('');
    }
    ;
    ve.ui.SequenceRegistry = function VeUiSequenceRegistry() {
        ve.ui.SequenceRegistry.super.call(this);
    }
    ;
    OO.inheritClass(ve.ui.SequenceRegistry, OO.Registry);
    ve.ui.SequenceRegistry.prototype.register = function(sequence) {
        if (!(sequence instanceof ve.ui.Sequence)) {
            throw new Error('sequence must be an instance of ve.ui.Sequence, cannot be a ' + typeof sequence);
        }
        ve.ui.SequenceRegistry.super.prototype.register.call(this, sequence.getName(), sequence);
    }
    ;
    ve.ui.SequenceRegistry.prototype.findMatching = function(data, offset, isPaste, isDelete) {
        var textStart, plaintext, name, range, sequence, state = 0, sequences = [];
        for (textStart = offset - 1; textStart >= 0 && (offset - textStart) <= 256; textStart--) {
            if (state === 0 && !data.isOpenElementData(textStart)) {
                state++;
            }
            if (state === 1 && !data.isCloseElementData(textStart)) {
                state++;
            }
            if (state === 2 && data.isElementData(textStart)) {
                break;
            }
        }
        plaintext = data.getText(true, new ve.Range(textStart + 1,offset));
        for (name in this.registry) {
            sequence = this.registry[name];
            if (isPaste && !sequence.checkOnPaste) {
                continue;
            }
            if (isDelete && !sequence.checkOnDelete) {
                continue;
            }
            range = sequence.match(data, offset, plaintext);
            if (range !== null) {
                sequences.push({
                    sequence: sequence,
                    range: range
                });
            }
        }
        return sequences;
    }
    ;
    ve.ui.sequenceRegistry = new ve.ui.SequenceRegistry();
    ve.ui.sequenceRegistry.register(new ve.ui.Sequence('bulletStar','bulletWrapOnce',[{
        type: 'paragraph'
    }, '*', ' '],2));
    ve.ui.sequenceRegistry.register(new ve.ui.Sequence('numberDot','numberWrapOnce',[{
        type: 'paragraph'
    }, '1', '.', ' '],3));
    ve.ui.sequenceRegistry.register(new ve.ui.Sequence('horizontalRule','insertHorizontalRule',[{
        type: 'paragraph'
    }, '-', '-', '-', '-'],4));
    ve.ui.Action = function VeUiAction(surface) {
        this.surface = surface;
    }
    ;
    OO.initClass(ve.ui.Action);
    ve.ui.Action.static.methods = [];
    ve.ui.ActionFactory = function VeUiActionFactory() {
        OO.Factory.call(this);
    }
    ;
    OO.inheritClass(ve.ui.ActionFactory, OO.Factory);
    ve.ui.ActionFactory.prototype.doesActionSupportMethod = function(action, method) {
        if (Object.prototype.hasOwnProperty.call(this.registry, action)) {
            return this.registry[action].static.methods.indexOf(method) !== -1;
        }
        throw new Error('Unknown action: ' + action);
    }
    ;
    ve.ui.actionFactory = new ve.ui.ActionFactory();
    ve.ui.DataTransferHandler = function VeUiDataTransferHandler(surface, item) {
        this.surface = surface;
        this.item = item;
        this.progress = !1;
        this.progressBar = null;
        this.insertableDataDeferred = ve.createDeferred();
    }
    ;
    OO.initClass(ve.ui.DataTransferHandler);
    ve.ui.DataTransferHandler.static.name = null;
    ve.ui.DataTransferHandler.static.kinds = null;
    ve.ui.DataTransferHandler.static.types = [];
    ve.ui.DataTransferHandler.static.handlesPaste = !0;
    ve.ui.DataTransferHandler.static.handlesPasteSpecial = !1;
    ve.ui.DataTransferHandler.static.matchFunction = null;
    ve.ui.DataTransferHandler.prototype.process = null;
    ve.ui.DataTransferHandler.prototype.getInsertableData = function() {
        this.process();
        return this.insertableDataDeferred.promise();
    }
    ;
    ve.ui.DataTransferHandler.prototype.resolve = function(dataOrDoc) {
        this.insertableDataDeferred.resolve(dataOrDoc);
    }
    ;
    ve.ui.DataTransferHandler.prototype.abort = function() {
        this.insertableDataDeferred.reject();
    }
    ;
    ve.ui.DataTransferHandler.prototype.createProgress = function(progressCompletePromise, label) {
        var handler = this;
        this.surface.createProgress(progressCompletePromise, label).done(function(progressBar, cancelPromise) {
            progressBar.setProgress(handler.progress);
            handler.progressBar = progressBar;
            cancelPromise.fail(handler.abort.bind(handler));
        });
    }
    ;
    ve.ui.DataTransferHandler.prototype.setProgress = function(progress) {
        this.progress = progress;
        if (this.progressBar) {
            this.progressBar.setProgress(this.progress);
        }
    }
    ;
    ve.ui.FileTransferHandler = function VeUiFileTransferHandler() {
        ve.ui.FileTransferHandler.super.apply(this, arguments);
        this.file = this.item.getAsFile();
        this.reader = new FileReader();
        this.reader.addEventListener('progress', this.onFileProgress.bind(this));
        this.reader.addEventListener('load', this.onFileLoad.bind(this));
        this.reader.addEventListener('error', this.onFileError.bind(this));
    }
    ;
    OO.inheritClass(ve.ui.FileTransferHandler, ve.ui.DataTransferHandler);
    ve.ui.FileTransferHandler.static.kinds = ['file'];
    ve.ui.FileTransferHandler.static.extensions = [];
    ve.ui.FileTransferHandler.prototype.process = function() {
        this.createProgress(this.insertableDataDeferred.promise());
        this.reader.readAsText(this.file);
    }
    ;
    ve.ui.FileTransferHandler.prototype.onFileProgress = function(e) {
        if (e.lengthComputable) {
            this.setProgress(100 * e.loaded / e.total);
        } else {
            this.setProgress(false);
        }
    }
    ;
    ve.ui.FileTransferHandler.prototype.onFileLoad = function() {
        this.setProgress(100);
    }
    ;
    ve.ui.FileTransferHandler.prototype.onFileError = function() {
        this.abort();
    }
    ;
    ve.ui.FileTransferHandler.prototype.abort = function() {
        ve.ui.FileTransferHandler.super.prototype.abort.apply(this, arguments);
        this.reader.abort();
    }
    ;
    ve.ui.FileTransferHandler.prototype.createProgress = function(progressCompletePromise, label) {
        label = label || this.file.name;
        ve.ui.FileTransferHandler.super.prototype.createProgress.call(this, progressCompletePromise, label);
    }
    ;
    ve.ui.DataTransferHandlerFactory = function VeUiDataTransferHandlerFactory() {
        ve.ui.DataTransferHandlerFactory.super.apply(this, arguments);
        this.handlerNamesByType = {};
        this.handlerNamesByKindAndType = {};
        this.handlerNamesByExtension = {};
    }
    ;
    OO.inheritClass(ve.ui.DataTransferHandlerFactory, OO.Factory);
    ve.ui.DataTransferHandlerFactory.prototype.register = function(constructor) {
        ve.ui.DataTransferHandlerFactory.super.prototype.register.apply(this, arguments);
        this.updateIndexes(constructor, true);
    }
    ;
    ve.ui.DataTransferHandlerFactory.prototype.unregister = function(constructor) {
        ve.ui.DataTransferHandlerFactory.super.prototype.unregister.apply(this, arguments);
        this.updateIndexes(constructor, false);
    }
    ;
    ve.ui.DataTransferHandlerFactory.prototype.updateIndexes = function(constructor, insert) {
        var i, j, ilen, jlen, kinds = constructor.static.kinds, types = constructor.static.types, extensions = constructor.static.extensions;
        function ensureArray(obj, prop) {
            if (obj[prop] === undefined) {
                obj[prop] = [];
            }
            return obj[prop];
        }
        function ensureMap(obj, prop) {
            if (obj[prop] === undefined) {
                obj[prop] = {};
            }
            return obj[prop];
        }
        function remove(arr, item) {
            var index;
            if ((index = arr.indexOf(item)) !== -1) {
                arr.splice(index, 1);
            }
        }
        if (!kinds) {
            for (j = 0,
            jlen = types.length; j < jlen; j++) {
                if (insert) {
                    ensureArray(this.handlerNamesByType, types[j]).unshift(constructor.static.name);
                } else {
                    remove(this.handlerNamesByType[types[j]], constructor.static.name);
                }
            }
        } else {
            for (i = 0,
            ilen = kinds.length; i < ilen; i++) {
                for (j = 0,
                jlen = types.length; j < jlen; j++) {
                    if (insert) {
                        ensureArray(ensureMap(this.handlerNamesByKindAndType, kinds[i]), types[j]).unshift(constructor.static.name);
                    } else {
                        remove(this.handlerNamesByKindAndType[kinds[i]][types[j]], constructor.static.name);
                    }
                }
            }
        }
        if (constructor.prototype instanceof ve.ui.FileTransferHandler) {
            for (i = 0,
            ilen = extensions.length; i < ilen; i++) {
                if (insert) {
                    ensureArray(this.handlerNamesByExtension, extensions[i]).unshift(constructor.static.name);
                } else {
                    remove(this.handlerNamesByExtension[extensions[i]], constructor.static.name);
                }
            }
        }
    }
    ;
    ve.ui.DataTransferHandlerFactory.prototype.getHandlerNameForItem = function(item, isPaste, isPasteSpecial) {
        var i, name, constructor, names;
        function fetch(obj) {
            var i;
            for (i = 1; i < arguments.length; i++) {
                if (typeof arguments[i] !== 'string' || !Object.prototype.hasOwnProperty.call(obj, arguments[i])) {
                    return [];
                }
                obj = obj[arguments[i]];
            }
            return obj;
        }
        names = [].concat(fetch(this.handlerNamesByKindAndType, item.kind, item.type), fetch(this.handlerNamesByType, item.type), fetch(this.handlerNamesByExtension, item.getExtension()));
        for (i = 0; i < names.length; i++) {
            name = names[i];
            constructor = this.registry[name];
            if (isPasteSpecial && !constructor.static.handlesPasteSpecial) {
                continue;
            }
            if (isPaste && !constructor.static.handlesPaste) {
                continue;
            }
            if (constructor.static.matchFunction && !constructor.static.matchFunction(item)) {
                continue;
            }
            return name;
        }
        return;
    }
    ;
    ve.ui.dataTransferHandlerFactory = new ve.ui.DataTransferHandlerFactory();
    ve.ui.DataTransferItem = function VeUiDataTransferItem(kind, type, data, name) {
        this.kind = kind;
        this.type = type;
        this.data = data || {};
        this.blob = this.data.blob || null;
        this.stringData = this.data.stringData || ve.getProp(this.blob, 'name') || '';
        this.name = name;
    }
    ;
    OO.initClass(ve.ui.DataTransferItem);
    ve.ui.DataTransferItem.static.newFromBlob = function(blob, htmlStringData) {
        return new ve.ui.DataTransferItem('file',blob.type,{
            blob: blob,
            htmlStringData: htmlStringData
        },blob.name);
    }
    ;
    ve.ui.DataTransferItem.static.newFromDataUri = function(dataUri, htmlStringData) {
        var parts = dataUri.split(',');
        return new ve.ui.DataTransferItem('file',parts[0].match(/^data:([^;]+)/)[1],{
            dataUri: parts[1],
            htmlStringData: htmlStringData
        });
    }
    ;
    ve.ui.DataTransferItem.static.newFromString = function(stringData, type, htmlStringData) {
        return new ve.ui.DataTransferItem('string',type || 'text/plain',{
            stringData: stringData,
            htmlStringData: htmlStringData
        });
    }
    ;
    ve.ui.DataTransferItem.static.newFromItem = function(item, htmlStringData) {
        return new ve.ui.DataTransferItem(item.kind,item.type,{
            item: item,
            htmlStringData: htmlStringData
        },item.getAsFile().name);
    }
    ;
    ve.ui.DataTransferItem.prototype.getAsFile = function() {
        var binary, array, i;
        if (this.data.item) {
            return this.data.item.getAsFile();
        }
        if (!this.blob && this.data.dataUri) {
            binary = atob(this.data.dataUri);
            delete this.data.dataUri;
            array = [];
            for (i = 0; i < binary.length; i++) {
                array.push(binary.charCodeAt(i));
            }
            this.blob = new Blob([new Uint8Array(array)],{
                type: this.type
            });
        }
        return this.blob;
    }
    ;
    ve.ui.DataTransferItem.prototype.getExtension = function() {
        return this.name ? this.name.split('.').pop() : null;
    }
    ;
    ve.ui.DataTransferItem.prototype.getAsString = function() {
        return this.stringData;
    }
    ;
    ve.ui.WindowManager = function VeUiWindowManager(config) {
        config = config || {};
        ve.ui.WindowManager.super.call(this, config);
        this.overlay = config.overlay || null;
        this.$element.addClass('ve-ui-dir-block-' + this.getDir());
    }
    ;
    OO.inheritClass(ve.ui.WindowManager, OO.ui.WindowManager);
    ve.ui.WindowManager.prototype.getDir = function() {
        return $(document.body).css('direction');
    }
    ;
    ve.ui.WindowManager.prototype.getOverlay = function() {
        return this.overlay;
    }
    ;
    ve.ui.FragmentWindow = function VeUiFragmentWindow() {
        this.fragment = null;
    }
    ;
    OO.initClass(ve.ui.FragmentWindow);
    ve.ui.FragmentWindow.prototype.getFragment = function() {
        return this.fragment;
    }
    ;
    ve.ui.FragmentWindow.prototype.getActionWidgetConfig = function(config) {
        if (config.action === 'done' && OO.ui.isMobile()) {
            config = ve.extendObject({
                icon: 'check',
                invisibleLabel: !0
            }, config);
        }
        return config;
    }
    ;
    ve.ui.FragmentWindow.prototype.getSetupProcess = function(data, process) {
        data = data || {};
        return process.first(function() {
            if (!(data.fragment instanceof ve.dm.SurfaceFragment)) {
                throw new Error('Cannot open dialog: opening data must contain a fragment');
            }
            this.fragment = data.fragment;
            this.initialFragment = data.fragment;
            this.previousSelection = this.fragment.getSelection();
        }, this).next(function() {
            if (!this.isEditing() && this.isReadOnly()) {
                return ve.createDeferred().reject().promise();
            }
            this.actions.setMode(this.getMode());
        }, this);
    }
    ;
    ve.ui.FragmentWindow.prototype.getTeardownProcess = function(data, process) {
        ve.track('activity.' + this.constructor.static.name, {
            action: 'dialog-' + (data && data.action || 'abort')
        });
        return process.next(function() {
            this.fragment = null;
            this.initialFragment = null;
            this.previousSelection = null;
        }, this);
    }
    ;
    ve.ui.FragmentWindow.prototype.isReadOnly = function() {
        var fragment = this.getFragment()
          , surface = fragment && fragment.getSurface();
        return surface && surface.isReadOnly();
    }
    ;
    ve.ui.FragmentWindow.prototype.getMode = function() {
        if (this.isReadOnly()) {
            return 'readonly';
        }
        if (this.getFragment()) {
            return this.isEditing() ? 'edit' : 'insert';
        }
        return '';
    }
    ;
    ve.ui.FragmentWindow.prototype.isEditing = function() {
        return !!this.fragment.getSelectedModels().length;
    }
    ;
    ve.ui.NodeWindow = function VeUiNodeWindow() {
        ve.ui.NodeWindow.super.apply(this, arguments);
        this.selectedNode = null;
    }
    ;
    OO.inheritClass(ve.ui.NodeWindow, ve.ui.FragmentWindow);
    ve.ui.NodeWindow.static.modelClasses = [];
    ve.ui.NodeWindow.prototype.isEditing = function() {
        return !!this.getSelectedNode();
    }
    ;
    ve.ui.NodeWindow.prototype.getSelectedNode = function() {
        var modelClasses = this.constructor.static.modelClasses
          , selectedNode = this.getFragment().getSelectedNode();
        if (selectedNode && modelClasses.some(function(modelClass) {
            return selectedNode instanceof modelClass;
        })) {
            return selectedNode;
        }
        return null;
    }
    ;
    ve.ui.NodeWindow.prototype.getSetupProcess = function(data, process) {
        return ve.ui.NodeWindow.super.prototype.getSetupProcess.call(this, data, process).next(function() {
            this.selectedNode = this.getSelectedNode(data);
        }, this);
    }
    ;
    ve.ui.NodeWindow.prototype.getTeardownProcess = function(data, process) {
        return ve.ui.NodeWindow.super.prototype.getTeardownProcess.call(this, data, process).next(function() {
            this.selectedNode = null;
        }, this);
    }
    ;
    ve.ui.TabIndexScope = function VeUiTabIndexScope(config) {
        config = ve.extendObject({
            root: !1,
            skipAriaDisabled: !0,
            skipAriaHidden: !0
        }, config);
        this.skipAriaDisabled = config.skipAriaDisabled;
        this.skipAriaHidden = config.skipAriaHidden;
        this.onRootKeyDownBound = this.onRootKeyDown.bind(this);
        if (config.root) {
            this.setTabRoot(config.root);
        }
    }
    ;
    OO.initClass(ve.ui.TabIndexScope);
    ve.ui.TabIndexScope.prototype.setTabRoot = function($root) {
        if (this.$root) {
            this.$root.off('keydown', this.onRootKeyDownBound);
        }
        this.$root = $($root).on('keydown', this.onRootKeyDownBound);
    }
    ;
    ve.ui.TabIndexScope.prototype.getElementsInRoot = function() {
        var self = this
          , elements = this.$root.find('*').filter(function() {
            if (this.tabIndex === -1) {
                return false;
            }
            if (self.skipAriaDisabled && this.getAttribute('aria-disabled') === 'true') {
                return false;
            }
            if (self.skipAriaHidden && $(this).closest('[aria-hidden="true"]', self.$root[0]).length) {
                return false;
            }
            return OO.ui.isFocusableElement($(this));
        }).map(function(index) {
            return {
                element: this,
                index: index
            };
        }).get();
        elements.sort(function(a, b) {
            if (a.element.tabIndex < b.element.tabIndex) {
                return -1;
            }
            if (a.element.tabIndex > b.element.tabIndex) {
                return 1;
            }
            return a.index - b.index;
        });
        return elements.map(function(data) {
            return data.element;
        });
    }
    ;
    ve.ui.TabIndexScope.prototype.onRootKeyDown = function(e) {
        var elements, index;
        if (e.which !== OO.ui.Keys.TAB) {
            return;
        }
        elements = this.getElementsInRoot();
        index = elements.indexOf(e.target);
        if (index === -1) {
            return;
        }
        index += e.shiftKey ? -1 : 1;
        if ((index < 0 || index >= elements.length)) {
            return;
        }
        e.preventDefault();
        elements[index].focus();
    }
    ;
    ve.ui.TabIndexScope.prototype.teardown = function() {
        this.setRoot([]);
    }
    ;
    ve.ui.SurfaceWindowManager = function VeUiSurfaceWindowManager(surface, config) {
        this.surface = surface;
        ve.ui.SurfaceWindowManager.super.call(this, config);
    }
    ;
    OO.inheritClass(ve.ui.SurfaceWindowManager, ve.ui.WindowManager);
    ve.ui.SurfaceWindowManager.prototype.getDir = function() {
        return this.surface.getDir() || ve.ui.SurfaceWindowManager.super.prototype.getDir.call(this);
    }
    ;
    ve.ui.SurfaceWindowManager.prototype.getSurface = function() {
        return this.surface;
    }
    ;
    ve.ui.AnnotationAction = function VeUiAnnotationAction() {
        ve.ui.AnnotationAction.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.AnnotationAction, ve.ui.Action);
    ve.ui.AnnotationAction.static.name = 'annotation';
    ve.ui.AnnotationAction.static.methods = ['set', 'clear', 'toggle', 'clearAll'];
    ve.ui.AnnotationAction.prototype.set = function(name, data) {
        ve.track('activity.' + name, {
            action: 'set'
        });
        return this.setInternal(name, data);
    }
    ;
    ve.ui.AnnotationAction.prototype.clear = function(name, data) {
        ve.track('activity.' + name, {
            action: 'clear'
        });
        this.surface.getModel().getFragment().annotateContent('clear', name, data);
        return true;
    }
    ;
    ve.ui.AnnotationAction.prototype.toggle = function(name, data) {
        var existingAnnotations, insertionAnnotations, removesAnnotations, surfaceModel = this.surface.getModel(), fragment = surfaceModel.getFragment(), annotation = ve.dm.annotationFactory.create(name, data), removes = annotation.constructor.static.removes;
        if (!fragment.getSelection().isCollapsed()) {
            ve.track('activity.' + name, {
                action: 'toggle-selection'
            });
            if (!fragment.getAnnotations().containsComparable(annotation)) {
                this.setInternal(name, data);
            } else {
                fragment.annotateContent('clear', name);
            }
        } else if (surfaceModel.sourceMode) {
            return false;
        } else {
            ve.track('activity.' + name, {
                action: 'toggle-insertion'
            });
            insertionAnnotations = surfaceModel.getInsertionAnnotations();
            existingAnnotations = insertionAnnotations.getAnnotationsByName(annotation.name);
            if (existingAnnotations.isEmpty()) {
                removesAnnotations = insertionAnnotations.filter(function(annotation) {
                    return removes.indexOf(annotation.name) !== -1;
                });
                surfaceModel.removeInsertionAnnotations(removesAnnotations);
                surfaceModel.addInsertionAnnotations(annotation);
            } else {
                surfaceModel.removeInsertionAnnotations(existingAnnotations);
            }
        }
        return true;
    }
    ;
    ve.ui.AnnotationAction.prototype.clearAll = function() {
        var i, len, arr, surfaceModel = this.surface.getModel(), fragment = surfaceModel.getFragment(), annotations = fragment.getAnnotations(true);
        ve.track('activity.allAnnotations', {
            action: 'clear-all'
        });
        arr = annotations.get();
        for (i = 0,
        len = arr.length; i < len; i++) {
            fragment.annotateContent('clear', arr[i].name, arr[i].data);
        }
        surfaceModel.setInsertionAnnotations(null);
        return true;
    }
    ;
    ve.ui.AnnotationAction.prototype.setInternal = function(name, data) {
        var i, trimmedFragment, fragment = this.surface.getModel().getFragment(), annotationClass = ve.dm.annotationFactory.lookup(name), removes = annotationClass.static.removes;
        if (fragment.getSelection()instanceof ve.dm.LinearSelection) {
            trimmedFragment = fragment.trimLinearSelection();
            if (!trimmedFragment.getSelection().isCollapsed()) {
                fragment = trimmedFragment;
            }
        }
        for (i = removes.length - 1; i >= 0; i--) {
            fragment.annotateContent('clear', removes[i]);
        }
        fragment.annotateContent('set', name, data);
        return true;
    }
    ;
    ve.ui.actionFactory.register(ve.ui.AnnotationAction);
    ve.ui.BlockquoteAction = function VeUiBlockquoteAction() {
        ve.ui.BlockquoteAction.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.BlockquoteAction, ve.ui.Action);
    ve.ui.BlockquoteAction.static.name = 'blockquote';
    ve.ui.BlockquoteAction.static.methods = ['wrap', 'unwrap', 'toggle'];
    ve.ui.BlockquoteAction.prototype.isWrapped = function() {
        var fragment = this.surface.getModel().getFragment();
        return fragment.hasMatchingAncestor('blockquote');
    }
    ;
    ve.ui.BlockquoteAction.prototype.toggle = function() {
        return this[this.isWrapped() ? 'unwrap' : 'wrap']();
    }
    ;
    ve.ui.BlockquoteAction.prototype.wrap = function() {
        var surfaceModel = this.surface.getModel(), selection = surfaceModel.getSelection(), fragment = surfaceModel.getFragment(null, true), leaves, leavesRange;
        if (!(selection instanceof ve.dm.LinearSelection)) {
            return false;
        }
        leaves = fragment.getSelectedLeafNodes();
        leavesRange = new ve.Range(leaves[0].getRange().start,leaves[leaves.length - 1].getRange().end);
        fragment = surfaceModel.getLinearFragment(leavesRange, true);
        fragment = fragment.expandLinearSelection('siblings');
        while (fragment.getCoveredNodes().some(function(nodeInfo) {
            return !nodeInfo.node.isAllowedParentNodeType('blockquote') || nodeInfo.node.isContent();
        })) {
            fragment = fragment.expandLinearSelection('parent');
        }
        fragment.wrapAllNodes({
            type: 'blockquote'
        });
        return true;
    }
    ;
    ve.ui.BlockquoteAction.prototype.unwrap = function() {
        var surfaceModel = this.surface.getModel(), selection = surfaceModel.getSelection(), fragment = surfaceModel.getFragment(null, true), leaves, leavesRange;
        if (!(selection instanceof ve.dm.LinearSelection)) {
            return false;
        }
        if (!this.isWrapped()) {
            return false;
        }
        leaves = fragment.getSelectedLeafNodes();
        leavesRange = new ve.Range(leaves[0].getRange().start,leaves[leaves.length - 1].getRange().end);
        fragment = surfaceModel.getLinearFragment(leavesRange, true);
        fragment.expandLinearSelection('closest', ve.dm.BlockquoteNode).unwrapNodes(0, 1);
        return true;
    }
    ;
    ve.ui.actionFactory.register(ve.ui.BlockquoteAction);
    ve.ui.CompletionAction = function VeUiCompletionAction() {
        ve.ui.CompletionAction.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.CompletionAction, ve.ui.Action);
    ve.ui.CompletionAction.static.defaultLimit = 8;
    ve.ui.CompletionAction.static.triggerLength = 1;
    ve.ui.CompletionAction.static.alwaysIncludeInput = !0;
    ve.ui.CompletionAction.static.methods = ['open'];
    ve.ui.CompletionAction.prototype.open = function() {
        this.surface.completion.setup(this);
        return true;
    }
    ;
    ve.ui.CompletionAction.prototype.getSuggestions = null;
    ve.ui.CompletionAction.prototype.insertCompletion = function(data, range) {
        return this.surface.getModel().getLinearFragment(range).insertContent(data, true);
    }
    ;
    ve.ui.CompletionAction.prototype.shouldAbandon = function(input, matches) {
        return matches === (this.constructor.static.alwaysIncludeInput ? 1 : 0) && !!(input && input.match(/\s$/));
    }
    ;
    ve.ui.CompletionAction.prototype.getMenuItemForSuggestion = function(suggestion) {
        return new OO.ui.MenuOptionWidget({
            data: suggestion,
            label: suggestion
        });
    }
    ;
    ve.ui.CompletionAction.prototype.filterSuggestionsForInput = function(suggestions, input) {
        var exact = !1
          , inputTrimmed = input.trim()
          , inputTrimmedLower = inputTrimmed.toLowerCase().trim();
        suggestions = suggestions.filter(function(word) {
            var wordLower = word.toLowerCase();
            exact = exact || wordLower === inputTrimmedLower;
            return wordLower.slice(0, inputTrimmedLower.length) === inputTrimmedLower;
        });
        if (this.constructor.static.defaultLimit < suggestions.length) {
            suggestions.length = this.constructor.static.defaultLimit;
        }
        if (!exact && this.constructor.static.alwaysIncludeInput && inputTrimmed.length) {
            suggestions.push(inputTrimmed);
        }
        return suggestions;
    }
    ;
    ve.ui.ContentAction = function VeUiContentAction() {
        ve.ui.ContentAction.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.ContentAction, ve.ui.Action);
    ve.ui.ContentAction.static.name = 'content';
    ve.ui.ContentAction.static.methods = ['insert', 'remove', 'select', 'pasteSpecial', 'selectAll', 'changeDirectionality', 'submit', 'focusContext'];
    ve.ui.ContentAction.prototype.insert = function(content, annotate, collapseToEnd) {
        var fragment = this.surface.getModel().getFragment();
        fragment.insertContent(content, annotate);
        if (collapseToEnd) {
            fragment.collapseToEnd().select();
        }
        return true;
    }
    ;
    ve.ui.ContentAction.prototype.remove = function(key) {
        var e, defaultPrevented = !1;
        if (key) {
            e = {
                keyCode: key === 'delete' ? OO.ui.Keys.DELETE : OO.ui.Keys.BACKSPACE,
                preventDefault: function() {
                    defaultPrevented = !0;
                }
            };
            ve.ce.keyDownHandlerFactory.executeHandlersForKey(e.keyCode, this.surface.getModel().getSelection().getName(), this.surface.getView(), e);
            return defaultPrevented;
        } else {
            this.surface.getModel().getFragment().removeContent();
            return true;
        }
    }
    ;
    ve.ui.ContentAction.prototype.select = function(selection) {
        this.surface.getModel().setSelection(selection);
        return true;
    }
    ;
    ve.ui.ContentAction.prototype.selectAll = function() {
        this.surface.getView().selectAll();
        return true;
    }
    ;
    ve.ui.ContentAction.prototype.pasteSpecial = function() {
        this.surface.getView().pasteSpecial = !0;
        return false;
    }
    ;
    ve.ui.ContentAction.prototype.changeDirectionality = function() {
        var documentView = this.surface.getView().getDocument();
        documentView.setDir(documentView.getDir() === 'ltr' ? 'rtl' : 'ltr');
        this.surface.getModel().emit('contextChange');
        this.surface.getView().emit('position');
        return true;
    }
    ;
    ve.ui.ContentAction.prototype.submit = function() {
        this.surface.emit('submit');
        return true;
    }
    ;
    ve.ui.ContentAction.prototype.focusContext = function() {
        var $focusable;
        if (this.surface.getContext().isVisible()) {
            this.surface.getContext().$focusTrapBefore.prop('disabled', true);
            $focusable = OO.ui.findFocusable(this.surface.getContext().$element);
            this.surface.getContext().$focusTrapBefore.prop('disabled', false);
            if ($focusable.length) {
                this.surface.getView().deactivate();
                $focusable[0].focus();
                return true;
            }
        }
        return false;
    }
    ;
    ve.ui.actionFactory.register(ve.ui.ContentAction);
    ve.ui.FormatAction = function VeUiFormatAction() {
        ve.ui.FormatAction.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.FormatAction, ve.ui.Action);
    ve.ui.FormatAction.static.name = 'format';
    ve.ui.FormatAction.static.methods = ['convert'];
    ve.ui.FormatAction.prototype.convert = function(type, attributes) {
        var selected, i, length, contentBranch, surfaceModel = this.surface.getModel(), fragment = surfaceModel.getFragment(), fragmentSelection = fragment.getSelection(), fragments = [];
        if (!(fragmentSelection instanceof ve.dm.LinearSelection)) {
            return;
        }
        selected = fragment.getLeafNodes();
        for (i = 0,
        length = selected.length; i < length; i++) {
            contentBranch = selected[i].node.isContent() ? selected[i].node.getParent() : selected[i].node;
            fragments.push(surfaceModel.getLinearFragment(contentBranch.getOuterRange(), true));
        }
        for (i = 0,
        length = fragments.length; i < length; i++) {
            fragments[i].isolateAndUnwrap(type);
        }
        fragment.convertNodes(type, attributes);
        if (fragmentSelection.isCollapsed()) {
            surfaceModel.setSelection(fragmentSelection);
        }
        this.surface.getView().focus();
        ve.track('activity.format', {
            action: type + (attributes && attributes.level ? ('-' + attributes.level) : '')
        });
        return true;
    }
    ;
    ve.ui.actionFactory.register(ve.ui.FormatAction);
    ve.ui.HistoryAction = function VeUiHistoryAction() {
        ve.ui.HistoryAction.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.HistoryAction, ve.ui.Action);
    ve.ui.HistoryAction.static.name = 'history';
    ve.ui.HistoryAction.static.methods = ['undo', 'redo'];
    ve.ui.HistoryAction.prototype.undo = function() {
        this.surface.getModel().undo();
        return true;
    }
    ;
    ve.ui.HistoryAction.prototype.redo = function() {
        this.surface.getModel().redo();
        return true;
    }
    ;
    ve.ui.actionFactory.register(ve.ui.HistoryAction);
    ve.ui.IndentationAction = function VeUiIndentationAction() {
        ve.ui.IndentationAction.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.IndentationAction, ve.ui.Action);
    ve.ui.IndentationAction.static.name = 'indentation';
    ve.ui.IndentationAction.static.methods = ['increase', 'decrease'];
    ve.ui.IndentationAction.prototype.increase = function() {
        var i, group, groups, fragments = [], increased = !1, surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument(), fragment = surfaceModel.getFragment();
        if (!(fragment.getSelection()instanceof ve.dm.LinearSelection)) {
            return;
        }
        groups = documentModel.getCoveredSiblingGroups(fragment.getSelection().getRange());
        for (i = 0; i < groups.length; i++) {
            group = groups[i];
            if (group.grandparent && group.grandparent.getType() === 'list') {
                fragments.push(surfaceModel.getLinearFragment(group.parent.getRange(), true));
                increased = !0;
            }
        }
        for (i = 0; i < fragments.length; i++) {
            this.indentListItem(documentModel.getBranchNodeFromOffset(fragments[i].getSelection().getRange().start));
        }
        fragment.select();
        return increased;
    }
    ;
    ve.ui.IndentationAction.prototype.decrease = function() {
        var i, group, groups, fragments = [], decreased = !1, surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument(), fragment = surfaceModel.getFragment();
        if (!(fragment.getSelection()instanceof ve.dm.LinearSelection)) {
            return;
        }
        groups = documentModel.getCoveredSiblingGroups(fragment.getSelection().getRange());
        for (i = 0; i < groups.length; i++) {
            group = groups[i];
            if (group.grandparent && group.grandparent.getType() === 'list') {
                fragments.push(surfaceModel.getLinearFragment(group.parent.getRange(), true));
                decreased = !0;
            } else if (group.parent && group.parent.getType() === 'list') {
                fragments.push(surfaceModel.getLinearFragment(group.nodes[0].getRange(), true));
                decreased = !0;
            }
        }
        for (i = 0; i < fragments.length; i++) {
            this.unindentListItem(documentModel.getBranchNodeFromOffset(fragments[i].getSelection().getRange().start));
        }
        fragment.select();
        return decreased;
    }
    ;
    ve.ui.IndentationAction.prototype.indentListItem = function(listItem) {
        var listType, listItemRange, mergeStart, mergeEnd, surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument(), fragment = surfaceModel.getFragment();
        if (!(listItem instanceof ve.dm.ListItemNode)) {
            throw new Error('listItem must be a ve.dm.ListItemNode');
        }
        if (!(fragment.getSelection()instanceof ve.dm.LinearSelection)) {
            return;
        }
        listType = listItem.getParent().getAttribute('style');
        listItemRange = listItem.getOuterRange();
        surfaceModel.getLinearFragment(listItemRange, true).wrapNodes([{
            type: 'listItem'
        }, {
            type: 'list',
            attributes: {
                style: listType
            }
        }]);
        if (documentModel.data.getData(listItemRange.start).type === 'listItem' && documentModel.data.getData(listItemRange.start - 1).type === '/listItem') {
            mergeStart = listItemRange.start - 1;
            mergeEnd = listItemRange.start + 1;
            if (documentModel.data.getData(mergeEnd).type === 'list' && documentModel.data.getData(mergeStart - 1).type === '/list') {
                mergeStart--;
                mergeEnd++;
            }
            surfaceModel.getLinearFragment(new ve.Range(mergeStart,mergeEnd), true).removeContent();
        }
        fragment.select();
    }
    ;
    ve.ui.IndentationAction.prototype.unindentListItem = function(listItem) {
        var tx, i, length, children, child, splitListRange, fragment, list, listElement, grandParentType, listItemRange, surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument();
        if (!(listItem instanceof ve.dm.ListItemNode)) {
            throw new Error('listItem must be a ve.dm.ListItemNode');
        }
        fragment = surfaceModel.getLinearFragment(listItem.getOuterRange(), true);
        list = listItem.getParent();
        listElement = list.getClonedElement();
        grandParentType = list.getParent().getType();
        listItemRange = listItem.getOuterRange();
        if (documentModel.data.getData(listItemRange.start - 1).type !== 'list') {
            tx = ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, listItemRange.start, [{
                type: '/list'
            }, listElement]);
            surfaceModel.change(tx);
            listItemRange = listItemRange.translate(2);
        }
        if (documentModel.data.getData(listItemRange.end).type !== '/list') {
            tx = ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, listItemRange.end, [{
                type: '/list'
            }, listElement]);
            surfaceModel.change(tx);
        }
        splitListRange = new ve.Range(listItemRange.start - 1,listItemRange.end + 1);
        if (grandParentType !== 'listItem') {
            surfaceModel.getLinearFragment(new ve.Range(listItemRange.start + 1,listItemRange.end - 1), true).unwrapNodes(2);
            children = fragment.getSiblingNodes();
            for (i = 0,
            length = children.length; i < length; i++) {
                child = children[i].node;
                if (child.type === 'paragraph') {
                    ve.deleteProp(child.element, 'internal', 'generated');
                }
            }
        } else {
            if (documentModel.data.getData(splitListRange.start - 1).type !== 'listItem') {
                tx = ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, splitListRange.start, [{
                    type: '/listItem'
                }, {
                    type: 'listItem'
                }]);
                surfaceModel.change(tx);
                splitListRange = splitListRange.translate(2);
            }
            if (documentModel.data.getData(splitListRange.end).type !== '/listItem') {
                tx = ve.dm.TransactionBuilder.static.newFromInsertion(documentModel, splitListRange.end, [{
                    type: '/listItem'
                }, {
                    type: 'listItem'
                }]);
                surfaceModel.change(tx);
            }
            surfaceModel.getLinearFragment(new ve.Range(splitListRange.start + 1,splitListRange.end - 1), true).unwrapNodes(2);
        }
    }
    ;
    ve.ui.actionFactory.register(ve.ui.IndentationAction);
    ve.ui.LinkAction = function VeUiLinkAction() {
        ve.ui.LinkAction.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.LinkAction, ve.ui.Action);
    ve.ui.LinkAction.static.name = 'link';
    ve.ui.LinkAction.static.autolinkRegExp = null;
    ve.ui.LinkAction.static.methods = ['autolinkUrl'];
    ve.ui.LinkAction.prototype.autolinkUrl = function() {
        return this.autolink(function(linktext) {
            return ve.ui.LinkAction.static.autolinkRegExp.test(linktext);
        });
    }
    ;
    ve.ui.LinkAction.prototype.autolink = function(validateFunc, txFunc) {
        var range, rangeEnd, linktext, i, surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument(), selection = surfaceModel.getSelection();
        function isLinkAnnotation(annotation) {
            return /^link/.test(annotation.name);
        }
        if (!(selection instanceof ve.dm.LinearSelection)) {
            return false;
        }
        range = selection.getRange();
        rangeEnd = range.end;
        linktext = documentModel.data.getText(true, range);
        linktext = linktext.replace(/\s+$/, '');
        linktext = linktext.replace(this.getTrailingPunctuation(linktext), '');
        if (!validateFunc(linktext)) {
            return false;
        }
        range = range.truncate(linktext.length);
        if (range.end + 1 < documentModel.data.getLength() && /\w/.test(documentModel.data.getText(true, new ve.Range(range.end,range.end + 1)))) {
            return false;
        }
        for (i = range.start; i < range.end; i++) {
            if (documentModel.data.getAnnotationsFromOffset(i).containsMatching(isLinkAnnotation)) {
                return false;
            }
        }
        surfaceModel.setLinearSelection(new ve.Range(rangeEnd));
        if (txFunc) {
            surfaceModel.change(txFunc(documentModel, range, linktext));
        } else {
            surfaceModel.getLinearFragment(range, true).annotateContent('set', this.getLinkAnnotation(linktext));
        }
        return true;
    }
    ;
    ve.ui.LinkAction.prototype.getTrailingPunctuation = function() {
        return /[,;.:!?)\]}"']+$/;
    }
    ;
    ve.ui.LinkAction.prototype.getLinkAnnotation = function(linktext) {
        return new ve.dm.LinkAnnotation({
            type: 'link',
            attributes: {
                href: linktext
            }
        });
    }
    ;
    ve.ui.actionFactory.register(ve.ui.LinkAction);
    ve.init.Platform.static.initializedPromise.then(function() {
        ve.ui.LinkAction.static.autolinkRegExp = new RegExp('\\b' + ve.init.platform.getUnanchoredExternalLinkUrlProtocolsRegExp().source + '\\S+$','i');
        ve.ui.sequenceRegistry.register(new ve.ui.Sequence('autolinkUrl','autolinkUrl',ve.ui.LinkAction.static.autolinkRegExp,0,true,true));
    });
    ve.ui.ListAction = function VeUiListAction() {
        ve.ui.ListAction.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.ListAction, ve.ui.Action);
    ve.ui.ListAction.static.name = 'list';
    ve.ui.ListAction.static.methods = ['wrap', 'unwrap', 'toggle', 'wrapOnce'];
    ve.ui.ListAction.prototype.allWrapped = function(style, listType) {
        var i, len, attributes = style ? {
            style: style
        } : undefined, nodes = this.surface.getModel().getFragment().getLeafNodes(), all = !!nodes.length;
        listType = listType || 'list';
        for (i = 0,
        len = nodes.length; i < len; i++) {
            if ((len === 1 || !nodes[i].range || nodes[i].range.getLength()) && !nodes[i].node.hasMatchingAncestor(listType, attributes)) {
                all = !1;
                break;
            }
        }
        return all;
    }
    ;
    ve.ui.ListAction.prototype.toggle = function(style, noBreakpoints, listType) {
        if (this.allWrapped(style, listType)) {
            return this.unwrap(noBreakpoints, listType);
        } else {
            return this.wrap(style, noBreakpoints, listType);
        }
    }
    ;
    ve.ui.ListAction.prototype.wrapOnce = function(style, noBreakpoints, listType) {
        if (!this.allWrapped(null, listType)) {
            return this.wrap(style, noBreakpoints, listType);
        }
        return false;
    }
    ;
    ve.ui.ListAction.prototype.wrap = function(style, noBreakpoints, listType) {
        var i, previousList, groupRange, group, range, element, itemElement, surfaceModel = this.surface.getModel(), fragment = surfaceModel.getFragment(null, true), documentModel = surfaceModel.getDocument(), selection = surfaceModel.getSelection(), groups;
        listType = listType || 'list';
        if (!(selection instanceof ve.dm.LinearSelection)) {
            return false;
        }
        range = selection.getRange();
        if (!noBreakpoints) {
            surfaceModel.breakpoint();
        }
        if (range.isCollapsed() && !documentModel.data.isContentOffset(range.to) && documentModel.hasSlugAtOffset(range.to)) {
            fragment = fragment.insertContent([{
                type: 'paragraph'
            }, {
                type: '/paragraph'
            }]).collapseToStart().adjustLinearSelection(1, 1).select();
            range = fragment.getSelection().getRange();
        }
        groups = documentModel.getCoveredSiblingGroups(range);
        for (i = 0; i < groups.length; i++) {
            group = groups[i];
            if (group.grandparent && group.grandparent.getType() === listType) {
                if (group.grandparent !== previousList) {
                    surfaceModel.getLinearFragment(group.grandparent.getOuterRange(), true).changeAttributes({
                        style: style
                    });
                    previousList = group.grandparent;
                }
            } else {
                groupRange = new ve.Range(group.nodes[0].getOuterRange().start,group.nodes[group.nodes.length - 1].getOuterRange().end);
                element = {
                    type: listType
                };
                if (style) {
                    element.attributes = {
                        style: style
                    };
                }
                itemElement = ve.dm.modelRegistry.lookup(listType).static.createItem();
                surfaceModel.getLinearFragment(groupRange, true).convertNodes('paragraph').wrapAllNodes(element, itemElement);
            }
        }
        if (!noBreakpoints) {
            surfaceModel.breakpoint();
        }
        return true;
    }
    ;
    ve.ui.ListAction.prototype.unwrap = function(noBreakpoints, listType) {
        var node, indentationAction = ve.ui.actionFactory.create('indentation', this.surface), surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument();
        listType = listType || 'list';
        if (!(surfaceModel.getSelection()instanceof ve.dm.LinearSelection)) {
            return false;
        }
        if (!noBreakpoints) {
            surfaceModel.breakpoint();
        }
        do {
            node = documentModel.getBranchNodeFromOffset(surfaceModel.getSelection().getRange().start);
        } while (node.hasMatchingAncestor(listType) && indentationAction.decrease());if (!noBreakpoints) {
            surfaceModel.breakpoint();
        }
        return true;
    }
    ;
    ve.ui.actionFactory.register(ve.ui.ListAction);
    ve.ui.TableAction = function VeUiTableAction() {
        ve.ui.TableAction.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.TableAction, ve.ui.Action);
    ve.ui.TableAction.static.name = 'table';
    ve.ui.TableAction.static.methods = ['create', 'insert', 'moveRelative', 'move', 'delete', 'importTable', 'changeCellStyle', 'mergeCells', 'enterTableCell', 'exitTableCell'];
    ve.ui.TableAction.prototype.create = function(options) {
        var i, type, tableElement, surfaceModel, fragment, data, numberOfCols, numberOfRows;
        options = options || {};
        type = options.type || 'table';
        tableElement = {
            type: type
        };
        surfaceModel = this.surface.getModel();
        fragment = surfaceModel.getFragment();
        data = [];
        numberOfCols = options.cols || 4;
        numberOfRows = options.rows || 3;
        if (!(fragment.getSelection()instanceof ve.dm.LinearSelection)) {
            return false;
        }
        if (options.attributes) {
            tableElement.attributes = ve.copy(options.attributes);
        }
        data.push(tableElement);
        if (options.caption) {
            data.push({
                type: 'tableCaption'
            }, {
                type: 'paragraph',
                internal: {
                    generated: 'wrapper'
                }
            }, {
                type: '/paragraph'
            }, {
                type: '/tableCaption'
            });
        }
        data.push({
            type: 'tableSection',
            attributes: {
                style: 'body'
            }
        });
        if (options.header) {
            data = data.concat(ve.dm.TableRowNode.static.createData({
                style: 'header',
                cellCount: numberOfCols
            }));
        }
        for (i = 0; i < numberOfRows; i++) {
            data = data.concat(ve.dm.TableRowNode.static.createData({
                style: 'data',
                cellCount: numberOfCols
            }));
        }
        data.push({
            type: '/tableSection'
        });
        data.push({
            type: '/' + type
        });
        fragment.insertContent(data, false);
        surfaceModel.setSelection(new ve.dm.TableSelection(fragment.getSelection().getRange(),0,0,0,0));
        ve.track('activity.table', {
            action: 'create'
        });
        return true;
    }
    ;
    ve.ui.TableAction.prototype.insert = function(mode, position) {
        var index, surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument(), selection = surfaceModel.getSelection();
        if (!(selection instanceof ve.dm.TableSelection)) {
            return false;
        }
        if (mode === 'col') {
            index = position === 'before' ? selection.startCol : selection.endCol;
        } else {
            index = position === 'before' ? selection.startRow : selection.endRow;
        }
        if (position === 'before') {
            if (mode === 'col') {
                selection = selection.newFromAdjustment(documentModel, 1, 0);
            } else {
                selection = selection.newFromAdjustment(documentModel, 0, 1);
            }
            surfaceModel.setSelection(selection);
        }
        this.insertRowOrCol(selection.getTableNode(documentModel), mode, index, position, selection);
        ve.track('activity.table', {
            action: 'insert-' + mode
        });
        return true;
    }
    ;
    ve.ui.TableAction.prototype.moveRelative = function(mode, direction) {
        var index, surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument(), selection = surfaceModel.getSelection(), matrix = selection.getTableNode(documentModel).getMatrix();
        if (mode === 'row') {
            if (direction === 'before') {
                index = Math.max(0, selection.startRow - 1);
            } else {
                index = Math.min(matrix.getRowCount(), selection.endRow + 2);
            }
        } else {
            if (direction === 'before') {
                index = Math.max(0, selection.startCol - 1);
            } else {
                index = Math.min(matrix.getMaxColCount(), selection.endCol + 2);
            }
        }
        return this.move(mode, index);
    }
    ;
    ve.ui.TableAction.prototype.move = function(mode, index) {
        var i, removedMatrix, position, newOffsets, surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument(), selection = surfaceModel.getSelection(), tableNode = selection.getTableNode(documentModel), matrix = tableNode.getMatrix();
        if (!(selection instanceof ve.dm.TableSelection)) {
            return false;
        }
        if (mode === 'row') {
            removedMatrix = this.deleteRowsOrColumns(matrix, mode, selection.startRow, selection.endRow);
            if (index > selection.endRow) {
                index = index - selection.getRowCount();
            }
            newOffsets = [selection.fromCol, index, selection.toCol, index + selection.getRowCount() - 1];
        } else {
            removedMatrix = this.deleteRowsOrColumns(matrix, mode, selection.startCol, selection.endCol);
            if (index > selection.endCol) {
                index = index - selection.getColCount();
            }
            newOffsets = [index, selection.fromRow, index + selection.getColCount() - 1, selection.toRow];
        }
        if (index === 0) {
            position = 'before';
        } else {
            index--;
            position = 'after';
        }
        for (i = removedMatrix.length - 1; i >= 0; i--) {
            this.insertRowOrCol(tableNode, mode, index, position, null, removedMatrix[i]);
        }
        surfaceModel.setSelection(new ve.dm.TableSelection(tableNode.getOuterRange(),newOffsets[0],newOffsets[1],newOffsets[2],newOffsets[3]));
        ve.track('activity.table', {
            action: 'move-' + mode
        });
        return true;
    }
    ;
    ve.ui.TableAction.prototype.delete = function(mode) {
        var tableNode, minIndex, maxIndex, isFull, documentModel = this.surface.getModel().getDocument(), selection = this.getTableSelectionFromSelection();
        if (!(selection instanceof ve.dm.TableSelection)) {
            return false;
        }
        tableNode = selection.getTableNode(documentModel);
        if (mode === 'table') {
            this.deleteTable(tableNode);
        } else {
            if (mode === 'col') {
                minIndex = selection.startCol;
                maxIndex = selection.endCol;
                isFull = selection.isFullRow(documentModel);
            } else {
                minIndex = selection.startRow;
                maxIndex = selection.endRow;
                isFull = selection.isFullCol(documentModel);
            }
            if (isFull) {
                this.deleteTable(tableNode);
            } else {
                this.deleteRowsOrColumns(tableNode.matrix, mode, minIndex, maxIndex);
            }
        }
        ve.track('activity.table', {
            action: 'delete' + (mode !== 'table' ? ('-' + mode) : '')
        });
        return true;
    }
    ;
    ve.ui.TableAction.prototype.importTable = function(importedTableNode, importInternalList) {
        var i, l, row, col, cell, importedCell, cellRange, txBuilders, importedMatrix = importedTableNode.getMatrix(), surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument(), selection = surfaceModel.getSelection(), tableNode = selection.getTableNode(documentModel), matrix = tableNode.getMatrix();
        for (i = 0,
        l = selection.startRow + importedMatrix.getRowCount() - matrix.getRowCount(); i < l; i++) {
            this.insertRowOrCol(tableNode, 'row', matrix.getRowCount() - 1, 'after');
        }
        for (i = 0,
        l = selection.startCol + importedMatrix.getMaxColCount() - matrix.getMaxColCount(); i < l; i++) {
            this.insertRowOrCol(tableNode, 'col', matrix.getMaxColCount() - 1, 'after');
        }
        for (row = importedMatrix.getRowCount() - 1; row >= 0; row--) {
            for (col = importedMatrix.getColCount(row) - 1; col >= 0; col--) {
                cell = matrix.getCell(selection.fromRow + row, selection.fromCol + col);
                if (cell.isPlaceholder() || cell.node.getColspan() > 1 || cell.node.getRowspan() > 1) {
                    this.unmergeCell(matrix, cell.owner);
                }
            }
        }
        for (row = importedMatrix.getRowCount() - 1; row >= 0; row--) {
            for (col = importedMatrix.getColCount(row) - 1; col >= 0; col--) {
                cell = matrix.getCell(selection.fromRow + row, selection.fromCol + col);
                cellRange = cell.node.getRange();
                importedCell = importedMatrix.getCell(row, col);
                if (importedCell.node.type !== cell.node.type) {
                    surfaceModel.change(ve.dm.TransactionBuilder.static.newFromReplacement(documentModel, cell.node.getOuterRange(), importedTableNode.getDocument().getData(importedCell.node.getOuterRange())));
                } else if (!importedCell.isPlaceholder()) {
                    surfaceModel.change(ve.dm.TransactionBuilder.static.newFromRemoval(documentModel, cellRange));
                    txBuilders = [ve.dm.TransactionBuilder.static.newFromAttributeChanges.bind(null, documentModel, cellRange.start - 1, ve.copy(importedCell.node.element.attributes))];
                    if (importInternalList) {
                        txBuilders.push(ve.dm.TransactionBuilder.static.newFromDocumentInsertion.bind(null, documentModel, cellRange.start, importedTableNode.getDocument(), importedCell.node.getRange()));
                    } else {
                        txBuilders.push(ve.dm.TransactionBuilder.static.newFromInsertion.bind(null, documentModel, cellRange.start, importedTableNode.getDocument().getData(importedCell.node.getRange())));
                    }
                    txBuilders.forEach(function(txBuilder) {
                        surfaceModel.change(txBuilder());
                    });
                } else {
                    surfaceModel.change(ve.dm.TransactionBuilder.static.newFromRemoval(documentModel, cell.node.getOuterRange()));
                }
            }
        }
        surfaceModel.setSelection(new ve.dm.TableSelection(tableNode.getOuterRange(),selection.startCol,selection.startRow,selection.startCol + importedMatrix.getMaxColCount() - 1,selection.startRow + importedMatrix.getRowCount() - 1));
        return true;
    }
    ;
    ve.ui.TableAction.prototype.changeCellStyle = function(style) {
        var i, ranges, txBuilders = [], surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument(), selection = surfaceModel.getSelection();
        if (!(selection instanceof ve.dm.TableSelection)) {
            return false;
        }
        ranges = selection.getOuterRanges(documentModel);
        for (i = ranges.length - 1; i >= 0; i--) {
            txBuilders.push(ve.dm.TransactionBuilder.static.newFromAttributeChanges.bind(null, documentModel, ranges[i].start, {
                style: style
            }));
        }
        txBuilders.forEach(function(txBuilder) {
            surfaceModel.change(txBuilder());
        });
        ve.track('activity.table', {
            action: 'style-' + style
        });
        return true;
    }
    ;
    ve.ui.TableAction.prototype.mergeCells = function() {
        var i, l, r, c, cell, cells, hasNonPlaceholders, contentData, txBuilders = [], surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument(), selection = surfaceModel.getSelection(), matrix = selection.getTableNode(documentModel).getMatrix();
        if (!(selection instanceof ve.dm.TableSelection)) {
            return false;
        }
        if (selection.isSingleCell(documentModel)) {
            cells = selection.getMatrixCells(documentModel);
            this.unmergeCell(matrix, cells[0]);
            ve.track('activity.table', {
                action: 'cell-split'
            });
        } else {
            if (!selection.isMergeable(documentModel)) {
                return false;
            }
            cells = selection.getMatrixCells(documentModel);
            txBuilders.push(ve.dm.TransactionBuilder.static.newFromAttributeChanges.bind(null, documentModel, cells[0].node.getOuterRange().start, {
                colspan: 1 + selection.endCol - selection.startCol,
                rowspan: 1 + selection.endRow - selection.startRow
            }));
            for (i = 0,
            l = cells.length; i < l; i++) {
                contentData = new ve.dm.ElementLinearData(documentModel.getStore(),documentModel.getData(cells[i].node.getRange()));
                if (contentData.hasContent()) {
                    if (!i) {
                        contentData = null;
                    }
                    break;
                }
            }
            for (i = cells.length - 1; i >= 1; i--) {
                txBuilders.push(ve.dm.TransactionBuilder.static.newFromRemoval.bind(null, documentModel, cells[i].node.getOuterRange()));
            }
            if (contentData) {
                txBuilders.push(ve.dm.TransactionBuilder.static.newFromReplacement.bind(null, documentModel, cells[0].node.getRange(), contentData.data));
            }
            txBuilders.forEach(function(txBuilder) {
                surfaceModel.change(txBuilder());
            });
            for (r = selection.endRow; r >= selection.startRow; r--) {
                hasNonPlaceholders = !1;
                for (c = 0; (cell = matrix.getCell(r, c)) !== undefined; c++) {
                    if (cell && !cell.isPlaceholder()) {
                        hasNonPlaceholders = !0;
                        break;
                    }
                }
                if (!hasNonPlaceholders) {
                    this.deleteRowsOrColumns(matrix, 'row', r, r);
                }
            }
            for (c = selection.endCol; c >= selection.startCol; c--) {
                hasNonPlaceholders = !1;
                for (r = 0; (cell = matrix.getCell(r, c)) !== undefined; r++) {
                    if (cell && !cell.isPlaceholder()) {
                        hasNonPlaceholders = !0;
                        break;
                    }
                }
                if (!hasNonPlaceholders) {
                    this.deleteRowsOrColumns(matrix, 'col', c, c);
                }
            }
            ve.track('activity.table', {
                action: 'cell-merge'
            });
        }
        return true;
    }
    ;
    ve.ui.TableAction.prototype.enterTableCell = function() {
        var tableNode = this.findClosestTable();
        if (!tableNode) {
            return false;
        }
        tableNode.setEditing(true);
        this.surface.getView().focus();
        return true;
    }
    ;
    ve.ui.TableAction.prototype.exitTableCell = function() {
        var tableNode = this.findClosestTable();
        if (!tableNode) {
            return false;
        }
        tableNode.setEditing(false);
        this.surface.getView().focus();
        return true;
    }
    ;
    ve.ui.TableAction.prototype.deleteTable = function(tableNode) {
        this.surface.getModel().getLinearFragment(tableNode.getOuterRange()).delete();
    }
    ;
    ve.ui.TableAction.prototype.unmergeCell = function(matrix, ownerCell) {
        var col, row, cell, txBuilders = [], colspan = ownerCell.node.getColspan(), rowspan = ownerCell.node.getRowspan(), surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument();
        txBuilders.push(ve.dm.TransactionBuilder.static.newFromAttributeChanges.bind(null, documentModel, ownerCell.node.getOuterRange().start, {
            colspan: 1,
            rowspan: 1
        }));
        for (row = ownerCell.row + rowspan - 1; row >= ownerCell.row; row--) {
            for (col = ownerCell.col + colspan - 1; col >= ownerCell.col; col--) {
                cell = matrix.getCell(row, col);
                if (cell.isPlaceholder()) {
                    txBuilders.push(this.replacePlaceholder(matrix, cell, {
                        style: ownerCell.node.getStyle()
                    }));
                }
            }
        }
        txBuilders.forEach(function(txBuilder) {
            surfaceModel.change(txBuilder());
        });
    }
    ;
    ve.ui.TableAction.prototype.insertRowOrCol = function(tableNode, mode, index, position, selection, dataMatrixLine) {
        var refIndex, cells, refCells, before, cellData, offset, range, i, l, cell, refCell, style, matrix = tableNode.matrix, insertCells = [], insertData = [], txBuilders = [], updated = {}, inserts = [], surfaceModel = this.surface.getModel();
        before = position === 'before';
        refIndex = index + (before ? -1 : 1);
        if (mode === 'row') {
            cells = matrix.getRow(index) || [];
            refCells = matrix.getRow(refIndex) || [];
        } else {
            cells = matrix.getColumn(index) || [];
            refCells = matrix.getColumn(refIndex) || [];
        }
        for (i = 0,
        l = Math.max(cells.length, dataMatrixLine ? dataMatrixLine.cells.length : 0); i < l; i++) {
            cell = cells[i];
            if (!cell) {
                if (dataMatrixLine && dataMatrixLine.cells[i]) {
                    insertCells.push(dataMatrixLine.cells[i]);
                }
                continue;
            }
            refCell = refCells[i];
            if (refCell && (cell.isPlaceholder() || refCell.isPlaceholder())) {
                if (cell.node === refCell.node) {
                    cell = cell.owner || cell;
                    if (!updated[cell.key]) {
                        txBuilders.push(this.incrementSpan(cell, mode));
                        updated[cell.key] = !0;
                    }
                    if (dataMatrixLine && dataMatrixLine.cells[i].owner.data && !dataMatrixLine.cells[i].owner.conflicted) {
                        if (dataMatrixLine.cells[i].isPlaceholder()) {
                            dataMatrixLine.cells[i].owner.data[0].attributes.colspan = 1;
                            dataMatrixLine.cells[i].owner.data[0].attributes.rowspan = 1;
                        }
                        dataMatrixLine.cells[i].owner.conflicted = !0;
                    }
                    continue;
                }
            }
            inserts.push(cell);
            if (dataMatrixLine) {
                insertCells.push(dataMatrixLine.cells[i]);
            }
        }
        if (mode === 'row') {
            if (!dataMatrixLine) {
                insertData = ve.dm.TableRowNode.static.createData({
                    cellCount: inserts.length,
                    style: cells.map(function(cell) {
                        return cell.node.getStyle();
                    })
                });
            } else {
                insertData.push(dataMatrixLine.row[0]);
                insertCells.forEach(function(cell) {
                    if (cell && cell.data) {
                        insertData = insertData.concat(cell.data);
                    } else if (!(cell && cell.isPlaceholder() && cell.owner.data && !cell.owner.conflicted)) {
                        insertData = insertData.concat(ve.dm.TableCellNode.static.createData());
                    }
                });
                insertData.push(dataMatrixLine.row[1]);
            }
            range = matrix.getRowNode(index).getOuterRange();
            offset = before ? range.start : range.end;
            txBuilders.push(ve.dm.TransactionBuilder.static.newFromInsertion.bind(null, surfaceModel.getDocument(), offset, insertData));
        } else {
            inserts.sort(ve.dm.TableMatrixCell.static.sortDescending);
            for (i = 0; i < inserts.length; i++) {
                cell = inserts[i];
                if (!cell) {
                    continue;
                }
                refCell = matrix.findClosestCell(cell);
                if (refCell) {
                    range = refCell.node.getOuterRange();
                    if (refCell.col < cell.col || (refCell.col === cell.col && !before)) {
                        offset = range.end;
                    } else {
                        offset = range.start;
                    }
                    style = refCell.node.getStyle();
                } else {
                    range = matrix.getRowNode(cell.row).getRange();
                    offset = before ? range.start : range.end;
                    style = cells[0].node.getStyle();
                }
                if (!dataMatrixLine) {
                    cellData = ve.dm.TableCellNode.static.createData({
                        style: style
                    });
                } else {
                    cell = dataMatrixLine.cells[cell.row];
                    cellData = [];
                    if (cell && cell.data) {
                        cellData = cell.data;
                    } else if (!(cell && cell.isPlaceholder() && cell.owner.data && !cell.owner.conflicted)) {
                        cellData = ve.dm.TableCellNode.static.createData();
                    }
                }
                txBuilders.push(ve.dm.TransactionBuilder.static.newFromInsertion.bind(null, surfaceModel.getDocument(), offset, cellData));
            }
        }
        txBuilders.forEach(function(txBuilder) {
            var tx = txBuilder();
            selection = selection && selection.translateByTransaction(tx);
            surfaceModel.change(tx);
        });
        if (selection) {
            surfaceModel.change(null, selection);
        }
    }
    ;
    ve.ui.TableAction.prototype.incrementSpan = function(cell, mode) {
        var data, surfaceModel = this.surface.getModel();
        if (mode === 'row') {
            data = {
                rowspan: cell.node.getRowspan() + 1
            };
        } else {
            data = {
                colspan: cell.node.getColspan() + 1
            };
        }
        return ve.dm.TransactionBuilder.static.newFromAttributeChanges.bind(null, surfaceModel.getDocument(), cell.node.getOuterRange().start, data);
    }
    ;
    ve.ui.TableAction.prototype.decrementSpan = function(cell, mode, minIndex, maxIndex) {
        var span, data, surfaceModel = this.surface.getModel();
        span = (minIndex - cell[mode]) + Math.max(0, cell[mode] + cell.node.getSpans()[mode] - 1 - maxIndex);
        if (mode === 'row') {
            data = {
                rowspan: span
            };
        } else {
            data = {
                colspan: span
            };
        }
        return ve.dm.TransactionBuilder.static.newFromAttributeChanges.bind(null, surfaceModel.getDocument(), cell.node.getOuterRange().start, data);
    }
    ;
    ve.ui.TableAction.prototype.deleteRowsOrColumns = function(matrix, mode, minIndex, maxIndex) {
        var row, col, i, l, cell, key, span, startRow, startCol, endRow, endCol, rowNode, rowRange, rowData, removedMatrix = [], cells = [], txBuilders = [], adapted = {}, actions = [], surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument();
        if (mode === 'row') {
            for (row = minIndex; row <= maxIndex; row++) {
                cells = cells.concat(matrix.getRow(row));
            }
        } else {
            for (col = minIndex; col <= maxIndex; col++) {
                cells = cells.concat(matrix.getColumn(col));
            }
        }
        for (i = 0,
        l = cells.length; i < l; i++) {
            cell = cells[i];
            if (!cell) {
                continue;
            }
            if (cell.isPlaceholder()) {
                key = cell.owner.key;
                if (!adapted[key]) {
                    txBuilders.push(this.decrementSpan(cell.owner, mode, minIndex, maxIndex));
                    adapted[key] = !0;
                }
                continue;
            }
            span = cell.node.getSpans()[mode];
            if (cell[mode] + span - 1 > maxIndex) {
                if (mode === 'col') {
                    startRow = cell.row;
                    startCol = maxIndex + 1;
                } else {
                    startRow = maxIndex + 1;
                    startCol = cell.col;
                }
                endRow = cell.row + cell.node.getRowspan() - 1;
                endCol = cell.col + cell.node.getColspan() - 1;
                actions.push({
                    action: 'insert',
                    cell: matrix.getCell(startRow, startCol),
                    colspan: 1 + endCol - startCol,
                    rowspan: 1 + endRow - startRow,
                    style: cell.node.getStyle(),
                    content: documentModel.getData(cell.node.getRange())
                });
            }
            if (mode === 'col') {
                actions.push({
                    action: 'delete',
                    cell: cell
                });
            }
        }
        actions.sort(function(a, b) {
            return ve.dm.TableMatrixCell.static.sortDescending(a.cell, b.cell);
        });
        if (mode === 'row') {
            for (i = 0; i < actions.length; i++) {
                txBuilders.push(this.replacePlaceholder(matrix, actions[i].cell, actions[i]));
            }
            for (row = maxIndex; row >= minIndex; row--) {
                rowNode = matrix.getRowNode(row);
                txBuilders.push(ve.dm.TransactionBuilder.static.newFromRemoval.bind(null, documentModel, rowNode.getOuterRange()));
                cells = matrix.getRow(row);
                rowRange = rowNode.getOuterRange();
                rowData = documentModel.getData(new ve.Range(rowRange.start,rowRange.start + 1), true).concat(documentModel.getData(new ve.Range(rowRange.end - 1,rowRange.end), true));
                rowData.splice(1, rowData.length - 2);
                removedMatrix[row - minIndex] = {
                    row: rowData,
                    cells: cells.map(function(cell) {
                        if (cell && !cell.isPlaceholder()) {
                            cell.data = documentModel.getData(cell.node.getOuterRange(), true);
                            if (cell.data[0].attributes.rowspan > 1 + maxIndex - minIndex) {
                                cell.data = null;
                            }
                        }
                        return cell;
                    })
                };
            }
        } else {
            for (i = 0; i < actions.length; i++) {
                if (actions[i].action === 'insert') {
                    txBuilders.push(this.replacePlaceholder(matrix, actions[i].cell, actions[i]));
                } else {
                    txBuilders.push(ve.dm.TransactionBuilder.static.newFromRemoval.bind(null, documentModel, actions[i].cell.node.getOuterRange()));
                    col = actions[i].cell.col - minIndex;
                    actions[i].cell.data = documentModel.getData(actions[i].cell.node.getOuterRange(), true);
                }
            }
            for (col = maxIndex; col >= minIndex; col--) {
                removedMatrix[col - minIndex] = {
                    cells: matrix.getColumn(col).map(function(cell) {
                        if (cell && !cell.isPlaceholder()) {
                            cell.data = documentModel.getData(cell.node.getOuterRange(), true);
                            if (cell.data[0].attributes.colspan > 1 + maxIndex - minIndex) {
                                cell.data = null;
                            }
                        }
                        return cell;
                    })
                };
            }
        }
        surfaceModel.change(null, new ve.dm.NullSelection());
        txBuilders.forEach(function(txBuilder) {
            surfaceModel.change(txBuilder());
        });
        return removedMatrix;
    }
    ;
    ve.ui.TableAction.prototype.replacePlaceholder = function(matrix, placeholder, options) {
        var range, offset, data, refCell = matrix.findClosestCell(placeholder), surfaceModel = this.surface.getModel();
        if (refCell) {
            range = refCell.node.getOuterRange();
            offset = (placeholder.col < refCell.col) ? range.start : range.end;
        } else {
            range = matrix.getRowNode(placeholder.row).getRange();
            offset = range.start;
        }
        data = ve.dm.TableCellNode.static.createData(options);
        return ve.dm.TransactionBuilder.static.newFromInsertion.bind(null, surfaceModel.getDocument(), offset, data);
    }
    ;
    ve.ui.TableAction.prototype.findClosestTable = function() {
        var tableNode, node, selection = this.surface.getModel().getSelection();
        if (selection instanceof ve.dm.TableSelection) {
            tableNode = this.surface.getView().documentView.getBranchNodeFromOffset(selection.tableRange.start + 1);
        } else if (selection instanceof ve.dm.LinearSelection) {
            node = this.surface.getView().documentView.getBranchNodeFromOffset(selection.getRange().start);
            if (node) {
                tableNode = node.$element.closest('table').data('view');
            }
        }
        return tableNode;
    }
    ;
    ve.ui.TableAction.prototype.getTableSelectionFromSelection = function() {
        var tableNode, cellNode, cell, surfaceModel = this.surface.getModel(), selection = surfaceModel.getSelection();
        if (selection instanceof ve.dm.TableSelection) {
            return selection;
        }
        tableNode = this.findClosestTable();
        if (!tableNode) {
            return false;
        }
        cellNode = tableNode.getActiveCellNode();
        if (!cellNode) {
            return false;
        }
        cell = tableNode.getModel().matrix.lookupCell(cellNode.getModel());
        if (!cell) {
            return false;
        }
        selection = new ve.dm.TableSelection(tableNode.getModel().getOuterRange(),cell.col,cell.row);
        selection = selection.expand(surfaceModel.getDocument());
        return selection;
    }
    ;
    ve.ui.actionFactory.register(ve.ui.TableAction);
    ve.ui.WindowAction = function VeUiWindowAction() {
        ve.ui.WindowAction.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.WindowAction, ve.ui.Action);
    ve.ui.WindowAction.static.name = 'window';
    ve.ui.WindowAction.static.methods = ['open', 'close', 'toggle'];
    ve.ui.WindowAction.prototype.open = function(name, data, action) {
        var currentInspector, inspectorWindowManager, fragmentPromise, originalFragment, text, windowAction = this, windowType = this.getWindowType(name), windowManager = windowType && this.getWindowManager(windowType), currentWindow = windowManager.getCurrentWindow(), autoClosePromises = [], surface = this.surface, fragment = surface.getModel().getFragment(undefined, true), dir = surface.getView().getSelectionDirectionality(), windowClass = ve.ui.windowFactory.lookup(name), isFragmentWindow = !!windowClass.prototype.getFragment, mayRequireFragment = isFragmentWindow || windowType === 'toolbar', sourceMode = surface.getMode() === 'source' && !windowClass.static.handlesSource, openDeferred = ve.createDeferred(), openPromise = openDeferred.promise();
        if (!windowManager) {
            return false;
        }
        if (!mayRequireFragment) {
            fragmentPromise = ve.createDeferred().resolve().promise();
        } else if (sourceMode) {
            text = fragment.getText(true);
            originalFragment = fragment;
            fragmentPromise = fragment.convertFromSource(text).then(function(selectionDocument) {
                var tempSurfaceModel = new ve.dm.Surface(selectionDocument)
                  , tempFragment = tempSurfaceModel.getLinearFragment(new ve.Range(1,Math.max(1, selectionDocument.getDocumentRange().end - 1)));
                return tempFragment;
            });
        } else {
            fragmentPromise = ve.createDeferred().resolve(fragment).promise();
        }
        data = ve.extendObject({
            dir: dir
        }, data, {
            $returnFocusTo: null
        });
        if (windowType === 'toolbar' || windowType === 'inspector') {
            data = ve.extendObject(data, {
                surface: surface
            });
            if (currentWindow && currentWindow.constructor.static.name !== name) {
                autoClosePromises.push(windowManager.closeWindow(currentWindow).closed);
            }
        }
        if (windowType === 'dialog') {
            inspectorWindowManager = windowAction.getWindowManager('inspector');
            currentInspector = inspectorWindowManager.getCurrentWindow();
            if (currentInspector) {
                autoClosePromises.push(inspectorWindowManager.closeWindow(currentInspector).closed);
            }
        }
        fragmentPromise.then(function(fragment) {
            ve.extendObject(data, {
                fragment: fragment
            });
            ve.promiseAll(autoClosePromises).always(function() {
                windowManager.getWindow(name).then(function(win) {
                    var instance = windowManager.openWindow(win, data);
                    if (sourceMode) {
                        win.sourceMode = sourceMode;
                    }
                    if (!win.constructor.static.activeSurface) {
                        surface.getView().deactivate(false);
                    }
                    instance.opened.then(function() {
                        if (sourceMode) {
                            win.initialFragment = null;
                            win.previousSelection = null;
                        }
                    });
                    instance.opened.always(function() {
                        if (action) {
                            win.executeAction(action);
                        }
                        openDeferred.resolve(instance);
                    });
                    if (!win.constructor.static.activeSurface) {
                        windowManager.once('closing', function() {
                            if (OO.ui.isMobile() && surface.getModel().getSelection().isCollapsed()) {
                                surface.getView().activate();
                            } else {
                                instance.closing.then(function() {
                                    if (!(OO.ui.isMobile() && !surface.getModel().getSelection().isCollapsed())) {
                                        surface.getView().activate();
                                    }
                                });
                            }
                        });
                    }
                    instance.closed.then(function(closedData) {
                        if (data.strippedSequence && !(closedData && closedData.action)) {
                            surface.getModel().undo();
                            surface.getModel().truncateUndoStack();
                            surface.getModel().emit('history');
                        }
                        if (sourceMode && fragment && fragment.getSurface().hasBeenModified()) {
                            originalFragment.setAutoSelect(true);
                            originalFragment.insertDocument(fragment.getDocument());
                        }
                        surface.getView().emit('position');
                    });
                });
            });
        });
        return openPromise;
    }
    ;
    ve.ui.WindowAction.prototype.close = function(name, data) {
        var windowType = this.getWindowType(name)
          , windowManager = windowType && this.getWindowManager(windowType);
        if (!windowManager) {
            return false;
        }
        windowManager.closeWindow(name, data);
        return true;
    }
    ;
    ve.ui.WindowAction.prototype.toggle = function(name, data) {
        var win, windowType = this.getWindowType(name), windowManager = windowType && this.getWindowManager(windowType);
        if (!windowManager) {
            return false;
        }
        win = windowManager.getCurrentWindow();
        if (!win || win.constructor.static.name !== name) {
            this.open(name, data);
        } else {
            this.close(name, data);
        }
        return true;
    }
    ;
    ve.ui.WindowAction.prototype.getWindowType = function(name) {
        var windowClass = ve.ui.windowFactory.lookup(name);
        if (windowClass.prototype instanceof ve.ui.FragmentInspector) {
            return 'inspector';
        } else if (windowClass.prototype instanceof ve.ui.ToolbarDialog) {
            return 'toolbar';
        } else if (windowClass.prototype instanceof OO.ui.Dialog) {
            return 'dialog';
        }
        return null;
    }
    ;
    ve.ui.WindowAction.prototype.getWindowManager = function(windowType) {
        switch (windowType) {
        case 'inspector':
            return this.surface.getContext().getInspectors();
        case 'toolbar':
            return this.surface.getToolbarDialogs();
        case 'dialog':
            return this.surface.getDialogs();
        }
        return null;
    }
    ;
    ve.ui.actionFactory.register(ve.ui.WindowAction);
    ve.ui.LinearContextItem = function VeUiLinearContextItem(context, model, config) {
        var contextItem = this;
        config = config || {};
        ve.ui.LinearContextItem.super.apply(this, arguments);
        OO.ui.mixin.PendingElement.call(this, config);
        this.$head = $('<div>');
        this.$title = $('<div>');
        this.$actions = $('<div>');
        this.$body = $('<div>');
        this.icon = new OO.ui.IconWidget({
            icon: config.icon || this.constructor.static.icon
        });
        this.label = new OO.ui.LabelWidget({
            label: config.label || this.constructor.static.label
        });
        this.actionButtons = new OO.ui.ButtonGroupWidget();
        if (this.context.isMobile()) {
            this.closeButton = new OO.ui.ButtonWidget({
                classes: ['ve-ui-linearContextItem-close'],
                framed: !1,
                label: ve.msg('visualeditor-contextitemwidget-label-close'),
                invisibleLabel: !0,
                icon: 'close'
            });
            this.editButton = new OO.ui.ButtonWidget({
                framed: !1,
                label: ve.msg(this.isReadOnly() ? 'visualeditor-contextitemwidget-label-view' : 'visualeditor-contextitemwidget-label-secondary'),
                invisibleLabel: !0,
                icon: this.isReadOnly() ? 'eye' : 'edit',
                flags: ['progressive']
            });
            this.deleteButton = new OO.ui.ButtonWidget({
                framed: !1,
                label: ve.msg('visualeditor-contextitemwidget-label-remove'),
                icon: 'trash',
                flags: ['destructive']
            });
            this.$foot = $('<div>');
            this.$bodyAction = $('<div>');
            if (this.isDeletable()) {
                this.$foot.append(this.deleteButton.$element);
            }
            this.closeButton.on('click', function() {
                context.toggleMenu(false);
                context.toggle(false);
                context.getSurface().getView().contexedAnnotations = [];
                ve.track('activity.' + contextItem.constructor.static.name, {
                    action: 'context-close'
                });
            });
        } else {
            this.editButton = new OO.ui.ButtonWidget({
                label: ve.msg(this.isReadOnly() ? 'visualeditor-contextitemwidget-label-view' : 'visualeditor-contextitemwidget-label-secondary'),
                flags: ['progressive']
            });
            this.deleteButton = new OO.ui.ButtonWidget({
                label: ve.msg('visualeditor-contextitemwidget-label-remove'),
                flags: ['destructive']
            });
            if (this.isDeletable()) {
                this.actionButtons.addItems([this.deleteButton]);
            }
        }
        if (this.isEditable()) {
            this.actionButtons.addItems([this.editButton]);
        }
        this.editButton.connect(this, {
            click: 'onEditButtonClick'
        });
        this.deleteButton.connect(this, {
            click: 'onDeleteButtonClick'
        });
        this.$title.addClass('ve-ui-linearContextItem-title').append(this.icon.$element, this.label.$element);
        this.$actions.addClass('ve-ui-linearContextItem-actions').append(this.actionButtons.$element);
        this.$head.addClass('ve-ui-linearContextItem-head').append(this.$title, this.$actions);
        this.$body.addClass('ve-ui-linearContextItem-body');
        this.$element.addClass('ve-ui-linearContextItem').append(this.$head, this.$body);
        if (this.context.isMobile()) {
            this.$foot.addClass('ve-ui-linearContextItem-foot');
            this.$head.append(this.closeButton.$element);
            this.$bodyAction.addClass('ve-ui-linearContextItem-body-action').append(this.$body, this.$actions);
            this.$element.append(this.$head, $('<div>').addClass('ve-ui-linearContextItem-body-action-wrapper').append(this.$bodyAction), this.$foot);
        }
    }
    ;
    OO.inheritClass(ve.ui.LinearContextItem, ve.ui.ContextItem);
    OO.mixinClass(ve.ui.ContextItem, OO.ui.mixin.PendingElement);
    ve.ui.LinearContextItem.static.editable = !0;
    ve.ui.LinearContextItem.static.deletable = !0;
    ve.ui.LinearContextItem.static.embeddable = !0;
    ve.ui.LinearContextItem.prototype.onEditButtonClick = function() {
        var command = this.getCommand();
        if (command) {
            command.execute(this.context.getSurface(), undefined, 'context');
            this.emit('command');
        }
    }
    ;
    ve.ui.LinearContextItem.prototype.onDeleteButtonClick = function() {
        this.getFragment().removeContent();
        ve.track('activity.' + this.constructor.static.name, {
            action: 'context-delete'
        });
    }
    ;
    ve.ui.LinearContextItem.prototype.isEditable = function() {
        return this.constructor.static.editable && (!this.model || this.model.isEditable());
    }
    ;
    ve.ui.LinearContextItem.prototype.isDeletable = function() {
        return this.constructor.static.deletable && this.isNode() && this.context.showDeleteButton() && !this.isReadOnly();
    }
    ;
    ve.ui.LinearContextItem.prototype.getDescription = function() {
        return '';
    }
    ;
    ve.ui.LinearContextItem.prototype.setIcon = function(icon) {
        return this.icon.setIcon(icon);
    }
    ;
    ve.ui.LinearContextItem.prototype.setLabel = function(label) {
        return this.label.setLabel(label);
    }
    ;
    ve.ui.LinearContextItem.prototype.renderBody = function() {
        this.$body.text(this.getDescription());
    }
    ;
    ve.ui.LinearContextItem.prototype.setup = function() {
        var isEmpty;
        this.renderBody();
        isEmpty = this.$body.is(':empty');
        if (isEmpty && this.context.isMobile()) {
            this.deleteButton.setInvisibleLabel(true);
            if (this.isDeletable()) {
                this.$head.append(this.deleteButton.$element);
            }
            if (this.isEditable()) {
                this.$head.append(this.editButton.$element);
            }
            this.closeButton.$element.remove();
        }
        this.$element.toggleClass('ve-ui-linearContextItem-empty', isEmpty);
        ve.track('activity.' + this.constructor.static.name, {
            action: 'context-show'
        });
        return this;
    }
    ;
    ve.ui.LinearContextItem.prototype.teardown = function() {
        this.$body.empty();
        return this;
    }
    ;
    ve.ui.AnnotationContextItem = function VeUiAnnotationContextItem(context, model, config) {
        ve.ui.AnnotationContextItem.super.call(this, context, model, config);
        this.$element.addClass('ve-ui-annotationContextItem');
        if (this.context.isMobile()) {
            this.clearButton = new OO.ui.ButtonWidget({
                framed: !1,
                label: this.constructor.static.clearMsg,
                icon: this.constructor.static.clearIcon,
                flags: ['destructive']
            });
            if (this.isClearable() && !this.isReadOnly()) {
                this.$foot.append(this.clearButton.$element);
            }
        } else {
            this.clearButton = new OO.ui.ButtonWidget({
                title: this.constructor.static.clearMsg,
                icon: this.constructor.static.clearIcon,
                flags: ['destructive']
            });
            if (this.isClearable() && !this.isReadOnly()) {
                this.actionButtons.addItems([this.clearButton], 0);
            }
        }
        this.clearButton.connect(this, {
            click: 'onClearButtonClick'
        });
    }
    ;
    OO.inheritClass(ve.ui.AnnotationContextItem, ve.ui.LinearContextItem);
    ve.ui.AnnotationContextItem.static.clearable = !0;
    ve.ui.AnnotationContextItem.static.clearIcon = 'cancel';
    ve.ui.AnnotationContextItem.static.clearMsg = OO.ui.deferMsg('visualeditor-clearbutton-tooltip');
    ve.ui.AnnotationContextItem.prototype.isClearable = function() {
        return this.constructor.static.clearable;
    }
    ;
    ve.ui.AnnotationContextItem.prototype.onClearButtonClick = function() {
        ve.track('activity.' + this.constructor.static.name, {
            action: 'context-clear'
        });
        this.applyToAnnotations(function(fragment, annotation) {
            fragment.annotateContent('clear', annotation);
        });
    }
    ;
    ve.ui.AnnotationContextItem.prototype.applyToAnnotations = function(callback) {
        var i, len, modelClasses = this.constructor.static.modelClasses, fragment = this.getFragment(), annotations = fragment.getAnnotations(true).filter(function(annotation) {
            return ve.isInstanceOfAny(annotation, modelClasses);
        }).get();
        if (!annotations.length && fragment.getSelection().isCollapsed() && fragment.getDocument().data.isContentOffset(fragment.getSelection().getRange().start)) {
            fragment = fragment.expandLinearSelection('word');
            annotations = fragment.getAnnotations(true).filter(function(annotation) {
                return ve.isInstanceOfAny(annotation, modelClasses);
            }).get();
        }
        for (i = 0,
        len = annotations.length; i < len; i++) {
            callback(fragment.expandLinearSelection('annotation', annotations[i]), annotations[i]);
        }
    }
    ;
    ve.ui.AnnotationContextItem.prototype.getAnnotationView = function() {
        var annotations = []
          , model = this.model
          , surfaceView = this.context.getSurface().getView();
        function isThisModel(annotationView) {
            return model === annotationView.model;
        }
        if (surfaceView.contexedAnnotations) {
            annotations = surfaceView.contexedAnnotations.filter(isThisModel);
        }
        if (!annotations.length) {
            annotations = surfaceView.annotationsAtModelSelection(isThisModel);
        }
        return annotations.length ? annotations[0] : undefined;
    }
    ;
    ve.ui.TableLineContextItem = function VeUiTableLineContextItem() {
        ve.ui.TableLineContextItem.super.apply(this, arguments);
        this.actionButton = new OO.ui.ButtonWidget({
            framed: !1,
            classes: ['ve-ui-tableLineContextItem-actionButton']
        });
        this.actionButton.connect(this, {
            click: 'onActionButtonClick'
        });
        this.$element.addClass('ve-ui-tableLineContextItem').append(this.actionButton.$element);
    }
    ;
    OO.inheritClass(ve.ui.TableLineContextItem, ve.ui.ContextItem);
    ve.ui.TableLineContextItem.static.name = 'tableLine';
    ve.ui.TableLineContextItem.static.title = null;
    ve.ui.TableLineContextItem.prototype.onActionButtonClick = function() {
        var command = this.getCommand();
        if (command) {
            command.execute(this.context.getSurface());
            this.emit('command');
        }
    }
    ;
    ve.ui.TableLineContextItem.prototype.getTitle = function() {
        return this.constructor.static.title;
    }
    ;
    ve.ui.TableLineContextItem.prototype.setup = function() {
        ve.ui.TableLineContextItem.super.prototype.setup.call(this);
        this.actionButton.setIcon(this.constructor.static.icon).setLabel(this.getTitle());
    }
    ;
    (function() {
        var className, modes = ['row', 'col'], sides = ['before', 'after'], modeNames = {
            row: 'Row',
            col: 'Column'
        }, sideNames = {
            before: 'Before',
            after: 'After'
        };
        modes.forEach(function(mode) {
            var modeName = modeNames[mode];
            sides.forEach(function(side) {
                var sideName = sideNames[side];
                className = 'Insert' + modeName + sideName + 'ContextItem';
                ve.ui[className] = function VeUiInsertRowOrColumnContextItem() {
                    ve.ui.TableLineContextItem.apply(this, arguments);
                }
                ;
                OO.inheritClass(ve.ui[className], ve.ui.TableLineContextItem);
                ve.ui[className].static.name = 'insert' + modeName + sideName;
                ve.ui[className].static.group = 'table-' + mode;
                ve.ui[className].static.icon = 'tableAdd' + modeName + sideName;
                ve.ui[className].static.title = OO.ui.deferMsg('visualeditor-table-insert-' + mode + '-' + side);
                ve.ui[className].static.commandName = 'insert' + modeName + sideName;
                ve.ui.contextItemFactory.register(ve.ui[className]);
                className = 'Move' + modeName + sideName + 'ContextItem';
                ve.ui[className] = function VeUiMoveRowOrColumnContextItem() {
                    ve.ui.TableLineContextItem.apply(this, arguments);
                }
                ;
                OO.inheritClass(ve.ui[className], ve.ui.TableLineContextItem);
                ve.ui[className].static.name = 'move' + modeName + sideName;
                ve.ui[className].static.group = 'table-' + mode;
                ve.ui[className].static.icon = 'tableMove' + modeName + sideName;
                ve.ui[className].static.title = OO.ui.deferMsg('visualeditor-table-move-' + mode + '-' + side);
                ve.ui[className].static.commandName = 'move' + modeName + sideName;
                ve.ui[className].prototype.setup = function() {
                    var selection, documentModel, matrix;
                    ve.ui.TableLineContextItem.prototype.setup.call(this);
                    selection = this.context.getSurface().getModel().getSelection();
                    documentModel = this.context.getSurface().getModel().getDocument();
                    if (!(selection instanceof ve.dm.TableSelection)) {
                        this.actionButton.setDisabled(true);
                        return;
                    }
                    if (side === 'before') {
                        this.actionButton.setDisabled((mode === 'row' && selection.startRow === 0) || (mode === 'col' && selection.startCol === 0));
                    } else {
                        matrix = selection.getTableNode(documentModel).getMatrix();
                        this.actionButton.setDisabled((mode === 'row' && selection.endRow === matrix.getRowCount() - 1) || (mode === 'col' && selection.endCol === matrix.getMaxColCount() - 1));
                    }
                }
                ;
                ve.ui.contextItemFactory.register(ve.ui[className]);
            });
            className = 'Delete' + modeName + 'ContextItem';
            ve.ui[className] = function VeUiDeleteRowOrColumnContextItem() {
                ve.ui.TableLineContextItem.apply(this, arguments);
                this.actionButton.setFlags({
                    destructive: !0
                });
            }
            ;
            OO.inheritClass(ve.ui[className], ve.ui.TableLineContextItem);
            ve.ui[className].static.name = 'delete' + modeName;
            ve.ui[className].static.group = 'table-' + mode;
            ve.ui[className].static.icon = 'trash';
            ve.ui[className].static.commandName = 'delete' + modeName;
            ve.ui[className].prototype.getTitle = function() {
                var count, selection = this.context.getSurface().getModel().getSelection();
                if (!(selection instanceof ve.dm.TableSelection)) {
                    count = 0;
                } else if (mode === 'row') {
                    count = selection.getRowCount();
                } else {
                    count = selection.getColCount();
                }
                return ve.msg('visualeditor-table-delete-' + mode, count);
            }
            ;
            ve.ui.contextItemFactory.register(ve.ui[className]);
        });
        ve.ui.TablePropertiesContextItem = function VeUiTablePropertiesContextItem() {
            ve.ui.TableLineContextItem.apply(this, arguments);
            this.actionButton.setFlags({
                progressive: !0
            });
        }
        ;
        OO.inheritClass(ve.ui.TablePropertiesContextItem, ve.ui.TableLineContextItem);
        ve.ui.TablePropertiesContextItem.static.name = 'tableProperties';
        ve.ui.TablePropertiesContextItem.static.group = 'table';
        ve.ui.TablePropertiesContextItem.static.icon = 'edit';
        ve.ui.TablePropertiesContextItem.static.commandName = 'table';
        ve.ui.TablePropertiesContextItem.static.title = OO.ui.deferMsg('visualeditor-table-contextitem-properties');
        ve.ui.TablePropertiesContextItem.prototype.onActionButtonClick = function() {
            var command = this.context.getSurface().commandRegistry.lookup('exitTableCell');
            if (command) {
                command.execute(this.context.getSurface());
            }
            return ve.ui.TablePropertiesContextItem.super.prototype.onActionButtonClick.apply(this, arguments);
        }
        ;
        ve.ui.contextItemFactory.register(ve.ui.TablePropertiesContextItem);
        ve.ui.DeleteTableContextItem = function VeUiDeleteTableContextItem() {
            ve.ui.TableLineContextItem.apply(this, arguments);
            this.actionButton.setFlags({
                destructive: !0
            });
        }
        ;
        OO.inheritClass(ve.ui.DeleteTableContextItem, ve.ui.TableLineContextItem);
        ve.ui.DeleteTableContextItem.static.name = 'deleteTable';
        ve.ui.DeleteTableContextItem.static.group = 'table';
        ve.ui.DeleteTableContextItem.static.icon = 'trash';
        ve.ui.DeleteTableContextItem.static.commandName = 'deleteTable';
        ve.ui.DeleteTableContextItem.static.title = OO.ui.deferMsg('visualeditor-contextitemwidget-label-remove');
        ve.ui.contextItemFactory.register(ve.ui.DeleteTableContextItem);
        ve.ui.ToggleTableSelectionContextItem = function VeUiToggleTableSelectionContextItem() {
            ve.ui.TableLineContextItem.apply(this, arguments);
            this.actionButton.setFlags({
                progressive: !0
            });
        }
        ;
        OO.inheritClass(ve.ui.ToggleTableSelectionContextItem, ve.ui.TableLineContextItem);
        ve.ui.ToggleTableSelectionContextItem.static.name = 'toggleTableEditing';
        ve.ui.ToggleTableSelectionContextItem.static.group = 'table';
        ve.ui.ToggleTableSelectionContextItem.static.icon = 'table';
        ve.ui.ToggleTableSelectionContextItem.prototype.getCommand = function() {
            var commandName = this.context.wasEditing ? 'exitTableCell' : 'enterTableCell';
            return this.context.getSurface().commandRegistry.lookup(commandName);
        }
        ;
        ve.ui.ToggleTableSelectionContextItem.prototype.getTitle = function() {
            var mode = 'cells'
              , selection = this.context.getSurface().getModel().getSelection();
            if (selection instanceof ve.dm.TableSelection) {
                mode = 'contents';
            }
            return ve.msg('visualeditor-table-contextitem-selectionmode-' + mode);
        }
        ;
        ve.ui.contextItemFactory.register(ve.ui.ToggleTableSelectionContextItem);
    }());
    ve.ui.AlienContextItem = function VeUiAlienContextItem(context, model, config) {
        ve.ui.AlienContextItem.super.call(this, context, model, config);
        this.$element.addClass('ve-ui-alienContextItem');
    }
    ;
    OO.inheritClass(ve.ui.AlienContextItem, ve.ui.LinearContextItem);
    ve.ui.AlienContextItem.static.name = 'alien';
    ve.ui.AlienContextItem.static.icon = 'puzzle';
    ve.ui.AlienContextItem.static.label = OO.ui.deferMsg('visualeditor-aliencontextitem-title');
    ve.ui.AlienContextItem.static.editable = !1;
    ve.ui.contextItemFactory.register(ve.ui.AlienContextItem);
    ve.ui.AlignableContextItem = function VeUiAlignableContextItem(context, model, config) {
        var align;
        ve.ui.AlignableContextItem.super.call(this, context, model, config);
        align = model.getAttribute('align');
        this.align = new ve.ui.AlignWidget({
            dir: this.context.getSurface().getDir()
        });
        this.align.selectItemByData(align);
        this.align.connect(this, {
            choose: 'onAlignChoose'
        });
        if (OO.ui.isMobile()) {
            this.align.items.forEach(function(item) {
                item.setInvisibleLabel(true);
            });
        }
        this.$element.addClass('ve-ui-alignableContextItem');
    }
    ;
    OO.inheritClass(ve.ui.AlignableContextItem, ve.ui.LinearContextItem);
    ve.ui.AlignableContextItem.static.name = 'alignable';
    ve.ui.AlignableContextItem.static.icon = 'alignLeft';
    ve.ui.AlignableContextItem.static.label = OO.ui.deferMsg('visualeditor-alignablecontextitem-title');
    ve.ui.AlignableContextItem.static.editable = !1;
    ve.ui.AlignableContextItem.static.exclusive = !1;
    ve.ui.AlignableContextItem.static.isCompatibleWith = function(model) {
        return model instanceof ve.dm.Node && model.isAlignable();
    }
    ;
    ve.ui.AlignableContextItem.prototype.setup = function() {
        this.align.setDisabled(this.context.getSurface().isReadOnly());
        ve.ui.AlignableContextItem.super.prototype.setup.apply(this, arguments);
    }
    ;
    ve.ui.AlignableContextItem.prototype.renderBody = function() {
        this.$body.empty().append(this.align.$element);
    }
    ;
    ve.ui.AlignableContextItem.prototype.onAlignChoose = function(item) {
        this.getFragment().changeAttributes({
            align: item.getData()
        });
    }
    ;
    ve.ui.contextItemFactory.register(ve.ui.AlignableContextItem);
    ve.ui.CommentContextItem = function VeUiCommentContextItem(context, model, config) {
        ve.ui.CommentContextItem.super.call(this, context, model, config);
        this.$element.addClass('ve-ui-commentContextItem');
    }
    ;
    OO.inheritClass(ve.ui.CommentContextItem, ve.ui.LinearContextItem);
    ve.ui.CommentContextItem.static.name = 'comment';
    ve.ui.CommentContextItem.static.icon = 'notice';
    ve.ui.CommentContextItem.static.label = OO.ui.deferMsg('visualeditor-commentinspector-title');
    ve.ui.CommentContextItem.static.modelClasses = [ve.dm.CommentNode];
    ve.ui.CommentContextItem.static.embeddable = !1;
    ve.ui.CommentContextItem.static.commandName = 'comment';
    ve.ui.CommentContextItem.prototype.getDescription = function() {
        return this.model.getAttribute('text').trim();
    }
    ;
    ve.ui.contextItemFactory.register(ve.ui.CommentContextItem);
    ve.ui.LinkContextItem = function VeUiLinkContextItem(context, model, config) {
        ve.ui.LinkContextItem.super.call(this, context, model, config);
        this.$element.addClass('ve-ui-linkContextItem');
        this.labelPreview = new OO.ui.LabelWidget();
        if (this.context.isMobile()) {
            this.$labelLayout = $('<div>').addClass('ve-ui-linkContextItem-label').append($('<div>').addClass('ve-ui-linkContextItem-label-body').append(new OO.ui.LabelWidget({
                classes: ['ve-ui-linkContextItem-label-label'],
                label: OO.ui.deferMsg('visualeditor-linkcontext-label-label')
            }).$element, $('<div>').addClass('ve-ui-linkContextItem-label-preview').append(this.labelPreview.$element)));
            this.$innerBody = $('<div>').addClass('ve-ui-linkContextItem-inner-body');
            this.$body.append(this.$labelLayout, new OO.ui.LabelWidget({
                classes: ['ve-ui-linkContextItem-link-label'],
                label: OO.ui.deferMsg('visualeditor-linkinspector-title')
            }).$element, this.$innerBody);
            this.$body = this.$innerBody;
        } else {
            this.labelButton = new OO.ui.ButtonWidget({
                label: OO.ui.deferMsg('visualeditor-linkcontext-label-change'),
                framed: !1,
                flags: ['progressive']
            });
            this.$labelLayout = $('<div>').addClass('ve-ui-linkContextItem-label').append($('<div>').addClass('ve-ui-linkContextItem-label-label').append(new OO.ui.IconWidget({
                icon: 'quotes'
            }).$element, new OO.ui.LabelWidget({
                label: OO.ui.deferMsg('visualeditor-linkcontext-label-label')
            }).$element), $('<div>').addClass('ve-ui-linkContextItem-label-preview').append(this.labelPreview.$element));
            this.labelButton.connect(this, {
                click: 'onLabelButtonClick'
            });
            if (!this.isReadOnly()) {
                this.$labelLayout.append($('<div>').addClass('ve-ui-linkContextItem-label-action').append(this.labelButton.$element));
            }
        }
    }
    ;
    OO.inheritClass(ve.ui.LinkContextItem, ve.ui.AnnotationContextItem);
    ve.ui.LinkContextItem.static.name = 'link';
    ve.ui.LinkContextItem.static.icon = 'link';
    ve.ui.LinkContextItem.static.label = OO.ui.deferMsg('visualeditor-linkinspector-title');
    ve.ui.LinkContextItem.static.modelClasses = [ve.dm.LinkAnnotation];
    ve.ui.LinkContextItem.static.embeddable = !1;
    ve.ui.LinkContextItem.static.commandName = 'link';
    ve.ui.LinkContextItem.static.clearable = !0;
    ve.ui.LinkContextItem.static.clearMsg = OO.ui.deferMsg('visualeditor-linkcontext-remove');
    ve.ui.LinkContextItem.static.clearIcon = 'unLink';
    ve.ui.LinkContextItem.prototype.getDescription = function() {
        return this.model.getHref();
    }
    ;
    ve.ui.LinkContextItem.prototype.renderBody = function() {
        var htmlDoc = this.context.getSurface().getModel().getDocument().getHtmlDocument();
        this.$body.empty().append($('<a>').addClass('ve-ui-linkContextItem-link').text(this.getDescription()).attr({
            href: ve.resolveUrl(this.model.getHref(), htmlDoc),
            target: '_blank',
            rel: 'noopener'
        }));
        if (!this.context.isMobile()) {
            this.$body.append(this.$labelLayout);
        }
        this.updateLabelPreview();
    }
    ;
    ve.ui.LinkContextItem.prototype.updateLabelPreview = function() {
        var label, surfaceModel = this.context.getSurface().getModel(), annotationView = this.getAnnotationView();
        if (annotationView) {
            label = surfaceModel.getFragment().expandLinearSelection('annotation', annotationView.getModel()).getText();
        }
        this.labelPreview.setLabel(label || ve.msg('visualeditor-linkcontext-label-fallback'));
    }
    ;
    ve.ui.LinkContextItem.prototype.onLabelButtonClick = function() {
        var surface = this.context.getSurface().getView()
          , annotationView = this.getAnnotationView();
        surface.selectNodeContents(annotationView.$element[0], this.context.isMobile() ? 'end' : undefined);
        ve.track('activity.' + this.constructor.static.name, {
            action: 'context-label'
        });
    }
    ;
    ve.ui.contextItemFactory.register(ve.ui.LinkContextItem);
    ve.ui.ToolContextItem = function VeUiToolContextItem(context, model, tool, config) {
        ve.ui.ToolContextItem.super.call(this, context, model, config);
        this.tool = tool;
        this.setIcon(tool.static.icon);
        this.setLabel(tool.static.title);
        this.$element.addClass('ve-ui-toolContextItem');
    }
    ;
    OO.inheritClass(ve.ui.ToolContextItem, ve.ui.LinearContextItem);
    ve.ui.ToolContextItem.prototype.getCommand = function() {
        return this.tool.static.getCommand(this.context.getSurface());
    }
    ;
    ve.ui.ToolContextItem.prototype.getDescription = function() {
        var description = '';
        if (this.model instanceof ve.dm.Annotation) {
            description = ve.ce.annotationFactory.getDescription(this.model);
        } else if (this.model instanceof ve.dm.Node) {
            description = ve.ce.nodeFactory.getDescription(this.model);
        }
        return description;
    }
    ;
    ve.ui.TableContextItem = function VeUiTableContextItem(context, model, config) {
        ve.ui.TableContextItem.super.call(this, context, model, config);
        this.$element.addClass('ve-ui-tableContextItem');
        this.editButton.setLabel(ve.msg('visualeditor-table-contextitem-properties'));
    }
    ;
    OO.inheritClass(ve.ui.TableContextItem, ve.ui.LinearContextItem);
    ve.ui.TableContextItem.static.name = 'table';
    ve.ui.TableContextItem.static.icon = 'table';
    ve.ui.TableContextItem.static.label = OO.ui.deferMsg('visualeditor-toolbar-table');
    ve.ui.TableContextItem.static.commandName = 'table';
    ve.ui.TableContextItem.static.embeddable = !1;
    ve.ui.TableContextItem.static.isCompatibleWith = function(model) {
        return model instanceof ve.dm.Node && model.isCellable() && !OO.ui.isMobile();
    }
    ;
    ve.ui.TableContextItem.prototype.isDeletable = function() {
        return !this.isReadOnly();
    }
    ;
    ve.ui.TableContextItem.prototype.onDeleteButtonClick = function() {
        var surfaceModel = this.getFragment().getSurface();
        surfaceModel.getLinearFragment(surfaceModel.getSelectedNode().findParent(ve.dm.TableNode).getOuterRange()).delete();
        ve.track('activity.table', {
            action: 'context-delete'
        });
    }
    ;
    ve.ui.contextItemFactory.register(ve.ui.TableContextItem);
    ve.ui.MergeCellsContextItem = function VeUiMergeCellsContextItem(context, model, config) {
        ve.ui.MergeCellsContextItem.super.call(this, context, model, config);
        this.$element.addClass('ve-ui-mergeCellsContextItem');
    }
    ;
    OO.inheritClass(ve.ui.MergeCellsContextItem, ve.ui.LinearContextItem);
    ve.ui.MergeCellsContextItem.static.name = 'mergeCells';
    ve.ui.MergeCellsContextItem.static.icon = 'tableMergeCells';
    ve.ui.MergeCellsContextItem.static.label = OO.ui.deferMsg('visualeditor-table-merge-cells');
    ve.ui.MergeCellsContextItem.static.commandName = 'mergeCells';
    ve.ui.MergeCellsContextItem.static.deletable = !1;
    ve.ui.MergeCellsContextItem.static.embeddable = !1;
    ve.ui.MergeCellsContextItem.static.isCompatibleWith = function(model) {
        return model instanceof ve.dm.Node && model.isCellable();
    }
    ;
    ve.ui.MergeCellsContextItem.prototype.setup = function() {
        var selection = this.getFragment().getSurface().getSelection()
          , documentModel = this.getFragment().getDocument()
          , isMergeable = (selection instanceof ve.dm.TableSelection) && selection.isMergeable(documentModel) && !this.isReadOnly();
        if (!isMergeable) {
            this.$element.detach();
        } else {
            this.editButton.setLabel(isMergeable && selection.isSingleCell(documentModel) ? ve.msg('visualeditor-table-merge-cells-unmerge') : ve.msg('visualeditor-table-merge-cells-merge'));
        }
    }
    ;
    ve.ui.contextItemFactory.register(ve.ui.MergeCellsContextItem);
    ve.ui.SumCellsContextItem = function VeUiSumCellsContextItem(context, model, config) {
        ve.ui.SumCellsContextItem.super.call(this, context, model, config);
        this.$element.addClass('ve-ui-sumCellsContextItem');
    }
    ;
    OO.inheritClass(ve.ui.SumCellsContextItem, ve.ui.LinearContextItem);
    ve.ui.SumCellsContextItem.static.name = 'sumCells';
    ve.ui.SumCellsContextItem.static.icon = 'mathematics';
    ve.ui.SumCellsContextItem.static.editable = !1;
    ve.ui.SumCellsContextItem.static.deletable = !1;
    ve.ui.SumCellsContextItem.static.embeddable = !1;
    ve.ui.SumCellsContextItem.static.isCompatibleWith = function(model) {
        return model instanceof ve.dm.Node && model.isCellable();
    }
    ;
    ve.ui.SumCellsContextItem.prototype.setup = function() {
        var sum, cells, viewCell, count = 0, selection = this.getFragment().getSurface().getSelection(), documentModel = this.getFragment().getDocument(), documentView = this.context.getSurface().getView().getDocument();
        if (selection instanceof ve.dm.TableSelection) {
            cells = selection.getMatrixCells(documentModel, true);
            if (cells.length > 1) {
                sum = cells.reduce(function(sum, cell) {
                    var number;
                    if (!cell.isPlaceholder()) {
                        viewCell = documentView.getBranchNodeFromOffset(cell.node.getRange().start);
                        number = ve.init.platform.parseNumber(viewCell.$element.text());
                        if (!isNaN(number)) {
                            count++;
                            return sum + number;
                        }
                    }
                    return sum;
                }, 0);
            }
        }
        if (count > 1) {
            this.setLabel(ve.msg('visualeditor-table-sum', ve.init.platform.formatNumber(sum), ve.init.platform.formatNumber(sum / count)));
        } else {
            this.$element.detach();
        }
    }
    ;
    ve.ui.contextItemFactory.register(ve.ui.SumCellsContextItem);
    ve.ui.ClearAnnotationCommand = function VeUiClearAnnotationCommand() {
        ve.ui.ClearAnnotationCommand.super.call(this, 'clear', 'annotation', 'clearAll', {
            supportedSelections: ['linear', 'table']
        });
    }
    ;
    OO.inheritClass(ve.ui.ClearAnnotationCommand, ve.ui.Command);
    ve.ui.ClearAnnotationCommand.prototype.isExecutable = function(fragment) {
        return ve.ui.ClearAnnotationCommand.super.prototype.isExecutable.apply(this, arguments) && fragment.hasAnnotations();
    }
    ;
    ve.ui.commandRegistry.register(new ve.ui.ClearAnnotationCommand());
    ve.ui.HistoryCommand = function VeUiHistoryCommand(name, method) {
        method = method || name;
        ve.ui.HistoryCommand.super.call(this, name, 'history', method);
        this.checkMethod = {
            undo: 'canUndo',
            redo: 'canRedo'
        }[method];
    }
    ;
    OO.inheritClass(ve.ui.HistoryCommand, ve.ui.Command);
    ve.ui.HistoryCommand.prototype.isExecutable = function(fragment) {
        var surface = fragment.getSurface();
        return ve.ui.HistoryCommand.super.prototype.isExecutable.apply(this, arguments) && surface[this.checkMethod]();
    }
    ;
    ve.ui.commandRegistry.register(new ve.ui.HistoryCommand('undo'));
    ve.ui.commandRegistry.register(new ve.ui.HistoryCommand('redo'));
    ve.ui.IndentationCommand = function VeUiIndentationCommand(name, method) {
        ve.ui.IndentationCommand.super.call(this, name, 'indentation', method, {
            supportedSelections: ['linear']
        });
    }
    ;
    OO.inheritClass(ve.ui.IndentationCommand, ve.ui.Command);
    ve.ui.IndentationCommand.prototype.isExecutable = function(fragment) {
        if (!ve.ui.IndentationCommand.super.prototype.isExecutable.apply(this, arguments)) {
            return false;
        }
        return fragment.hasMatchingAncestor('listItem');
    }
    ;
    ve.ui.commandRegistry.register(new ve.ui.IndentationCommand('indent','increase'));
    ve.ui.commandRegistry.register(new ve.ui.IndentationCommand('outdent','decrease'));
    ve.ui.MergeCellsCommand = function VeUiMergeCellsCommand() {
        ve.ui.MergeCellsCommand.super.call(this, 'mergeCells', 'table', 'mergeCells', {
            supportedSelections: ['table']
        });
    }
    ;
    OO.inheritClass(ve.ui.MergeCellsCommand, ve.ui.Command);
    ve.ui.MergeCellsCommand.prototype.isExecutable = function(fragment) {
        return ve.ui.MergeCellsCommand.super.prototype.isExecutable.apply(this, arguments) && fragment.getSelection().isMergeable(fragment.getDocument());
    }
    ;
    ve.ui.commandRegistry.register(new ve.ui.MergeCellsCommand());
    ve.ui.FragmentDialog = function VeUiFragmentDialog(config) {
        ve.ui.FragmentDialog.super.call(this, config);
        ve.ui.FragmentWindow.call(this, config);
    }
    ;
    OO.inheritClass(ve.ui.FragmentDialog, OO.ui.ProcessDialog);
    OO.mixinClass(ve.ui.FragmentDialog, ve.ui.FragmentWindow);
    ve.ui.FragmentDialog.static.actions = [{
        label: OO.ui.deferMsg('visualeditor-dialog-action-cancel'),
        flags: ['safe', 'close'],
        modes: ['readonly', 'edit', 'insert']
    }, {
        action: 'done',
        label: OO.ui.deferMsg('visualeditor-dialog-action-apply'),
        flags: ['progressive', 'primary'],
        modes: 'edit'
    }, {
        action: 'done',
        label: OO.ui.deferMsg('visualeditor-dialog-action-insert'),
        flags: ['progressive', 'primary'],
        modes: 'insert'
    }];
    ve.ui.FragmentDialog.prototype.initialize = function(data) {
        ve.ui.FragmentDialog.super.prototype.initialize.call(this, data);
        this.tabIndexScope = new ve.ui.TabIndexScope({
            root: this.$content
        });
    }
    ;
    ve.ui.FragmentDialog.prototype.getActionWidgetConfig = function(config) {
        config = ve.ui.FragmentWindow.prototype.getActionWidgetConfig.call(this, config);
        return ve.ui.FragmentDialog.super.prototype.getActionWidgetConfig.call(this, config);
    }
    ;
    ve.ui.FragmentDialog.prototype.getSetupProcess = function(data) {
        var process = ve.ui.FragmentDialog.super.prototype.getSetupProcess.call(this, data);
        return ve.ui.FragmentWindow.prototype.getSetupProcess.call(this, data, process);
    }
    ;
    ve.ui.FragmentDialog.prototype.getTeardownProcess = function(data) {
        var process = ve.ui.FragmentDialog.super.prototype.getTeardownProcess.call(this, data).first(function() {
            this.fragment.select();
        }, this);
        return ve.ui.FragmentWindow.prototype.getTeardownProcess.call(this, data, process);
    }
    ;
    ve.ui.NodeDialog = function VeUiNodeDialog(config) {
        ve.ui.NodeDialog.super.call(this, config);
        ve.ui.NodeWindow.call(this);
    }
    ;
    OO.inheritClass(ve.ui.NodeDialog, ve.ui.FragmentDialog);
    OO.mixinClass(ve.ui.NodeDialog, ve.ui.NodeWindow);
    ve.ui.NodeDialog.prototype.initialize = function(data) {
        ve.ui.NodeDialog.super.prototype.initialize.call(this, data);
        this.$content.addClass('ve-ui-nodeDialog');
    }
    ;
    ve.ui.NodeDialog.prototype.getSetupProcess = function(data) {
        var process = ve.ui.NodeDialog.super.prototype.getSetupProcess.call(this, data);
        return ve.ui.NodeWindow.prototype.getSetupProcess.call(this, data, process);
    }
    ;
    ve.ui.NodeDialog.prototype.getTeardownProcess = function(data) {
        var process = ve.ui.NodeDialog.super.prototype.getTeardownProcess.call(this, data);
        return ve.ui.NodeWindow.prototype.getTeardownProcess.call(this, data, process);
    }
    ;
    ve.ui.ToolbarDialog = function VeUiToolbarDialog(config) {
        ve.ui.ToolbarDialog.super.call(this, config);
        this.disabled = !1;
        this.$shield = $('<div>').addClass('ve-ui-toolbarDialog-shield');
        this.$element.addClass('ve-ui-toolbarDialog');
    }
    ;
    OO.inheritClass(ve.ui.ToolbarDialog, OO.ui.Dialog);
    ve.ui.ToolbarDialog.static.size = 'full';
    ve.ui.ToolbarDialog.static.padded = !0;
    ve.ui.ToolbarDialog.static.position = 'above';
    ve.ui.ToolbarDialog.prototype.initialize = function() {
        ve.ui.ToolbarDialog.super.prototype.initialize.call(this);
        this.$body.append(this.$shield);
        this.$content.addClass('ve-ui-toolbarDialog-content');
        this.$element.addClass('ve-ui-toolbarDialog-position-' + this.constructor.static.position);
        if (this.constructor.static.padded) {
            this.$element.addClass('ve-ui-toolbarDialog-padded');
        }
        this.title.setInvisibleLabel(true);
        this.$element.prepend(this.title.$element);
    }
    ;
    ve.ui.ToolbarDialog.prototype.setDisabled = function(disabled) {
        this.$content.addClass('ve-ui-toolbarDialog-content');
        if (disabled !== this.disabled) {
            this.disabled = disabled;
            this.$body.append(this.$shield).toggleClass('ve-ui-toolbarDialog-disabled', this.disabled);
        }
    }
    ;
    ve.ui.CommandHelpDialog = function VeUiCommandHelpDialog(config) {
        ve.ui.CommandHelpDialog.super.call(this, config);
    }
    ;
    OO.inheritClass(ve.ui.CommandHelpDialog, OO.ui.ProcessDialog);
    ve.ui.CommandHelpDialog.static.name = 'commandHelp';
    ve.ui.CommandHelpDialog.static.size = 'larger';
    ve.ui.CommandHelpDialog.static.title = OO.ui.deferMsg('visualeditor-dialog-command-help-title');
    ve.ui.CommandHelpDialog.static.actions = [{
        label: OO.ui.deferMsg('visualeditor-dialog-action-done'),
        flags: 'safe'
    }];
    ve.ui.CommandHelpDialog.static.commandGroups = {
        textStyle: {
            title: OO.ui.deferMsg('visualeditor-shortcuts-text-style'),
            promote: ['bold', 'italic', 'link'],
            demote: ['clear']
        },
        clipboard: {
            title: OO.ui.deferMsg('visualeditor-shortcuts-clipboard')
        },
        formatting: {
            title: OO.ui.deferMsg('visualeditor-shortcuts-formatting'),
            promote: ['paragraph', 'pre', 'blockquote']
        },
        history: {
            title: OO.ui.deferMsg('visualeditor-shortcuts-history'),
            promote: ['undo', 'redo']
        },
        dialog: {
            title: OO.ui.deferMsg('visualeditor-shortcuts-dialog')
        },
        other: {
            title: OO.ui.deferMsg('visualeditor-shortcuts-other'),
            promote: ['findAndReplace', 'findNext', 'findPrevious'],
            demote: ['commandHelp']
        },
        insert: {
            title: OO.ui.deferMsg('visualeditor-shortcuts-insert')
        }
    };
    ve.ui.CommandHelpDialog.static.commandGroupsOrder = ['textStyle', 'clipboard', 'formatting', 'history', 'dialog', 'other', 'insert'];
    ve.ui.CommandHelpDialog.prototype.getBodyHeight = function() {
        return Math.round(this.contentLayout.$element[0].scrollHeight);
    }
    ;
    ve.ui.CommandHelpDialog.prototype.initialize = function() {
        var i, iLen, j, jLen, k, kLen, triggerList, commands, shortcut, $list, $shortcut, groupName, commandGroup, commandGroups, commandGroupsOrder, sequence, hasCommand, hasShortcut, surface = ve.init.target.getSurface(), sequenceRegistry = surface.sequenceRegistry, commandRegistry = surface.commandRegistry;
        ve.ui.CommandHelpDialog.super.prototype.initialize.call(this);
        commandGroups = this.constructor.static.commandGroups;
        commandGroupsOrder = this.constructor.static.commandGroupsOrder;
        this.contentLayout = new OO.ui.PanelLayout({
            scrollable: !0,
            padded: !0,
            expanded: !1
        });
        this.$container = $('<div>').addClass('ve-ui-commandHelpDialog-container');
        for (i = 0,
        iLen = commandGroupsOrder.length; i < iLen; i++) {
            hasCommand = !1;
            groupName = commandGroupsOrder[i];
            commandGroup = commandGroups[groupName];
            commands = this.constructor.static.sortedCommandsFromGroup(groupName, commandGroup.promote, commandGroup.demote);
            $list = $('<dl>').addClass('ve-ui-commandHelpDialog-list');
            for (j = 0,
            jLen = commands.length; j < jLen; j++) {
                if (commands[j].trigger) {
                    if (!commands[j].ignoreCommand && !commandRegistry.lookup(commands[j].trigger)) {
                        continue;
                    }
                    triggerList = ve.ui.triggerRegistry.lookup(commands[j].trigger);
                } else {
                    triggerList = [];
                    if (commands[j].shortcuts) {
                        for (k = 0,
                        kLen = commands[j].shortcuts.length; k < kLen; k++) {
                            shortcut = commands[j].shortcuts[k];
                            triggerList.push(new ve.ui.Trigger(shortcut,true));
                        }
                    }
                }
                hasShortcut = !1;
                $shortcut = $('<dt>');
                for (k = 0,
                kLen = triggerList.length; k < kLen; k++) {
                    $shortcut.append($('<kbd>').append(triggerList[k].getMessage(true).map(this.constructor.static.buildKeyNode)).find('kbd + kbd').before('+').end());
                    hasShortcut = !0;
                }
                if (commands[j].sequences) {
                    for (k = 0,
                    kLen = commands[j].sequences.length; k < kLen; k++) {
                        sequence = sequenceRegistry.lookup(commands[j].sequences[k]);
                        if (sequence) {
                            $shortcut.append($('<kbd>').addClass('ve-ui-commandHelpDialog-sequence').attr('data-label', ve.msg('visualeditor-shortcuts-sequence-notice')).append(sequence.getMessage(true).map(this.constructor.static.buildKeyNode)));
                            hasShortcut = !0;
                        }
                    }
                }
                if (hasShortcut) {
                    $list.append($shortcut, $('<dd>').text(OO.ui.resolveMsg(commands[j].label)));
                    hasCommand = !0;
                }
            }
            if (hasCommand) {
                this.$container.append($('<div>').addClass('ve-ui-commandHelpDialog-section').append($('<h3>').text(OO.ui.resolveMsg(commandGroup.title)), $list));
            }
        }
        this.contentLayout.$element.append(this.$container);
        this.$body.append(this.contentLayout.$element);
    }
    ;
    ve.ui.CommandHelpDialog.static.buildKeyNode = function(key) {
        var $key = $('<kbd>');
        if (key === ' ') {
            key = (new ve.ui.Trigger('space')).getMessage();
            $key.addClass('ve-ui-commandHelpDialog-specialKey');
        }
        return $key.text(key);
    }
    ;
    ve.ui.CommandHelpDialog.static.sortedCommandsFromGroup = function(groupName, promote, demote) {
        var i, commands = ve.ui.commandHelpRegistry.lookupByGroup(groupName), keys = Object.keys(commands), used = {}, auto = [], promoted = [], demoted = [];
        keys.sort();
        if (promote) {
            for (i = 0; i < promote.length; i++) {
                if (!commands[promote[i]]) {
                    continue;
                }
                promoted.push(commands[promote[i]]);
                used[promote[i]] = !0;
            }
        }
        if (demote) {
            for (i = 0; i < demote.length; i++) {
                if (used[demote[i]] || !commands[demote[i]]) {
                    continue;
                }
                demoted.push(commands[demote[i]]);
                used[demote[i]] = !0;
            }
        }
        for (i = 0; i < keys.length; i++) {
            if (used[keys[i]]) {
                continue;
            }
            auto.push(commands[keys[i]]);
        }
        return promoted.concat(auto, demoted);
    }
    ;
    ve.ui.windowFactory.register(ve.ui.CommandHelpDialog);
    ve.ui.FindAndReplaceDialog = function VeUiFindAndReplaceDialog(config) {
        ve.ui.FindAndReplaceDialog.super.call(this, config);
        this.$element.addClass('ve-ui-findAndReplaceDialog');
    }
    ;
    OO.inheritClass(ve.ui.FindAndReplaceDialog, ve.ui.ToolbarDialog);
    ve.ui.FindAndReplaceDialog.static.name = 'findAndReplace';
    ve.ui.FindAndReplaceDialog.static.title = OO.ui.deferMsg('visualeditor-find-and-replace-title');
    ve.ui.FindAndReplaceDialog.static.handlesSource = !0;
    ve.ui.FindAndReplaceDialog.static.maxRenderedResults = 100;
    ve.ui.FindAndReplaceDialog.prototype.initialize = function() {
        var optionsGroup, navigateGroup, replaceGroup, doneButton, $findRow, $replaceRow;
        ve.ui.FindAndReplaceDialog.super.prototype.initialize.call(this);
        this.surface = null;
        this.invalidRegex = !1;
        this.$findResults = $('<div>').addClass('ve-ui-findAndReplaceDialog-findResults');
        this.initialFragment = null;
        this.startOffset = 0;
        this.fragments = [];
        this.results = 0;
        this.renderedResultsCache = {};
        this.renderedFragments = new ve.Range();
        this.replacing = !1;
        this.focusedIndex = 0;
        this.query = null;
        this.findText = new OO.ui.TextInputWidget({
            placeholder: ve.msg('visualeditor-find-and-replace-find-text'),
            value: ve.userConfig('visualeditor-findAndReplace-findText'),
            validate: (function(dialog) {
                return function() {
                    return !dialog.invalidRegex;
                }
                ;
            }(this)),
            tabIndex: 1
        });
        this.findText.$input.attr('aria-label', ve.msg('visualeditor-find-and-replace-find-text'));
        this.updateUserConfigDebounced = ve.debounce(this.updateUserConfig.bind(this), 500);
        this.previousButton = new OO.ui.ButtonWidget({
            icon: 'previous',
            title: ve.msg('visualeditor-find-and-replace-previous-button') + ' ' + ve.ui.triggerRegistry.getMessages('findPrevious').join(', '),
            tabIndex: 2
        });
        this.nextButton = new OO.ui.ButtonWidget({
            icon: 'next',
            title: ve.msg('visualeditor-find-and-replace-next-button') + ' ' + ve.ui.triggerRegistry.getMessages('findNext').join(', '),
            tabIndex: 2
        });
        this.matchCaseToggle = new OO.ui.ToggleButtonWidget({
            icon: 'searchCaseSensitive',
            title: ve.msg('visualeditor-find-and-replace-match-case'),
            value: ve.userConfig('visualeditor-findAndReplace-matchCase'),
            tabIndex: 2
        });
        this.regexToggle = new OO.ui.ToggleButtonWidget({
            icon: 'searchRegularExpression',
            title: ve.msg('visualeditor-find-and-replace-regular-expression'),
            value: ve.userConfig('visualeditor-findAndReplace-regex'),
            tabIndex: 2
        });
        this.wordToggle = new OO.ui.ToggleButtonWidget({
            icon: 'quotes',
            title: ve.msg('visualeditor-find-and-replace-word'),
            value: ve.userConfig('visualeditor-findAndReplace-word'),
            tabIndex: 2
        });
        this.diacriticToggle = new OO.ui.ToggleButtonWidget({
            icon: 'searchDiacritics',
            title: ve.supportsIntl ? ve.msg('visualeditor-find-and-replace-diacritic') : ve.msg('visualeditor-find-and-replace-diacritic-unavailable'),
            value: ve.userConfig('visualeditor-findAndReplace-diacritic'),
            tabIndex: 2
        });
        this.replaceText = new OO.ui.TextInputWidget({
            placeholder: ve.msg('visualeditor-find-and-replace-replace-text'),
            value: ve.userConfig('visualeditor-findAndReplace-replaceText'),
            tabIndex: 1
        });
        this.replaceText.$input.attr('aria-label', ve.msg('visualeditor-find-and-replace-replace-text'));
        this.replaceButton = new OO.ui.ButtonWidget({
            label: ve.msg('visualeditor-find-and-replace-replace-button'),
            tabIndex: 1
        });
        this.replaceAllButton = new OO.ui.ButtonWidget({
            label: ve.msg('visualeditor-find-and-replace-replace-all-button'),
            tabIndex: 1
        });
        doneButton = new OO.ui.ButtonWidget({
            classes: ['ve-ui-findAndReplaceDialog-cell'],
            label: ve.msg('visualeditor-find-and-replace-done'),
            tabIndex: 1
        });
        optionsGroup = new OO.ui.ButtonGroupWidget({
            classes: ['ve-ui-findAndReplaceDialog-cell'],
            items: [this.matchCaseToggle, this.regexToggle, this.wordToggle, this.diacriticToggle]
        });
        navigateGroup = new OO.ui.ButtonGroupWidget({
            classes: ['ve-ui-findAndReplaceDialog-cell'],
            items: [this.previousButton, this.nextButton]
        });
        replaceGroup = new OO.ui.ButtonGroupWidget({
            classes: ['ve-ui-findAndReplaceDialog-cell'],
            items: [this.replaceButton, this.replaceAllButton]
        });
        $findRow = $('<div>').addClass('ve-ui-findAndReplaceDialog-row');
        $replaceRow = $('<div>').addClass('ve-ui-findAndReplaceDialog-row');
        this.onWindowScrollThrottled = ve.throttle(this.onWindowScroll.bind(this), 250);
        this.updateFragmentsThrottled = ve.throttle(this.updateFragments.bind(this), 250);
        this.renderFragmentsThrottled = ve.throttle(this.renderFragments.bind(this), 250);
        this.findText.connect(this, {
            change: 'onFindChange',
            enter: 'onFindReplaceTextEnter'
        });
        this.replaceText.connect(this, {
            change: 'onReplaceChange',
            enter: 'onFindReplaceTextEnter'
        });
        this.matchCaseToggle.connect(this, {
            change: 'onFindChange'
        });
        this.regexToggle.connect(this, {
            change: 'onFindChange'
        });
        this.wordToggle.connect(this, {
            change: 'onFindChange'
        });
        this.diacriticToggle.connect(this, {
            change: 'onFindChange'
        });
        this.nextButton.connect(this, {
            click: 'findNext'
        });
        this.previousButton.connect(this, {
            click: 'findPrevious'
        });
        this.replaceButton.connect(this, {
            click: 'onReplaceButtonClick'
        });
        this.replaceAllButton.connect(this, {
            click: 'onReplaceAllButtonClick'
        });
        doneButton.connect(this, {
            click: 'close'
        });
        this.tabIndexScope = new ve.ui.TabIndexScope({
            root: this.$element
        });
        this.$content.addClass('ve-ui-findAndReplaceDialog-content');
        this.$body.append($findRow.append($('<div>').addClass('ve-ui-findAndReplaceDialog-cell ve-ui-findAndReplaceDialog-cell-input').append(this.findText.$element), navigateGroup.$element, optionsGroup.$element), $replaceRow.append($('<div>').addClass('ve-ui-findAndReplaceDialog-cell ve-ui-findAndReplaceDialog-cell-input').append(this.replaceText.$element), replaceGroup.$element, doneButton.$element));
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.getSetupProcess = function(data) {
        data = data || {};
        return ve.ui.FindAndReplaceDialog.super.prototype.getSetupProcess.call(this, data).first(function() {
            this.surface = data.surface;
            this.surface.$selections.append(this.$findResults);
            this.surface.getModel().connect(this, {
                documentUpdate: 'onSurfaceModelDocumentUpdate'
            });
            this.surface.getView().connect(this, {
                position: 'onSurfaceViewPosition'
            });
            ve.addPassiveEventListener(this.surface.getView().$window[0], 'scroll', this.onWindowScrollThrottled);
            this.updateFragments();
        }, this);
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.getReadyProcess = function(data) {
        return ve.ui.FindAndReplaceDialog.super.prototype.getReadyProcess.call(this, data).next(function() {
            this.focus();
        }, this);
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.getTeardownProcess = function(data) {
        return ve.ui.FindAndReplaceDialog.super.prototype.getTeardownProcess.call(this, data).next(function() {
            var selection, surfaceView = this.surface.getView(), surfaceModel = this.surface.getModel();
            this.surface.getModel().disconnect(this);
            surfaceView.disconnect(this);
            ve.removePassiveEventListener(this.surface.getView().$window[0], 'scroll', this.onWindowScrollThrottled);
            if (this.fragments.length) {
                selection = this.fragments[this.focusedIndex].getSelection();
            } else {
                selection = this.initialFragment.getSelection();
            }
            surfaceModel.setSelection(selection);
            this.$findResults.empty().detach();
            this.fragments = [];
            this.surface = null;
            this.focusedIndex = 0;
        }, this);
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.onSurfaceModelDocumentUpdate = function() {
        if (this.replacing) {
            return;
        }
        this.clearRenderedResultsCache();
        this.updateFragmentsThrottled();
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.onSurfaceViewPosition = function() {
        if (this.replacing) {
            return;
        }
        this.clearRenderedResultsCache();
        this.renderFragmentsThrottled();
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.onWindowScroll = function() {
        if (this.renderedFragments.getLength() < this.results) {
            this.renderFragments();
        }
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.onFindChange = function() {
        this.updateFragments();
        this.clearRenderedResultsCache();
        this.renderFragments();
        this.highlightFocused(true);
        this.diacriticToggle.setDisabled(!ve.supportsIntl || this.regexToggle.getValue());
        this.updateUserConfigDebounced();
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.onReplaceChange = function() {
        this.updateUserConfigDebounced();
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.updateUserConfig = function() {
        ve.userConfig({
            'visualeditor-findAndReplace-findText': this.findText.getValue(),
            'visualeditor-findAndReplace-matchCase': this.matchCaseToggle.getValue(),
            'visualeditor-findAndReplace-regex': this.regexToggle.getValue(),
            'visualeditor-findAndReplace-word': this.wordToggle.getValue(),
            'visualeditor-findAndReplace-diacritic': this.diacriticToggle.getValue(),
            'visualeditor-findAndReplace-replaceText': this.replaceText.getValue()
        });
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.onFindReplaceTextEnter = function(e) {
        if (!this.results) {
            return;
        }
        if (e.shiftKey) {
            this.findPrevious();
        } else {
            this.findNext();
        }
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.updateFragments = function() {
        var i, l, startIndex, surfaceModel = this.surface.getModel(), documentModel = surfaceModel.getDocument(), isReadOnly = surfaceModel.isReadOnly(), ranges = [], matchCase = this.matchCaseToggle.getValue(), isRegex = this.regexToggle.getValue(), wholeWord = this.wordToggle.getValue(), diacriticInsensitive = this.diacriticToggle.getValue(), find = this.findText.getValue();
        this.invalidRegex = !1;
        if (isRegex && find) {
            try {
                this.query = new RegExp(find,matchCase ? 'g' : 'gi');
            } catch (e) {
                this.invalidRegex = !0;
                this.query = '';
            }
        } else {
            this.query = find;
        }
        this.findText.setValidityFlag();
        this.fragments = [];
        if (this.query) {
            ranges = documentModel.findText(this.query, {
                caseSensitiveString: matchCase,
                diacriticInsensitiveString: diacriticInsensitive,
                noOverlaps: !0,
                wholeWord: wholeWord
            });
            for (i = 0,
            l = ranges.length; i < l; i++) {
                this.fragments.push(surfaceModel.getLinearFragment(ranges[i], true, true));
                if (startIndex === undefined && ranges[i].start >= this.startOffset) {
                    startIndex = this.fragments.length - 1;
                }
            }
        }
        this.results = this.fragments.length;
        this.focusedIndex = startIndex || 0;
        this.nextButton.setDisabled(!this.results);
        this.previousButton.setDisabled(!this.results);
        this.replaceText.setDisabled(isReadOnly);
        this.replaceButton.setDisabled(!this.results || isReadOnly);
        this.replaceAllButton.setDisabled(!this.results || isReadOnly);
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.renderFragments = function() {
        var i, selection, viewportRange, start, end;
        if (!this.surface) {
            return;
        }
        start = 0;
        end = this.results;
        if (this.results > 50) {
            viewportRange = this.surface.getView().getViewportRange();
            for (i = 0; i < this.results; i++) {
                selection = this.fragments[i].getSelection();
                if (viewportRange && selection.getRange().start < viewportRange.start) {
                    start = i + 1;
                    continue;
                }
                if (viewportRange && selection.getRange().end > viewportRange.end) {
                    end = i;
                    break;
                }
            }
        }
        if (end - start <= this.constructor.static.maxRenderedResults) {
            this.renderRangeOfFragments(new ve.Range(start,end));
        } else {
            this.renderRangeOfFragments(new ve.Range(this.focusedIndex,this.focusedIndex + 1));
        }
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.clearRenderedResultsCache = function() {
        this.renderedResultsCache = {};
        this.$findResults.empty();
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.renderRangeOfFragments = function(range) {
        var i, j, jlen, rects, $result, top;
        this.$findResults.empty();
        for (i in this.renderedResultsCache) {
            if (!range.containsOffset(i)) {
                this.renderedResultsCache[i].detach();
            }
        }
        for (i = range.start; i < range.end; i++) {
            if (this.renderedResultsCache[i]) {
                this.$findResults.append(this.renderedResultsCache[i]);
            } else {
                rects = this.surface.getView().getSelection(this.fragments[i].getSelection()).getSelectionRects();
                $result = $('<div>').addClass('ve-ui-findAndReplaceDialog-findResult');
                top = Infinity;
                for (j = 0,
                jlen = rects.length; j < jlen; j++) {
                    top = Math.min(top, rects[j].top);
                    $result.append($('<div>').css({
                        top: rects[j].top,
                        left: rects[j].left,
                        width: rects[j].width,
                        height: rects[j].height
                    }));
                }
                $result.data('top', top);
                this.$findResults.append($result);
                this.renderedResultsCache[i] = $result;
            }
        }
        this.renderedFragments = range;
        this.highlightFocused();
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.highlightFocused = function(scrollIntoView) {
        var $result, rect, top, offset, windowScrollTop, windowScrollHeight, surfaceView = this.surface.getView();
        if (this.results) {
            this.findText.setLabel(ve.msg('visualeditor-find-and-replace-results', this.focusedIndex + 1, this.results));
        } else {
            this.findText.setLabel(this.invalidRegex ? ve.msg('visualeditor-find-and-replace-invalid-regex') : '');
            return;
        }
        this.startOffset = this.fragments[this.focusedIndex].getSelection().getCoveringRange().start;
        this.$findResults.find('.ve-ui-findAndReplaceDialog-findResult-focused').removeClass('ve-ui-findAndReplaceDialog-findResult-focused');
        if (this.renderedFragments.containsOffset(this.focusedIndex)) {
            $result = this.renderedResultsCache[this.focusedIndex].addClass('ve-ui-findAndReplaceDialog-findResult-focused');
            top = $result.data('top');
        } else if (scrollIntoView) {
            rect = surfaceView.getSelection(this.fragments[this.focusedIndex].getSelection()).getSelectionBoundingRect();
            top = rect.top;
        }
        if (scrollIntoView) {
            surfaceView = this.surface.getView();
            offset = top + surfaceView.$element.offset().top;
            windowScrollTop = surfaceView.$window.scrollTop() + this.surface.padding.top;
            windowScrollHeight = surfaceView.$window.height() - this.surface.padding.top;
            if (offset < windowScrollTop || offset > windowScrollTop + windowScrollHeight) {
                $('body, html').animate({
                    scrollTop: offset - (windowScrollHeight / 2)
                }, 'fast');
            }
        }
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.focus = function() {
        this.findText.focus().select();
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.findFirst = function() {
        var text, fragment = this.surface.getModel().getFragment(null, true);
        this.initialFragment = fragment;
        this.startOffset = ve.getProp(this.initialFragment.getSelection().getRanges(this.initialFragment.getDocument()), 0, 'start') || 0;
        text = fragment.getText();
        if (text && text !== this.findText.getValue()) {
            this.findText.setValue(text);
        } else {
            this.onFindChange();
        }
        this.focus();
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.findNext = function() {
        this.focusedIndex = (this.focusedIndex + 1) % this.results;
        this.highlightFocused(true);
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.findPrevious = function() {
        this.focusedIndex = (this.focusedIndex + this.results - 1) % this.results;
        this.highlightFocused(true);
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.onReplaceButtonClick = function() {
        var end;
        if (!this.results) {
            return;
        }
        this.replace(this.focusedIndex);
        end = this.fragments[this.focusedIndex].getSelection().getRange().end;
        this.updateFragments();
        while (this.fragments[this.focusedIndex] && this.fragments[this.focusedIndex].getSelection().getRange().end <= end) {
            this.focusedIndex++;
        }
        this.focusedIndex = this.results ? this.focusedIndex % this.results : 0;
        this.clearRenderedResultsCache();
        this.renderFragments();
        this.highlightFocused(true);
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.onReplaceAllButtonClick = function() {
        var i, l, surfaceView = this.surface.getView(), wasActivated = !surfaceView.isDeactivated();
        if (wasActivated) {
            surfaceView.deactivate();
        }
        for (i = 0,
        l = this.results; i < l; i++) {
            this.replace(i);
        }
        if (wasActivated) {
            surfaceView.activate();
        }
        this.updateFragments();
        this.clearRenderedResultsCache();
        this.renderFragments();
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.replace = function(index) {
        var dialog = this
          , replace = this.replaceText.getValue();
        this.replacing = !0;
        if (this.query instanceof RegExp) {
            this.fragments[index].insertContent(this.fragments[index].getText().replace(this.query, replace), true);
        } else {
            this.fragments[index].insertContent(replace, true);
        }
        setTimeout(function() {
            dialog.replacing = !1;
        });
    }
    ;
    ve.ui.FindAndReplaceDialog.prototype.getActionProcess = function(action) {
        if (action === 'findFirst' || action === 'findNext' || action === 'findPrevious') {
            return new OO.ui.Process(this[action],this);
        }
        return ve.ui.FindAndReplaceDialog.super.prototype.getActionProcess.call(this, action);
    }
    ;
    ve.ui.windowFactory.register(ve.ui.FindAndReplaceDialog);
    ve.ui.ProgressDialog = function VeUiProgressDialog(config) {
        ve.ui.ProgressDialog.super.call(this, config);
    }
    ;
    OO.inheritClass(ve.ui.ProgressDialog, OO.ui.MessageDialog);
    ve.ui.ProgressDialog.static.name = 'progress';
    ve.ui.ProgressDialog.static.size = 'medium';
    ve.ui.ProgressDialog.static.actions = [{
        action: 'cancel',
        label: OO.ui.deferMsg('visualeditor-dialog-action-cancel'),
        flags: 'destructive',
        modes: 'cancellable'
    }];
    ve.ui.ProgressDialog.prototype.initialize = function() {
        ve.ui.ProgressDialog.super.prototype.initialize.call(this);
        this.inProgress = 0;
        this.cancelDeferreds = [];
    }
    ;
    ve.ui.ProgressDialog.prototype.getSetupProcess = function(data) {
        data = data || {};
        return ve.ui.ProgressDialog.super.prototype.getSetupProcess.call(this, data).next(function() {
            var i, l, $row, progressBar, fieldLayout, cancelButton, cancelDeferred, cancellable = !1, progresses = data.progresses;
            this.inProgress = progresses.length;
            this.text.$element.empty();
            this.cancelDeferreds = [];
            for (i = 0,
            l = progresses.length; i < l; i++) {
                cancelDeferred = ve.createDeferred();
                $row = $('<div>').addClass('ve-ui-progressDialog-row');
                progressBar = new OO.ui.ProgressBarWidget();
                fieldLayout = new OO.ui.FieldLayout(progressBar,{
                    label: progresses[i].label,
                    align: 'top'
                });
                $row.append(fieldLayout.$element);
                if (progresses[i].cancellable) {
                    cancelButton = new OO.ui.ButtonWidget({
                        framed: !1,
                        icon: 'cancel',
                        title: OO.ui.deferMsg('visualeditor-dialog-action-cancel')
                    }).on('click', cancelDeferred.reject.bind(cancelDeferred));
                    $row.append(cancelButton.$element);
                    cancellable = !0;
                }
                this.text.$element.append($row);
                progresses[i].progressBarDeferred.resolve(progressBar, cancelDeferred.promise());
                progresses[i].progressCompletePromise.then(this.progressComplete.bind(this, $row, false), this.progressComplete.bind(this, $row, true));
                this.cancelDeferreds.push(cancelDeferred);
            }
            this.actions.setMode(cancellable ? 'cancellable' : 'default');
        }, this);
    }
    ;
    ve.ui.ProgressDialog.prototype.getActionProcess = function(action) {
        return new OO.ui.Process(function() {
            var i, l;
            if (action === 'cancel') {
                for (i = 0,
                l = this.cancelDeferreds.length; i < l; i++) {
                    this.cancelDeferreds[i].reject();
                }
            }
            this.close({
                action: action
            });
        }
        ,this);
    }
    ;
    ve.ui.ProgressDialog.prototype.progressComplete = function($row, failed) {
        this.inProgress--;
        if (!this.inProgress) {
            this.close();
        }
        if (failed) {
            $row.remove();
            this.updateSize();
        }
    }
    ;
    ve.ui.windowFactory.register(ve.ui.ProgressDialog);
    ve.ui.SpecialCharacterDialog = function VeUiSpecialCharacterDialog() {
        ve.ui.SpecialCharacterDialog.super.apply(this, arguments);
        this.characters = null;
        this.$buttonDomList = null;
        this.categories = null;
        this.$element.addClass('ve-ui-specialCharacterDialog');
    }
    ;
    OO.inheritClass(ve.ui.SpecialCharacterDialog, ve.ui.ToolbarDialog);
    ve.ui.SpecialCharacterDialog.static.name = 'specialCharacter';
    ve.ui.SpecialCharacterDialog.static.title = OO.ui.deferMsg('visualeditor-specialcharacter-button-tooltip');
    ve.ui.SpecialCharacterDialog.static.size = 'full';
    ve.ui.SpecialCharacterDialog.static.padded = !1;
    ve.ui.SpecialCharacterDialog.static.activeSurface = !0;
    ve.ui.SpecialCharacterDialog.static.handlesSource = !0;
    ve.ui.SpecialCharacterDialog.prototype.initialize = function() {
        ve.ui.SpecialCharacterDialog.super.prototype.initialize.call(this);
    }
    ;
    ve.ui.SpecialCharacterDialog.prototype.getSetupProcess = function(data) {
        data = data || {};
        return ve.ui.SpecialCharacterDialog.super.prototype.getSetupProcess.call(this, data).next(function() {
            var inspector = this;
            this.surface = data.surface;
            this.surface.getModel().connect(this, {
                contextChange: 'onContextChange'
            });
            if (!this.characters) {
                return ve.init.platform.fetchSpecialCharList().then(function(specialChars) {
                    inspector.characters = specialChars;
                    inspector.buildButtonList();
                });
            }
        }, this);
    }
    ;
    ve.ui.SpecialCharacterDialog.prototype.getTeardownProcess = function(data) {
        data = data || {};
        return ve.ui.SpecialCharacterDialog.super.prototype.getTeardownProcess.call(this, data).first(function() {
            this.surface.getModel().disconnect(this);
            this.surface = null;
        }, this);
    }
    ;
    ve.ui.SpecialCharacterDialog.prototype.getReadyProcess = function(data) {
        return ve.ui.SpecialCharacterDialog.super.prototype.getReadyProcess.call(this, data).next(function() {
            this.surface.getView().focus();
        }, this);
    }
    ;
    ve.ui.SpecialCharacterDialog.prototype.getActionProcess = function(action) {
        return new OO.ui.Process(function() {
            this.close({
                action: action
            });
        }
        ,this);
    }
    ;
    ve.ui.SpecialCharacterDialog.prototype.onContextChange = function() {
        this.setDisabled(!(this.surface.getModel().getSelection()instanceof ve.dm.LinearSelection));
    }
    ;
    ve.ui.SpecialCharacterDialog.prototype.buildButtonList = function() {
        var category;
        this.bookletLayout = new OO.ui.BookletLayout({
            outlined: !0,
            continuous: !0
        });
        this.pages = [];
        for (category in this.characters) {
            this.pages.push(new ve.ui.SpecialCharacterPage(category,{
                label: category,
                characters: this.characters[category],
                source: this.surface.getMode() === 'source'
            }));
        }
        this.bookletLayout.addPages(this.pages);
        this.bookletLayout.$element.on('click', '.ve-ui-specialCharacterPage-character', this.onListClick.bind(this));
        this.$body.append(this.bookletLayout.$element);
        this.updateSize();
    }
    ;
    ve.ui.SpecialCharacterDialog.prototype.onListClick = function(e) {
        var character = $(e.target).data('character')
          , fragment = this.surface.getModel().getFragment();
        if (character) {
            if (typeof character === 'string' || character.string) {
                fragment.insertContent(character.string || character, true).collapseToEnd().select();
            } else if (character.action.type === 'replace') {
                fragment.insertContent(character.action.options.peri, true).collapseToEnd().select();
            } else if (character.action.type === 'encapsulate') {
                fragment.collapseToStart().insertContent(character.action.options.pre, true);
                fragment.collapseToEnd().insertContent(character.action.options.post, true).collapseToEnd().select();
            }
        }
    }
    ;
    ve.ui.windowFactory.register(ve.ui.SpecialCharacterDialog);
    ve.ui.TableDialog = function VeUiTableDialog(config) {
        ve.ui.TableDialog.super.call(this, config);
        this.$element.addClass('ve-ui-tableDialog');
    }
    ;
    OO.inheritClass(ve.ui.TableDialog, ve.ui.FragmentDialog);
    ve.ui.TableDialog.static.name = 'table';
    ve.ui.TableDialog.static.size = 'medium';
    ve.ui.TableDialog.static.title = OO.ui.deferMsg('visualeditor-dialog-table-title');
    ve.ui.TableDialog.prototype.initialize = function() {
        ve.ui.TableDialog.super.prototype.initialize.call(this);
        this.initialValues = null;
        this.panel = new OO.ui.PanelLayout({
            padded: !0,
            expanded: !1,
            classes: ['ve-ui-tableDialog-panel']
        });
        this.captionToggle = new OO.ui.ToggleSwitchWidget();
        this.captionField = new OO.ui.FieldLayout(this.captionToggle,{
            align: 'left',
            label: ve.msg('visualeditor-dialog-table-caption')
        });
        this.captionToggle.connect(this, {
            change: 'updateActions'
        });
        this.panel.$element.append(this.captionField.$element);
        this.$body.append(this.panel.$element);
    }
    ;
    ve.ui.TableDialog.prototype.updateActions = function() {
        this.actions.setAbilities({
            done: !ve.compare(this.getValues(), this.initialValues)
        });
    }
    ;
    ve.ui.TableDialog.prototype.getValues = function() {
        return {
            caption: this.captionToggle.getValue()
        };
    }
    ;
    ve.ui.TableDialog.prototype.getSetupProcess = function(data) {
        return ve.ui.TableDialog.super.prototype.getSetupProcess.call(this, data).next(function() {
            var isReadOnly = this.isReadOnly();
            this.initialValues = {
                caption: !!this.getFragment().getSelection().getTableNode(this.getFragment().getDocument()).getCaptionNode()
            };
            this.captionToggle.setValue(this.initialValues.caption).setDisabled(isReadOnly);
            this.closingFragment = null;
            this.updateActions();
        }, this);
    }
    ;
    ve.ui.TableDialog.prototype.getActionProcess = function(action) {
        return ve.ui.TableDialog.super.prototype.getActionProcess.call(this, action).next(function() {
            var fragment, surfaceModel, selection, captionNode;
            if (action === 'done') {
                surfaceModel = this.getFragment().getSurface();
                selection = surfaceModel.getSelection();
                captionNode = this.getFragment().getSelection().getTableNode(this.getFragment().getDocument()).getCaptionNode();
                if (this.captionToggle.getValue() !== this.initialValues.caption) {
                    if (this.initialValues.caption) {
                        fragment = surfaceModel.getLinearFragment(captionNode.getOuterRange(), true);
                        fragment.removeContent();
                    } else {
                        fragment = surfaceModel.getLinearFragment(new ve.Range(selection.tableRange.start + 1), true);
                        fragment.insertContent([{
                            type: 'tableCaption'
                        }, {
                            type: 'paragraph',
                            internal: {
                                generated: 'wrapper'
                            }
                        }, {
                            type: '/paragraph'
                        }, {
                            type: '/tableCaption'
                        }], false);
                        this.closingFragment = fragment.collapseToStart().adjustLinearSelection(2, 2);
                    }
                }
                this.close({
                    action: 'done'
                });
            }
        }, this);
    }
    ;
    ve.ui.TableDialog.prototype.getTeardownProcess = function(action) {
        return ve.ui.TableDialog.super.prototype.getTeardownProcess.call(this, action).first(function() {
            this.fragment = this.closingFragment || this.fragment;
        }, this);
    }
    ;
    ve.ui.windowFactory.register(ve.ui.TableDialog);
    ve.ui.PlainTextStringTransferHandler = function VeUiPlainTextStringTransferHandler() {
        ve.ui.PlainTextStringTransferHandler.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.PlainTextStringTransferHandler, ve.ui.DataTransferHandler);
    ve.ui.PlainTextStringTransferHandler.static.name = 'plainTextString';
    ve.ui.PlainTextStringTransferHandler.static.types = ['text/plain'];
    ve.ui.PlainTextStringTransferHandler.static.handlesPaste = !1;
    ve.ui.PlainTextStringTransferHandler.prototype.process = function() {
        this.resolve(this.item.getAsString());
    }
    ;
    ve.ui.dataTransferHandlerFactory.register(ve.ui.PlainTextStringTransferHandler);
    ve.ui.HTMLStringTransferHandler = function VeUiHTMLStringTransferHandler() {
        ve.ui.HTMLStringTransferHandler.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.HTMLStringTransferHandler, ve.ui.DataTransferHandler);
    ve.ui.HTMLStringTransferHandler.static.name = 'htmlString';
    ve.ui.HTMLStringTransferHandler.static.types = ['text/html', 'application/xhtml+xml'];
    ve.ui.HTMLStringTransferHandler.static.handlesPaste = !1;
    ve.ui.HTMLStringTransferHandler.prototype.process = function() {
        this.resolve(this.surface.getModel().getDocument().newFromHtml(this.item.getAsString(), this.surface.getImportRules()));
    }
    ;
    ve.ui.dataTransferHandlerFactory.register(ve.ui.HTMLStringTransferHandler);
    ve.ui.DSVFileTransferHandler = function VeUiDSVFileTransferHandler() {
        ve.ui.DSVFileTransferHandler.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.DSVFileTransferHandler, ve.ui.FileTransferHandler);
    ve.ui.DSVFileTransferHandler.static.name = 'dsv';
    ve.ui.DSVFileTransferHandler.static.types = ['text/csv', 'text/tab-separated-values'];
    ve.ui.DSVFileTransferHandler.static.extensions = ['csv', 'tsv'];
    ve.ui.DSVFileTransferHandler.prototype.onFileLoad = function() {
        var i, j, line, tableNodeName, tableNodeClass, tableElement, data = [], input = Papa.parse(this.reader.result);
        if (input.meta.aborted || (input.data.length <= 0)) {
            this.abort();
        } else {
            tableNodeName = ve.dm.modelRegistry.matchElement(document.createElement('table'));
            tableNodeClass = ve.dm.modelRegistry.lookup(tableNodeName);
            tableElement = {
                type: tableNodeName
            };
            tableNodeClass.static.sanitize(tableElement);
            data.push(tableElement, {
                type: 'tableSection',
                attributes: {
                    style: 'body'
                }
            });
            for (i = 0; i < input.data.length; i++) {
                line = input.data[i];
                if (i === input.data.length - 1 && line.length === 1 && line[0] === '') {
                    continue;
                }
                data.push({
                    type: 'tableRow'
                });
                for (j = 0; j < line.length; j++) {
                    data.push({
                        type: 'tableCell',
                        attributes: {
                            style: (i === 0 ? 'header' : 'data')
                        }
                    }, {
                        type: 'paragraph',
                        internal: {
                            generated: 'wrapper'
                        }
                    });
                    data = data.concat(line[j].split(''));
                    data.push({
                        type: '/paragraph'
                    }, {
                        type: '/tableCell'
                    });
                }
                data.push({
                    type: '/tableRow'
                });
            }
            data.push({
                type: '/tableSection'
            }, {
                type: '/' + tableElement.type
            });
            this.resolve(data);
        }
        ve.ui.DSVFileTransferHandler.super.prototype.onFileLoad.apply(this, arguments);
    }
    ;
    ve.ui.dataTransferHandlerFactory.register(ve.ui.DSVFileTransferHandler);
    ve.ui.PlainTextFileTransferHandler = function VeUiPlainTextFileTransferHandler() {
        ve.ui.PlainTextFileTransferHandler.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.PlainTextFileTransferHandler, ve.ui.FileTransferHandler);
    ve.ui.PlainTextFileTransferHandler.static.name = 'plainTextFile';
    ve.ui.PlainTextFileTransferHandler.static.types = ['text/plain'];
    ve.ui.PlainTextFileTransferHandler.static.extensions = ['txt'];
    ve.ui.PlainTextFileTransferHandler.prototype.onFileLoad = function() {
        this.resolve(this.reader.result);
        ve.ui.PlainTextFileTransferHandler.super.prototype.onFileLoad.apply(this, arguments);
    }
    ;
    ve.ui.dataTransferHandlerFactory.register(ve.ui.PlainTextFileTransferHandler);
    ve.ui.HTMLFileTransferHandler = function VeUiHTMLFileTransferHandler() {
        ve.ui.HTMLFileTransferHandler.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.HTMLFileTransferHandler, ve.ui.FileTransferHandler);
    ve.ui.HTMLFileTransferHandler.static.name = 'htmlFile';
    ve.ui.HTMLFileTransferHandler.static.types = ['text/html', 'application/xhtml+xml'];
    ve.ui.HTMLFileTransferHandler.static.extensions = ['html', 'htm', 'xhtml'];
    ve.ui.HTMLFileTransferHandler.prototype.onFileLoad = function() {
        this.resolve(this.surface.getModel().getDocument().newFromHtml(this.reader.result, this.surface.getImportRules()));
        ve.ui.HTMLFileTransferHandler.super.prototype.onFileLoad.apply(this, arguments);
    }
    ;
    ve.ui.dataTransferHandlerFactory.register(ve.ui.HTMLFileTransferHandler);
    ve.ui.UrlStringTransferHandler = function VeUiUrlStringTransferHandler() {
        ve.ui.UrlStringTransferHandler.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.UrlStringTransferHandler, ve.ui.PlainTextStringTransferHandler);
    ve.ui.UrlStringTransferHandler.static.name = 'urlString';
    ve.ui.UrlStringTransferHandler.static.types = ['text/uri-list', 'text/x-moz-url', 'text/x-uri'].concat(ve.ui.UrlStringTransferHandler.super.static.types);
    ve.ui.UrlStringTransferHandler.static.handlesPaste = !0;
    ve.ui.UrlStringTransferHandler.static.urlRegExp = null;
    ve.init.Platform.static.initializedPromise.then(function() {
        ve.ui.UrlStringTransferHandler.static.urlRegExp = new RegExp(ve.init.platform.getExternalLinkUrlProtocolsRegExp().source + '\\S+$','i');
    });
    ve.ui.UrlStringTransferHandler.static.matchFunction = function(item) {
        if (ve.ui.UrlStringTransferHandler.static.types.indexOf(item.type) >= 0 && item.type !== 'text/plain') {
            return true;
        }
        return ve.ui.UrlStringTransferHandler.static.urlRegExp.test(item.getAsString());
    }
    ;
    ve.ui.UrlStringTransferHandler.prototype.process = function() {
        var links, html, doc, result, surface = this.surface, store = surface.getModel().getDocument().getStore(), linkAction = ve.ui.actionFactory.create('link', surface), data = this.item.getAsString();
        switch (this.item.type) {
        case 'text/uri-list':
            links = data.replace(/^#.*(\r\n?|\n|$)/mg, '').trim().split(/[\r\n]+/g).map(function(line) {
                return {
                    href: line
                };
            });
            if (this.item.data.htmlStringData) {
                html = this.item.data.htmlStringData;
                doc = ve.createDocumentFromHtml(html);
                links = $.makeArray(doc.querySelectorAll('a[href]')).map(function(a) {
                    return {
                        href: a.href,
                        title: a.textContent
                    };
                });
            }
            break;
        case 'text/x-moz-url':
            links = data.match(/^(.*)(\r\n?|\n)(.*)$/mg).map(function(item) {
                item = item.split(/[\r\n]+/);
                return {
                    href: item[0],
                    title: item[1]
                };
            });
            break;
        default:
            links = [{
                href: data.trim()
            }];
            break;
        }
        result = [];
        links.forEach(function(link) {
            var i, annotation = linkAction.getLinkAnnotation(link.href), annotationSet = new ve.dm.AnnotationSet(store,store.hashAll([annotation])), title = link.title || annotation.getDisplayTitle(), content = title.split('');
            if (result.length) {
                result.push(' ');
            }
            ve.dm.Document.static.addAnnotationsToData(content, annotationSet);
            for (i = 0; i < content.length; i++) {
                result.push(content[i]);
            }
        });
        this.resolve(result);
    }
    ;
    ve.ui.dataTransferHandlerFactory.register(ve.ui.UrlStringTransferHandler);
    ve.ui.PreviewElement = function VeUiPreviewElement(model, config) {
        config = config || {};
        ve.ui.PreviewElement.super.call(this, config);
        OO.EventEmitter.call(this);
        this.useView = !!config.useView;
        if (model) {
            this.setModel(model);
        }
        this.$element.addClass('ve-ui-previewElement');
    }
    ;
    OO.inheritClass(ve.ui.PreviewElement, OO.ui.Element);
    OO.mixinClass(ve.ui.PreviewElement, OO.EventEmitter);
    ve.ui.PreviewElement.prototype.destroy = function() {
        if (this.view) {
            this.view.destroy();
            this.view = null;
        }
    }
    ;
    ve.ui.PreviewElement.prototype.setModel = function(model) {
        this.model = model;
        this.updatePreview();
    }
    ;
    ve.ui.PreviewElement.prototype.replaceWithModelDom = function() {
        var htmlDocument = ve.dm.converter.getDomFromNode(this.model, ve.dm.Converter.static.PREVIEW_MODE)
          , body = htmlDocument.body
          , element = this.$element[0];
        ve.resolveAttributes(body, this.model.getDocument().getHtmlDocument(), ve.dm.Converter.static.computedAttributes);
        ve.targetLinksToNewWindow(body);
        element.innerHTML = '';
        while (body.childNodes.length) {
            element.appendChild(element.ownerDocument.adoptNode(body.childNodes[0]));
        }
        this.afterRender();
    }
    ;
    ve.ui.PreviewElement.prototype.updatePreview = function() {
        var element = this;
        this.view = ve.ce.nodeFactory.createFromModel(this.model);
        this.$element.append(this.view.$element);
        this.view.setLive(true);
        ve.ce.GeneratedContentNode.static.awaitGeneratedContent(this.view).then(function() {
            if (!element.useView) {
                if (element.view) {
                    element.replaceWithModelDom();
                }
            } else {
                element.afterRender();
            }
        });
    }
    ;
    ve.ui.PreviewElement.prototype.afterRender = function() {
        this.view.destroy();
        this.view = null;
        this.emit('render');
    }
    ;
    ve.ui.PreviewElement.prototype.isGenerating = function() {
        return !!this.view;
    }
    ;
    ve.ui.ToolbarDialogWindowManager = function VeUiToolbarDialogWindowManager(surface, config) {
        ve.ui.ToolbarDialogWindowManager.super.call(this, surface, config);
    }
    ;
    OO.inheritClass(ve.ui.ToolbarDialogWindowManager, ve.ui.SurfaceWindowManager);
    ve.ui.ToolbarDialogWindowManager.static.sizes = {
        full: {
            width: '100%',
            maxHeight: '100%'
        },
        small: {
            width: 150
        },
        medium: {
            width: 300
        },
        large: {
            width: 400
        }
    };
    ve.ui.ToolbarDialogWindowManager.prototype.getTeardownDelay = function() {
        return 250;
    }
    ;
    ve.ui.AlignWidget = function VeUiAlignWidget(config) {
        var alignButtons;
        config = config || {};
        ve.ui.AlignWidget.super.call(this, config);
        alignButtons = [new OO.ui.ButtonOptionWidget({
            data: 'left',
            icon: 'alignLeft',
            label: ve.msg('visualeditor-align-widget-left')
        }), new OO.ui.ButtonOptionWidget({
            data: 'center',
            icon: 'alignCenter',
            label: ve.msg('visualeditor-align-widget-center')
        }), new OO.ui.ButtonOptionWidget({
            data: 'right',
            icon: 'alignRight',
            label: ve.msg('visualeditor-align-widget-right')
        })];
        if (config.dir === 'rtl') {
            alignButtons = alignButtons.reverse();
        }
        this.addItems(alignButtons, 0);
    }
    ;
    OO.inheritClass(ve.ui.AlignWidget, OO.ui.ButtonSelectWidget);
    ve.ui.TargetWidget = function VeUiTargetWidget(config) {
        config = config || {};
        ve.ui.TargetWidget.super.call(this, config);
        OO.ui.mixin.PendingElement.call(this, config);
        this.toolbarGroups = config.toolbarGroups;
        this.includeCommands = config.includeCommands;
        this.excludeCommands = config.excludeCommands;
        this.multiline = config.multiline !== !1;
        this.placeholder = config.placeholder;
        this.readOnly = config.readOnly;
        this.importRules = config.importRules;
        this.inDialog = config.inDialog;
        this.modes = config.modes;
        this.defaultMode = config.defaultMode;
        this.target = this.createTarget();
        if (config.doc) {
            this.setDocument(config.doc);
        }
        this.$element.addClass('ve-ui-targetWidget').append(this.target.$element);
    }
    ;
    OO.inheritClass(ve.ui.TargetWidget, OO.ui.Widget);
    OO.mixinClass(ve.ui.TargetWidget, OO.ui.mixin.PendingElement);
    ve.ui.TargetWidget.prototype.createTarget = function() {
        return new ve.init.Target({
            register: !1,
            toolbarGroups: this.toolbarGroups,
            inTargetWidget: !0,
            modes: this.modes,
            defaultMode: this.defaultMode
        });
    }
    ;
    ve.ui.TargetWidget.prototype.setDocument = function(doc) {
        var surface;
        this.clear();
        surface = this.target.addSurface(doc, {
            inTargetWidget: !0,
            includeCommands: this.includeCommands,
            excludeCommands: this.excludeCommands,
            importRules: this.importRules,
            multiline: this.multiline,
            placeholder: this.placeholder,
            readOnly: this.readOnly,
            inDialog: this.inDialog
        });
        this.target.setSurface(surface);
        this.getSurface().getView().connect(this, {
            focus: 'onFocusChange',
            blur: 'onFocusChange'
        });
        this.getSurface().getModel().connect(this, {
            history: ['emit', 'change']
        });
        this.getSurface().connect(this, {
            submit: ['emit', 'submit']
        });
        this.emit('setup');
    }
    ;
    ve.ui.TargetWidget.prototype.hasBeenModified = function() {
        return !!this.getSurface() && this.getSurface().getModel().hasBeenModified();
    }
    ;
    ve.ui.TargetWidget.prototype.setReadOnly = function(readOnly) {
        this.readOnly = !!readOnly;
        if (this.getSurface()) {
            this.getSurface().setReadOnly(this.readOnly);
        }
        this.$element.toggleClass('ve-ui-targetWidget-readOnly', this.readOnly);
    }
    ;
    ve.ui.TargetWidget.prototype.isReadOnly = function() {
        return this.readOnly;
    }
    ;
    ve.ui.TargetWidget.prototype.getSurface = function() {
        return this.target.getSurface();
    }
    ;
    ve.ui.TargetWidget.prototype.getToolbar = function() {
        return this.target.getToolbar();
    }
    ;
    ve.ui.TargetWidget.prototype.getContent = function() {
        return this.getSurface().getModel().getDocument().getData();
    }
    ;
    ve.ui.TargetWidget.prototype.initialize = function() {
        OO.ui.warnDeprecation('ve.ui.TargetWidget#initialize is deprecated and no longer needed.');
    }
    ;
    ve.ui.TargetWidget.prototype.clear = function() {
        this.target.clearSurfaces();
    }
    ;
    ve.ui.TargetWidget.prototype.onFocusChange = function() {
        var surface = this.getSurface();
        this.$element.toggleClass('ve-ui-targetWidget-focused', surface && surface.getView().isFocused());
    }
    ;
    ve.ui.TargetWidget.prototype.focus = function() {
        var surface = this.getSurface();
        if (surface) {
            if (!surface.getView().attachedRoot.isLive()) {
                surface.once('ready', function() {
                    surface.getView().focus();
                });
            } else {
                surface.getView().focus();
            }
        }
    }
    ;
    ve.ui.LinkAnnotationWidget = function VeUiLinkAnnotationWidget(config) {
        this.annotation = null;
        this.input = this.createInputWidget(config);
        ve.ui.LinkAnnotationWidget.super.apply(this, arguments);
        this.$element.append(this.input.$element).addClass('ve-ui-linkAnnotationWidget');
        this.getTextInputWidget().connect(this, {
            change: 'onTextChange'
        });
    }
    ;
    OO.inheritClass(ve.ui.LinkAnnotationWidget, OO.ui.Widget);
    ve.ui.LinkAnnotationWidget.static.getAnnotationFromText = function(value) {
        var href = value.trim();
        if (href === '') {
            return null;
        } else {
            return new ve.dm.LinkAnnotation({
                type: 'link',
                attributes: {
                    href: href
                }
            });
        }
    }
    ;
    ve.ui.LinkAnnotationWidget.static.getTextFromAnnotation = function(annotation) {
        return annotation ? annotation.getHref() : '';
    }
    ;
    ve.ui.LinkAnnotationWidget.prototype.createInputWidget = function(config) {
        return new OO.ui.TextInputWidget(ve.extendObject({
            validate: 'non-empty'
        }, config));
    }
    ;
    ve.ui.LinkAnnotationWidget.prototype.getTextInputWidget = function() {
        return this.input;
    }
    ;
    ve.ui.LinkAnnotationWidget.prototype.setDisabled = function() {
        ve.ui.LinkAnnotationWidget.super.prototype.setDisabled.apply(this, arguments);
        this.getTextInputWidget().setDisabled(this.isDisabled());
        return this;
    }
    ;
    ve.ui.LinkAnnotationWidget.prototype.onTextChange = function(value) {
        var isExt, widget = this;
        if (document.body.classList.contains('rtl')) {
            isExt = ve.init.platform.getExternalLinkUrlProtocolsRegExp().test(value.trim());
            this.getTextInputWidget().setDir(isExt ? 'ltr' : 'rtl');
        }
        this.getTextInputWidget().getValidity().done(function() {
            widget.setAnnotation(widget.constructor.static.getAnnotationFromText(value), true);
        }).fail(function() {
            widget.setAnnotation(null, true);
        });
    }
    ;
    ve.ui.LinkAnnotationWidget.prototype.setAnnotation = function(annotation, fromText) {
        if (ve.compare(annotation ? annotation.getComparableObject() : {}, this.annotation ? this.annotation.getComparableObject() : {})) {
            return this;
        }
        this.annotation = annotation;
        if (!fromText) {
            this.getTextInputWidget().setValue(this.constructor.static.getTextFromAnnotation(annotation));
        }
        this.emit('change', this.annotation);
        return this;
    }
    ;
    ve.ui.LinkAnnotationWidget.prototype.getAnnotation = function() {
        return this.annotation;
    }
    ;
    ve.ui.LinkAnnotationWidget.prototype.getHref = function() {
        return this.constructor.static.getTextFromAnnotation(this.annotation);
    }
    ;
    ve.ui.LinkAnnotationWidget.prototype.setReadOnly = function(readOnly) {
        this.input.setReadOnly(readOnly);
        return this;
    }
    ;
    ve.ui.CompletionWidget = function VeUiCompletionWidget(surface, config) {
        var $doc = surface.getView().getDocument().getDocumentNode().$element;
        this.surface = surface;
        this.surfaceModel = surface.getModel();
        config = config || {
            anchor: !1
        };
        ve.ui.CompletionWidget.super.call(this, config);
        this.$tabIndexed = this.$element;
        this.menu = new OO.ui.MenuSelectWidget({
            widget: this,
            $input: $doc,
            width: 'auto'
        });
        this.menu.connect(this, {
            choose: 'onMenuChoose'
        });
        this.$element.addClass('ve-ui-completionWidget').append(this.menu.$element);
    }
    ;
    OO.inheritClass(ve.ui.CompletionWidget, OO.ui.Widget);
    ve.ui.CompletionWidget.prototype.setup = function(action) {
        var offset = this.surfaceModel.getSelection().getRange();
        if (!offset.isCollapsed()) {
            return;
        }
        this.action = action;
        this.initialOffset = offset.end - this.action.constructor.static.triggerLength;
        this.update();
        this.surfaceModel.connect(this, {
            select: 'onModelSelect'
        });
    }
    ;
    ve.ui.CompletionWidget.prototype.teardown = function() {
        this.menu.toggle(false);
        this.surfaceModel.disconnect(this);
        this.action = undefined;
    }
    ;
    ve.ui.CompletionWidget.prototype.update = function() {
        var direction = this.surface.getDir()
          , range = this.getCompletionRange()
          , boundingRect = this.surface.getView().getSelection(new ve.dm.LinearSelection(range)).getSelectionBoundingRect()
          , style = {
            top: boundingRect.bottom
        }
          , data = this.surfaceModel.getDocument().data
          , input = data.getText(false, range);
        if (direction === 'rtl') {
            style.left = boundingRect.right;
        } else {
            style.left = boundingRect.left;
        }
        this.$element.css(style);
        this.action.getSuggestions(input).then(function(items) {
            this.menu.clearItems().addItems(items.map(this.action.getMenuItemForSuggestion.bind(this.action)));
            if (this.menu.getItems().length) {
                this.menu.highlightItem(this.menu.getItems()[0]);
            }
            this.menu.toggle(true);
        }
        .bind(this));
    }
    ;
    ve.ui.CompletionWidget.prototype.onMenuChoose = function(item) {
        var fragment = this.action.insertCompletion(item.getData(), this.getCompletionRange(true));
        fragment.collapseToEnd().select();
        this.teardown();
    }
    ;
    ve.ui.CompletionWidget.prototype.onModelSelect = function() {
        var range = this.getCompletionRange();
        if (!range || range.isBackwards() || this.action.shouldAbandon(this.surfaceModel.getDocument().data.getText(false, range), this.menu.getItems().length)) {
            this.teardown();
        } else {
            this.update();
        }
    }
    ;
    ve.ui.CompletionWidget.prototype.getCompletionRange = function(withTrigger) {
        var range = this.surfaceModel.getSelection().getCoveringRange();
        if (!range || !range.isCollapsed() || !this.action) {
            return null;
        }
        return new ve.Range(this.initialOffset + (withTrigger ? 0 : this.action.constructor.static.triggerLength),range.end);
    }
    ;
    ve.ui.ContextSelectWidget = function VeUiContextSelectWidget(config) {
        config = config || {};
        ve.ui.ContextSelectWidget.super.call(this, config);
        this.connect(this, {
            choose: 'onChooseItem'
        });
        this.$element.addClass('ve-ui-contextSelectWidget');
    }
    ;
    OO.inheritClass(ve.ui.ContextSelectWidget, OO.ui.SelectWidget);
    ve.ui.ContextSelectWidget.prototype.onChooseItem = function() {
        this.selectItem(null);
    }
    ;
    ve.ui.ContextOptionWidget = function VeUiContextOptionWidget(tool, model, config) {
        config = config || {};
        ve.ui.ContextOptionWidget.super.call(this, config);
        this.tool = tool;
        this.model = model;
        this.$element.addClass('ve-ui-contextOptionWidget');
        this.setIcon(this.tool.static.icon);
        this.setLabel(this.getDescription());
    }
    ;
    OO.inheritClass(ve.ui.ContextOptionWidget, OO.ui.DecoratedOptionWidget);
    ve.ui.ContextOptionWidget.prototype.getDescription = function() {
        var description;
        if (this.model instanceof ve.dm.Annotation) {
            description = ve.ce.annotationFactory.getDescription(this.model);
        } else if (this.model instanceof ve.dm.Node) {
            description = ve.ce.nodeFactory.getDescription(this.model);
        }
        if (!description) {
            description = this.tool.static.title;
        }
        return description;
    }
    ;
    ve.ui.ContextOptionWidget.prototype.getCommand = function() {
        return this.tool.static.getCommand(this.context.getSurface());
    }
    ;
    ve.ui.DimensionsWidget = function VeUiDimensionsWidget(config) {
        var labelTimes, labelPx;
        config = config || {};
        ve.ui.DimensionsWidget.super.call(this, config);
        this.widthInput = new OO.ui.TextInputWidget({
            validate: config.validate || $.isNumeric
        });
        this.heightInput = new OO.ui.TextInputWidget({
            validate: config.validate || $.isNumeric
        });
        this.defaults = config.defaults || {
            width: '',
            height: ''
        };
        this.setReadOnly(!!config.readOnly);
        this.renderDefaults();
        labelTimes = new OO.ui.LabelWidget({
            label: ve.msg('visualeditor-dimensionswidget-times')
        });
        labelPx = new OO.ui.LabelWidget({
            label: ve.msg('visualeditor-dimensionswidget-px')
        });
        this.widthInput.connect(this, {
            change: 'onWidthChange'
        });
        this.heightInput.connect(this, {
            change: 'onHeightChange'
        });
        this.$element.addClass('ve-ui-dimensionsWidget').append(this.widthInput.$element, labelTimes.$element.addClass('ve-ui-dimensionsWidget-label-times'), this.heightInput.$element, labelPx.$element.addClass('ve-ui-dimensionsWidget-label-px'));
    }
    ;
    OO.inheritClass(ve.ui.DimensionsWidget, OO.ui.Widget);
    ve.ui.DimensionsWidget.prototype.onWidthChange = function(value) {
        this.emit('widthChange', value);
    }
    ;
    ve.ui.DimensionsWidget.prototype.onHeightChange = function(value) {
        this.emit('heightChange', value);
    }
    ;
    ve.ui.DimensionsWidget.prototype.setDefaults = function(dimensions) {
        if (dimensions.width && dimensions.height) {
            this.defaults = ve.copy(dimensions);
            this.renderDefaults();
        }
        return this;
    }
    ;
    ve.ui.DimensionsWidget.prototype.renderDefaults = function() {
        this.widthInput.$input.prop('placeholder', this.getDefaults().width);
        this.heightInput.$input.prop('placeholder', this.getDefaults().height);
    }
    ;
    ve.ui.DimensionsWidget.prototype.getDefaults = function() {
        return this.defaults;
    }
    ;
    ve.ui.DimensionsWidget.prototype.removeDefaults = function() {
        this.defaults = {
            width: '',
            height: ''
        };
        this.renderDefaults();
        return this;
    }
    ;
    ve.ui.DimensionsWidget.prototype.isEmpty = function() {
        return (this.widthInput.getValue() === '' && this.heightInput.getValue() === '');
    }
    ;
    ve.ui.DimensionsWidget.prototype.clear = function() {
        this.widthInput.setValue('');
        this.heightInput.setValue('');
        return this;
    }
    ;
    ve.ui.DimensionsWidget.prototype.reset = function() {
        this.setDimensions(this.getDefaults());
        return this;
    }
    ;
    ve.ui.DimensionsWidget.prototype.setDimensions = function(dimensions) {
        if (dimensions.width) {
            this.setWidth(dimensions.width);
        }
        if (dimensions.height) {
            this.setHeight(dimensions.height);
        }
        return this;
    }
    ;
    ve.ui.DimensionsWidget.prototype.getDimensions = function() {
        return {
            width: +this.widthInput.getValue(),
            height: +this.heightInput.getValue()
        };
    }
    ;
    ve.ui.DimensionsWidget.prototype.setDisabled = function(disabled) {
        ve.ui.DimensionsWidget.super.prototype.setDisabled.call(this, disabled);
        if (this.widthInput) {
            this.widthInput.setDisabled(disabled);
        }
        if (this.heightInput) {
            this.heightInput.setDisabled(disabled);
        }
        return this;
    }
    ;
    ve.ui.DimensionsWidget.prototype.isReadOnly = function() {
        return this.readOnly;
    }
    ;
    ve.ui.DimensionsWidget.prototype.setReadOnly = function(readOnly) {
        this.readOnly = readOnly;
        this.widthInput.setReadOnly(readOnly);
        this.heightInput.setReadOnly(readOnly);
        return this;
    }
    ;
    ve.ui.DimensionsWidget.prototype.getWidth = function() {
        return this.widthInput.getValue();
    }
    ;
    ve.ui.DimensionsWidget.prototype.getHeight = function() {
        return this.heightInput.getValue();
    }
    ;
    ve.ui.DimensionsWidget.prototype.setWidth = function(value) {
        this.widthInput.setValue(value);
        return this;
    }
    ;
    ve.ui.DimensionsWidget.prototype.setHeight = function(value) {
        this.heightInput.setValue(value);
        return this;
    }
    ;
    ve.ui.DimensionsWidget.prototype.setValidityFlag = function() {
        this.widthInput.setValidityFlag();
        this.heightInput.setValidityFlag();
        return this;
    }
    ;
    ve.ui.MediaSizeWidget = function VeUiMediaSizeWidget(scalable, config) {
        var dimensionsField, sizeTypeField;
        config = config || {};
        this.scalable = scalable;
        ve.ui.MediaSizeWidget.super.call(this, config);
        this.ratio = {};
        this.currentDimensions = {};
        this.maxDimensions = {};
        this.valid = null;
        this.noDefaultDimensions = !!config.noDefaultDimensions;
        this.dimensionsAlign = config.dimensionsAlign || 'right';
        this.sizeTypeSelect = new OO.ui.ButtonSelectWidget({
            classes: ['ve-ui-mediaSizeWidget-section-sizetype']
        });
        this.sizeTypeSelect.addItems([new OO.ui.ButtonOptionWidget({
            data: 'default',
            label: ve.msg('visualeditor-mediasizewidget-sizeoptions-default')
        }), new OO.ui.ButtonOptionWidget({
            data: 'custom',
            label: ve.msg('visualeditor-mediasizewidget-sizeoptions-custom')
        })]);
        sizeTypeField = new OO.ui.FieldLayout(this.sizeTypeSelect);
        this.dimensions = new ve.ui.DimensionsWidget({
            validate: this.isValid.bind(this)
        });
        this.errorLabel = new OO.ui.LabelWidget({
            label: ve.msg('visualeditor-mediasizewidget-label-defaulterror')
        });
        dimensionsField = new OO.ui.FieldLayout(this.dimensions,{
            align: this.dimensionsAlign,
            classes: ['ve-ui-mediaSizeWidget-section-custom']
        });
        this.$element.addClass('ve-ui-mediaSizeWidget');
        if (!this.noDefaultDimensions) {
            this.$element.append(sizeTypeField.$element);
        }
        this.$element.append(dimensionsField.$element);
        this.$element.append($('<div>').addClass('ve-ui-mediaSizeWidget-label-error').append(this.errorLabel.$element));
        this.dimensions.connect(this, {
            widthChange: ['onDimensionsChange', 'width'],
            heightChange: ['onDimensionsChange', 'height']
        });
        this.sizeTypeSelect.connect(this, {
            choose: 'onSizeTypeChoose'
        });
    }
    ;
    OO.inheritClass(ve.ui.MediaSizeWidget, OO.ui.Widget);
    ve.ui.MediaSizeWidget.prototype.onScalableOriginalSizeChange = function() {
        this.updateDisabled();
        this.validateDimensions();
    }
    ;
    ve.ui.MediaSizeWidget.prototype.onScalableCurrentSizeChange = function(dimensions) {
        if (!ve.isEmptyObject(dimensions)) {
            this.setCurrentDimensions(dimensions);
            this.validateDimensions();
        }
    }
    ;
    ve.ui.MediaSizeWidget.prototype.onScalableDefaultSizeChange = function(isDefault) {
        this.updateDefaultDimensions();
        this.setSizeType(isDefault ? 'default' : 'custom');
        this.validateDimensions();
    }
    ;
    ve.ui.MediaSizeWidget.prototype.onDimensionsChange = function(type, value) {
        var dimensions = {};
        if (+value === 0 && !this.noDefaultDimensions) {
            this.setSizeType('default');
        } else {
            this.setSizeType('custom');
            if (!isNaN(+value)) {
                dimensions[type] = +value;
                this.setCurrentDimensions(dimensions);
            } else {
                this.validateDimensions();
            }
        }
    }
    ;
    ve.ui.MediaSizeWidget.prototype.onSizeTypeChoose = function(item) {
        var selectedType = item.getData()
          , wasDefault = this.scalable.isDefault();
        this.scalable.toggleDefault(selectedType === 'default');
        if (selectedType === 'default') {
            if (!ve.isEmptyObject(this.dimensions.getDefaults())) {
                this.dimensions.clear();
            }
        } else if (selectedType === 'custom') {
            if (wasDefault && !ve.isEmptyObject(this.dimensions.getDefaults())) {
                this.setCurrentDimensions(this.dimensions.getDefaults());
            }
            this.validateDimensions();
        }
        this.emit('changeSizeType', selectedType);
        this.updateDisabled();
        this.validateDimensions();
    }
    ;
    ve.ui.MediaSizeWidget.prototype.setSizeType = function(sizeType) {
        if (this.getSizeType() !== sizeType || +this.dimensions.getWidth() === 0 || +this.dimensions.getHeight() === 0) {
            this.sizeTypeSelect.chooseItem(this.sizeTypeSelect.findItemFromData(sizeType));
        }
        return this;
    }
    ;
    ve.ui.MediaSizeWidget.prototype.getSizeType = function() {
        return this.sizeTypeSelect.findSelectedItem() ? this.sizeTypeSelect.findSelectedItem().getData() : '';
    }
    ;
    ve.ui.MediaSizeWidget.prototype.setScalable = function(scalable) {
        if (this.scalable instanceof ve.dm.Scalable) {
            this.scalable.disconnect(this);
        }
        this.scalable = scalable;
        this.scalable.connect(this, {
            defaultSizeChange: 'onScalableDefaultSizeChange',
            originalSizeChange: 'onScalableOriginalSizeChange',
            currentSizeChange: 'onScalableCurrentSizeChange'
        });
        this.updateDefaultDimensions();
        if (!this.scalable.isDefault()) {
            this.setCurrentDimensions(this.scalable.getCurrentDimensions());
        }
        if (this.scalable.getOriginalDimensions()) {
            this.setSizeType(this.scalable.isDefault() ? 'default' : 'custom');
        }
        this.updateDisabled();
        this.validateDimensions();
        return this;
    }
    ;
    ve.ui.MediaSizeWidget.prototype.getScalable = function() {
        return this.scalable;
    }
    ;
    ve.ui.MediaSizeWidget.prototype.setRatio = function(ratio) {
        this.scalable.setRatio(ratio);
        return this;
    }
    ;
    ve.ui.MediaSizeWidget.prototype.getRatio = function() {
        return this.scalable.getRatio();
    }
    ;
    ve.ui.MediaSizeWidget.prototype.setMaxDimensions = function(dimensions) {
        var maxDimensions = ve.dm.Scalable.static.getDimensionsFromValue(dimensions, this.scalable.getRatio());
        this.scalable.setMaxDimensions(maxDimensions);
        return this;
    }
    ;
    ve.ui.MediaSizeWidget.prototype.getMaxDimensions = function() {
        return this.scalable.getMaxDimensions();
    }
    ;
    ve.ui.MediaSizeWidget.prototype.getCurrentDimensions = function() {
        return this.currentDimensions;
    }
    ;
    ve.ui.MediaSizeWidget.prototype.setDisabled = function(disabled) {
        ve.ui.MediaSizeWidget.super.prototype.setDisabled.call(this, disabled);
        this.updateDisabled();
        return this;
    }
    ;
    ve.ui.MediaSizeWidget.prototype.updateDisabled = function() {
        var sizeType, disabled = this.isDisabled();
        if (this.sizeTypeSelect && this.dimensions && this.scalable) {
            sizeType = this.getSizeType();
            this.sizeTypeSelect.setDisabled(disabled);
            this.sizeTypeSelect.findItemFromData('default').setDisabled(ve.isEmptyObject(this.scalable.getDefaultDimensions()));
            this.dimensions.setDisabled(disabled || sizeType !== 'custom');
        }
        return this;
    }
    ;
    ve.ui.MediaSizeWidget.prototype.setCurrentDimensions = function(dimensions) {
        var normalizedDimensions;
        if (this.preventChangeRecursion) {
            return;
        }
        this.preventChangeRecursion = !0;
        if (!this.scalable.isFixedRatio()) {
            dimensions = ve.extendObject({}, this.getCurrentDimensions(), dimensions);
        }
        normalizedDimensions = ve.dm.Scalable.static.getDimensionsFromValue(dimensions, this.scalable.getRatio());
        if (ve.dm.Scalable.static.isDimensionsObjectValid(normalizedDimensions) && !this.scalable.isDefault()) {
            this.currentDimensions = normalizedDimensions;
            this.dimensions.setWidth(this.currentDimensions.width);
            this.dimensions.setHeight(this.currentDimensions.height);
            this.scalable.setCurrentDimensions(this.currentDimensions);
            this.validateDimensions();
            this.emit('change', this.currentDimensions);
        }
        this.preventChangeRecursion = !1;
    }
    ;
    ve.ui.MediaSizeWidget.prototype.validateDimensions = function() {
        var isValid = this.isValid();
        if (this.valid !== isValid) {
            this.valid = isValid;
            this.errorLabel.toggle(!isValid);
            this.dimensions.setValidityFlag();
            this.emit('valid', this.valid);
        }
        return isValid;
    }
    ;
    ve.ui.MediaSizeWidget.prototype.updateDefaultDimensions = function() {
        var defaultDimensions = this.scalable.getDefaultDimensions();
        if (!ve.isEmptyObject(defaultDimensions)) {
            this.dimensions.setDefaults(defaultDimensions);
        } else {
            this.dimensions.removeDefaults();
        }
        this.updateDisabled();
        this.validateDimensions();
    }
    ;
    ve.ui.MediaSizeWidget.prototype.isCustomEmpty = function() {
        return this.dimensions.isEmpty();
    }
    ;
    ve.ui.MediaSizeWidget.prototype.isEmpty = function() {
        return this.isCustomEmpty();
    }
    ;
    ve.ui.MediaSizeWidget.prototype.isValid = function() {
        var itemType = this.sizeTypeSelect.findSelectedItem() ? this.sizeTypeSelect.findSelectedItem().getData() : 'custom';
        if (itemType === 'custom') {
            if (this.dimensions.getDefaults() && this.dimensions.isEmpty()) {
                return true;
            } else if (!isNaN(+this.dimensions.getWidth()) && !isNaN(+this.dimensions.getHeight())) {
                return this.scalable.isCurrentDimensionsValid();
            } else {
                return false;
            }
        } else {
            return true;
        }
    }
    ;
    ve.ui.NoFocusButtonWidget = function NoFocusButtonWidget() {
        ve.ui.NoFocusButtonWidget.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.NoFocusButtonWidget, OO.ui.ButtonWidget);
    ve.ui.NoFocusButtonWidget.static.cancelButtonMouseDownEvents = !0;
    ve.ui.WhitespacePreservingTextInputWidget = function VeUiWhitespacePreservingTextInputWidget(config) {
        config = config || {};
        ve.ui.WhitespacePreservingTextInputWidget.super.call(this, config);
        this.limit = config.limit;
        this.setWhitespace(['', '']);
        this.setValueAndWhitespace(config.valueAndWhitespace || '');
        this.$element.addClass('ve-ui-whitespacePreservingTextInputWidget');
    }
    ;
    OO.inheritClass(ve.ui.WhitespacePreservingTextInputWidget, OO.ui.MultilineTextInputWidget);
    ve.ui.WhitespacePreservingTextInputWidget.prototype.setValueAndWhitespace = function(value) {
        var leftValue, rightValue;
        leftValue = this.limit ? value.slice(0, this.limit) : value;
        this.whitespace[0] = leftValue.match(/^\s*/)[0];
        value = value.slice(this.whitespace[0].length);
        rightValue = this.limit ? value.slice(-this.limit) : value;
        this.whitespace[1] = rightValue.match(/\s*$/)[0];
        value = value.slice(0, value.length - this.whitespace[1].length);
        this.setValue(value);
    }
    ;
    ve.ui.WhitespacePreservingTextInputWidget.prototype.setWhitespace = function(whitespace) {
        this.whitespace = whitespace;
    }
    ;
    ve.ui.WhitespacePreservingTextInputWidget.prototype.getValueAndWhitespace = function() {
        if (!this.whitespace) {
            return this.value;
        }
        return this.whitespace[0] + this.value + this.whitespace[1];
    }
    ;
    ve.ui.AnnotationTool = function VeUiAnnotationTool() {
        ve.ui.AnnotationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.AnnotationTool, ve.ui.Tool);
    ve.ui.AnnotationTool.static.annotation = {
        name: ''
    };
    ve.ui.AnnotationTool.static.deactivateOnSelect = !1;
    ve.ui.AnnotationTool.prototype.onUpdateState = function(fragment) {
        ve.ui.AnnotationTool.super.prototype.onUpdateState.apply(this, arguments);
        this.setActive(fragment && fragment.getAnnotations().hasAnnotationWithName(this.constructor.static.annotation.name));
    }
    ;
    ve.ui.BoldAnnotationTool = function VeUiBoldAnnotationTool() {
        ve.ui.BoldAnnotationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.BoldAnnotationTool, ve.ui.AnnotationTool);
    ve.ui.BoldAnnotationTool.static.name = 'bold';
    ve.ui.BoldAnnotationTool.static.group = 'textStyle';
    ve.ui.BoldAnnotationTool.static.icon = 'bold';
    ve.ui.BoldAnnotationTool.static.title = OO.ui.deferMsg('visualeditor-annotationbutton-bold-tooltip');
    ve.ui.BoldAnnotationTool.static.annotation = {
        name: 'textStyle/bold'
    };
    ve.ui.BoldAnnotationTool.static.commandName = 'bold';
    ve.ui.toolFactory.register(ve.ui.BoldAnnotationTool);
    ve.ui.ItalicAnnotationTool = function VeUiItalicAnnotationTool() {
        ve.ui.ItalicAnnotationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.ItalicAnnotationTool, ve.ui.AnnotationTool);
    ve.ui.ItalicAnnotationTool.static.name = 'italic';
    ve.ui.ItalicAnnotationTool.static.group = 'textStyle';
    ve.ui.ItalicAnnotationTool.static.icon = 'italic';
    ve.ui.ItalicAnnotationTool.static.title = OO.ui.deferMsg('visualeditor-annotationbutton-italic-tooltip');
    ve.ui.ItalicAnnotationTool.static.annotation = {
        name: 'textStyle/italic'
    };
    ve.ui.ItalicAnnotationTool.static.commandName = 'italic';
    ve.ui.toolFactory.register(ve.ui.ItalicAnnotationTool);
    ve.ui.CodeAnnotationTool = function VeUiCodeAnnotationTool() {
        ve.ui.CodeAnnotationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.CodeAnnotationTool, ve.ui.AnnotationTool);
    ve.ui.CodeAnnotationTool.static.name = 'code';
    ve.ui.CodeAnnotationTool.static.group = 'textStyle';
    ve.ui.CodeAnnotationTool.static.icon = 'code';
    ve.ui.CodeAnnotationTool.static.title = OO.ui.deferMsg('visualeditor-annotationbutton-code-tooltip');
    ve.ui.CodeAnnotationTool.static.annotation = {
        name: 'textStyle/code'
    };
    ve.ui.CodeAnnotationTool.static.commandName = 'code';
    ve.ui.toolFactory.register(ve.ui.CodeAnnotationTool);
    ve.ui.StrikethroughAnnotationTool = function VeUiStrikethroughAnnotationTool() {
        ve.ui.StrikethroughAnnotationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.StrikethroughAnnotationTool, ve.ui.AnnotationTool);
    ve.ui.StrikethroughAnnotationTool.static.name = 'strikethrough';
    ve.ui.StrikethroughAnnotationTool.static.group = 'textStyle';
    ve.ui.StrikethroughAnnotationTool.static.icon = 'strikethrough';
    ve.ui.StrikethroughAnnotationTool.static.title = OO.ui.deferMsg('visualeditor-annotationbutton-strikethrough-tooltip');
    ve.ui.StrikethroughAnnotationTool.static.annotation = {
        name: 'textStyle/strikethrough'
    };
    ve.ui.StrikethroughAnnotationTool.static.commandName = 'strikethrough';
    ve.ui.toolFactory.register(ve.ui.StrikethroughAnnotationTool);
    ve.ui.UnderlineAnnotationTool = function VeUiUnderlineAnnotationTool() {
        ve.ui.UnderlineAnnotationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.UnderlineAnnotationTool, ve.ui.AnnotationTool);
    ve.ui.UnderlineAnnotationTool.static.name = 'underline';
    ve.ui.UnderlineAnnotationTool.static.group = 'textStyle';
    ve.ui.UnderlineAnnotationTool.static.icon = 'underline';
    ve.ui.UnderlineAnnotationTool.static.title = OO.ui.deferMsg('visualeditor-annotationbutton-underline-tooltip');
    ve.ui.UnderlineAnnotationTool.static.annotation = {
        name: 'textStyle/underline'
    };
    ve.ui.UnderlineAnnotationTool.static.commandName = 'underline';
    ve.ui.toolFactory.register(ve.ui.UnderlineAnnotationTool);
    ve.ui.SuperscriptAnnotationTool = function VeUiSuperscriptAnnotationTool() {
        ve.ui.SuperscriptAnnotationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.SuperscriptAnnotationTool, ve.ui.AnnotationTool);
    ve.ui.SuperscriptAnnotationTool.static.name = 'superscript';
    ve.ui.SuperscriptAnnotationTool.static.group = 'textStyle';
    ve.ui.SuperscriptAnnotationTool.static.icon = 'superscript';
    ve.ui.SuperscriptAnnotationTool.static.title = OO.ui.deferMsg('visualeditor-annotationbutton-superscript-tooltip');
    ve.ui.SuperscriptAnnotationTool.static.annotation = {
        name: 'textStyle/superscript'
    };
    ve.ui.SuperscriptAnnotationTool.static.commandName = 'superscript';
    ve.ui.toolFactory.register(ve.ui.SuperscriptAnnotationTool);
    ve.ui.SubscriptAnnotationTool = function VeUiSubscriptAnnotationTool() {
        ve.ui.SubscriptAnnotationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.SubscriptAnnotationTool, ve.ui.AnnotationTool);
    ve.ui.SubscriptAnnotationTool.static.name = 'subscript';
    ve.ui.SubscriptAnnotationTool.static.group = 'textStyle';
    ve.ui.SubscriptAnnotationTool.static.icon = 'subscript';
    ve.ui.SubscriptAnnotationTool.static.title = OO.ui.deferMsg('visualeditor-annotationbutton-subscript-tooltip');
    ve.ui.SubscriptAnnotationTool.static.annotation = {
        name: 'textStyle/subscript'
    };
    ve.ui.SubscriptAnnotationTool.static.commandName = 'subscript';
    ve.ui.toolFactory.register(ve.ui.SubscriptAnnotationTool);
    ve.ui.BigAnnotationTool = function VeUiBigAnnotationTool() {
        ve.ui.BigAnnotationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.BigAnnotationTool, ve.ui.AnnotationTool);
    ve.ui.BigAnnotationTool.static.name = 'big';
    ve.ui.BigAnnotationTool.static.group = 'textStyle';
    ve.ui.BigAnnotationTool.static.icon = 'bigger';
    ve.ui.BigAnnotationTool.static.title = OO.ui.deferMsg('visualeditor-annotationbutton-big-tooltip');
    ve.ui.BigAnnotationTool.static.annotation = {
        name: 'textStyle/big'
    };
    ve.ui.BigAnnotationTool.static.commandName = 'big';
    ve.ui.toolFactory.register(ve.ui.BigAnnotationTool);
    ve.ui.SmallAnnotationTool = function VeUiSmallAnnotationTool() {
        ve.ui.SmallAnnotationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.SmallAnnotationTool, ve.ui.AnnotationTool);
    ve.ui.SmallAnnotationTool.static.name = 'small';
    ve.ui.SmallAnnotationTool.static.group = 'textStyle';
    ve.ui.SmallAnnotationTool.static.icon = 'smaller';
    ve.ui.SmallAnnotationTool.static.title = OO.ui.deferMsg('visualeditor-annotationbutton-small-tooltip');
    ve.ui.SmallAnnotationTool.static.annotation = {
        name: 'textStyle/small'
    };
    ve.ui.SmallAnnotationTool.static.commandName = 'small';
    ve.ui.toolFactory.register(ve.ui.SmallAnnotationTool);
    ve.ui.MoreTextStyleTool = function VeUiMoreTextStyleTool() {
        ve.ui.MoreTextStyleTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.MoreTextStyleTool, OO.ui.ToolGroupTool);
    ve.ui.MoreTextStyleTool.static.autoAddToCatchall = !1;
    ve.ui.MoreTextStyleTool.static.name = 'moreTextStyle';
    ve.ui.MoreTextStyleTool.static.group = 'textStyleExpansion';
    ve.ui.MoreTextStyleTool.static.title = OO.ui.deferMsg('visualeditor-toolbar-style-tooltip');
    ve.ui.MoreTextStyleTool.static.groupConfig = {
        header: OO.ui.deferMsg('visualeditor-toolbar-text-style'),
        icon: 'textStyle',
        indicator: 'down',
        title: OO.ui.deferMsg('visualeditor-toolbar-style-tooltip'),
        label: OO.ui.deferMsg('visualeditor-toolbar-style-tooltip'),
        invisibleLabel: !0,
        include: [{
            group: 'textStyle'
        }, 'language', 'clear'],
        demote: ['strikethrough', 'code', 'underline', 'language', 'big', 'small', 'clear']
    };
    ve.ui.toolFactory.register(ve.ui.MoreTextStyleTool);
    ve.ui.ChangeDirectionalityTool = function VeUiChangeDirectionalityTool() {
        ve.ui.ChangeDirectionalityTool.super.apply(this, arguments);
        this.modelDir = null;
        this.setDisabled(false);
    }
    ;
    OO.inheritClass(ve.ui.ChangeDirectionalityTool, ve.ui.Tool);
    ve.ui.ChangeDirectionalityTool.static.name = 'changeDirectionality';
    ve.ui.ChangeDirectionalityTool.static.icon = 'textDirRTL';
    ve.ui.ChangeDirectionalityTool.static.title = OO.ui.deferMsg('visualeditor-changedir-rtl');
    ve.ui.ChangeDirectionalityTool.static.autoAddToCatchall = !1;
    ve.ui.ChangeDirectionalityTool.static.commandName = 'changeDirectionality';
    ve.ui.ChangeDirectionalityTool.static.deactivateOnSelect = !1;
    ve.ui.ChangeDirectionalityTool.prototype.onUpdateState = function(fragment) {
        var viewDir = this.toolbar.getSurface().getView().getDocument().getDir()
          , modelDir = fragment.getDocument().getDir();
        ve.ui.ChangeDirectionalityTool.super.prototype.onUpdateState.apply(this, arguments);
        if (modelDir !== this.modelDir) {
            this.setIcon('textDir' + (modelDir === 'ltr' ? 'RTL' : 'LTR'));
            this.setTitle(ve.msg('visualeditor-changedir-tool-' + (modelDir === 'ltr' ? 'rtl' : 'ltr')));
            this.modelDir = modelDir;
        }
        this.setActive(viewDir !== modelDir);
    }
    ;
    ve.ui.toolFactory.register(ve.ui.ChangeDirectionalityTool);
    ve.ui.ClearAnnotationTool = function VeUiClearAnnotationTool() {
        ve.ui.ClearAnnotationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.ClearAnnotationTool, ve.ui.Tool);
    ve.ui.ClearAnnotationTool.static.name = 'clear';
    ve.ui.ClearAnnotationTool.static.group = 'utility';
    ve.ui.ClearAnnotationTool.static.icon = 'cancel';
    ve.ui.ClearAnnotationTool.static.title = OO.ui.deferMsg('visualeditor-clearbutton-tooltip');
    ve.ui.ClearAnnotationTool.static.commandName = 'clear';
    ve.ui.toolFactory.register(ve.ui.ClearAnnotationTool);
    ve.ui.WindowTool = function VeUiWindowTool() {
        ve.ui.WindowTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.WindowTool, ve.ui.Tool);
    ve.ui.WindowTool.static.associatedWindows = null;
    ve.ui.WindowTool.prototype.onUpdateState = function(fragment, contextDirection, activeDialogs) {
        var command, myWindowNames = [];
        ve.ui.WindowTool.super.prototype.onUpdateState.apply(this, arguments);
        if (this.constructor.static.associatedWindows !== null) {
            myWindowNames = this.constructor.static.associatedWindows;
        } else {
            command = this.getCommand();
            if (command && command.getAction() === 'window') {
                myWindowNames = [command.getArgs()[0]];
            }
        }
        this.setActive($(activeDialogs).filter(myWindowNames).length !== 0);
    }
    ;
    ve.ui.DialogTool = ve.ui.WindowTool;
    ve.ui.CommandHelpDialogTool = function VeUiCommandHelpDialogTool() {
        ve.ui.CommandHelpDialogTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.CommandHelpDialogTool, ve.ui.WindowTool);
    ve.ui.CommandHelpDialogTool.static.name = 'commandHelp';
    ve.ui.CommandHelpDialogTool.static.group = 'dialog';
    ve.ui.CommandHelpDialogTool.static.icon = 'help';
    ve.ui.CommandHelpDialogTool.static.title = OO.ui.deferMsg('visualeditor-dialog-command-help-title');
    ve.ui.CommandHelpDialogTool.static.autoAddToCatchall = !1;
    ve.ui.CommandHelpDialogTool.static.autoAddToGroup = !1;
    ve.ui.CommandHelpDialogTool.static.commandName = 'commandHelp';
    ve.ui.toolFactory.register(ve.ui.CommandHelpDialogTool);
    ve.ui.FragmentWindowTool = function VeUiFragmentWindowTool() {
        ve.ui.FragmentWindowTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.FragmentWindowTool, ve.ui.WindowTool);
    ve.ui.FragmentWindowTool.static.modelClasses = [];
    ve.ui.FragmentWindowTool.static.deactivateOnSelect = !1;
    ve.ui.FragmentWindowTool.static.isCompatibleWith = function(model) {
        return ve.isInstanceOfAny(model, this.modelClasses);
    }
    ;
    ve.ui.FragmentWindowTool.prototype.onUpdateState = function(fragment) {
        var i, len, models;
        this.setActive(false);
        ve.ui.FragmentWindowTool.super.super.prototype.onUpdateState.apply(this, arguments);
        models = this.getSelectedModels(fragment);
        for (i = 0,
        len = models.length; i < len; i++) {
            if (this.constructor.static.isCompatibleWith(models[i])) {
                this.setActive(true);
                break;
            }
        }
    }
    ;
    ve.ui.FragmentWindowTool.prototype.getSelectedModels = function(fragment) {
        return fragment ? fragment.getSelectedModels() : [];
    }
    ;
    ve.ui.FragmentInspectorTool = function VeUiFragmentInspectorTool() {
        ve.ui.FragmentInspectorTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.FragmentInspectorTool, ve.ui.FragmentWindowTool);
    ve.ui.FragmentInspectorTool.static.makesEmbeddableContextItem = !1;
    ve.ui.InspectorTool = ve.ui.FragmentInspectorTool;
    ve.ui.LinkInspectorTool = function VeUiLinkInspectorTool() {
        ve.ui.LinkInspectorTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.LinkInspectorTool, ve.ui.FragmentInspectorTool);
    ve.ui.LinkInspectorTool.static.name = 'link';
    ve.ui.LinkInspectorTool.static.group = 'meta';
    ve.ui.LinkInspectorTool.static.icon = 'link';
    ve.ui.LinkInspectorTool.static.title = OO.ui.deferMsg('visualeditor-annotationbutton-link-tooltip');
    ve.ui.LinkInspectorTool.static.modelClasses = [ve.dm.LinkAnnotation];
    ve.ui.LinkInspectorTool.static.commandName = 'link';
    ve.ui.LinkInspectorTool.prototype.getSelectedModels = function(fragment) {
        var surfaceView, selection = fragment && fragment.getSelection();
        if (selection instanceof ve.dm.LinearSelection) {
            surfaceView = this.toolbar.getSurface().getView();
            if (selection.equals(surfaceView.getModel().getSelection())) {
                return surfaceView.getSelectedModels();
            }
        }
        return ve.ui.LinkInspectorTool.super.prototype.getSelectedModels.apply(this, arguments);
    }
    ;
    ve.ui.toolFactory.register(ve.ui.LinkInspectorTool);
    ve.ui.CommentInspectorTool = function VeUiCommentInspectorTool() {
        ve.ui.CommentInspectorTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.CommentInspectorTool, ve.ui.FragmentInspectorTool);
    ve.ui.CommentInspectorTool.static.name = 'comment';
    ve.ui.CommentInspectorTool.static.group = 'meta';
    ve.ui.CommentInspectorTool.static.icon = 'notice';
    ve.ui.CommentInspectorTool.static.title = OO.ui.deferMsg('visualeditor-commentinspector-tooltip');
    ve.ui.CommentInspectorTool.static.modelClasses = [ve.dm.CommentNode];
    ve.ui.CommentInspectorTool.static.commandName = 'comment';
    ve.ui.CommentInspectorTool.static.deactivateOnSelect = !0;
    ve.ui.toolFactory.register(ve.ui.CommentInspectorTool);
    ve.ui.ToolbarDialogTool = function VeUiToolbarDialogTool() {
        ve.ui.ToolbarDialogTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.ToolbarDialogTool, ve.ui.WindowTool);
    ve.ui.ToolbarDialogTool.static.deactivateOnSelect = !1;
    ve.ui.FindAndReplaceTool = function VeUiFindAndReplaceTool() {
        ve.ui.FindAndReplaceTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.FindAndReplaceTool, ve.ui.ToolbarDialogTool);
    ve.ui.FindAndReplaceTool.static.name = 'findAndReplace';
    ve.ui.FindAndReplaceTool.static.group = 'dialog';
    ve.ui.FindAndReplaceTool.static.icon = 'articleSearch';
    ve.ui.FindAndReplaceTool.static.title = OO.ui.deferMsg('visualeditor-find-and-replace-title');
    ve.ui.FindAndReplaceTool.static.autoAddToCatchall = !1;
    ve.ui.FindAndReplaceTool.static.autoAddToGroup = !1;
    ve.ui.FindAndReplaceTool.static.commandName = 'findAndReplace';
    ve.ui.toolFactory.register(ve.ui.FindAndReplaceTool);
    ve.ui.SpecialCharacterDialogTool = function VeUiSpecialCharacterDialogTool() {
        ve.ui.SpecialCharacterDialogTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.SpecialCharacterDialogTool, ve.ui.ToolbarDialogTool);
    ve.ui.SpecialCharacterDialogTool.static.name = 'specialCharacter';
    ve.ui.SpecialCharacterDialogTool.static.group = 'dialog';
    ve.ui.SpecialCharacterDialogTool.static.icon = 'specialCharacter';
    ve.ui.SpecialCharacterDialogTool.static.title = OO.ui.deferMsg('visualeditor-specialcharacter-button-tooltip');
    ve.ui.SpecialCharacterDialogTool.static.autoAddToCatchall = !1;
    ve.ui.SpecialCharacterDialogTool.static.autoAddToGroup = !1;
    ve.ui.SpecialCharacterDialogTool.static.commandName = 'specialCharacter';
    ve.ui.toolFactory.register(ve.ui.SpecialCharacterDialogTool);
    ve.ui.FormatTool = function VeUiFormatTool() {
        ve.ui.FormatTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.FormatTool, ve.ui.Tool);
    ve.ui.FormatTool.static.deactivateOnSelect = !1;
    ve.ui.FormatTool.static.format = null;
    ve.ui.FormatTool.prototype.onUpdateState = function(fragment) {
        var isMatching, format = this.constructor.static.format;
        ve.ui.FormatTool.super.prototype.onUpdateState.apply(this, arguments);
        if (this.isDisabled()) {
            this.toggle(false);
            this.setActive(false);
            return;
        }
        this.toggle(true);
        isMatching = fragment.hasMatchingAncestor(format.type, format.attributes);
        this.setActive(isMatching);
    }
    ;
    ve.ui.ParagraphFormatTool = function VeUiParagraphFormatTool() {
        ve.ui.ParagraphFormatTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.ParagraphFormatTool, ve.ui.FormatTool);
    ve.ui.ParagraphFormatTool.static.name = 'paragraph';
    ve.ui.ParagraphFormatTool.static.group = 'format';
    ve.ui.ParagraphFormatTool.static.title = OO.ui.deferMsg('visualeditor-formatdropdown-format-paragraph');
    ve.ui.ParagraphFormatTool.static.format = {
        type: 'paragraph'
    };
    ve.ui.ParagraphFormatTool.static.commandName = 'paragraph';
    ve.ui.toolFactory.register(ve.ui.ParagraphFormatTool);
    ve.ui.Heading1FormatTool = function VeUiHeading1FormatTool() {
        ve.ui.Heading1FormatTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.Heading1FormatTool, ve.ui.FormatTool);
    ve.ui.Heading1FormatTool.static.name = 'heading1';
    ve.ui.Heading1FormatTool.static.group = 'format';
    ve.ui.Heading1FormatTool.static.title = OO.ui.deferMsg('visualeditor-formatdropdown-format-heading1');
    ve.ui.Heading1FormatTool.static.format = {
        type: 'heading',
        attributes: {
            level: 1
        }
    };
    ve.ui.Heading1FormatTool.static.commandName = 'heading1';
    ve.ui.toolFactory.register(ve.ui.Heading1FormatTool);
    ve.ui.Heading2FormatTool = function VeUiHeading2FormatTool() {
        ve.ui.Heading2FormatTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.Heading2FormatTool, ve.ui.FormatTool);
    ve.ui.Heading2FormatTool.static.name = 'heading2';
    ve.ui.Heading2FormatTool.static.group = 'format';
    ve.ui.Heading2FormatTool.static.title = OO.ui.deferMsg('visualeditor-formatdropdown-format-heading2');
    ve.ui.Heading2FormatTool.static.format = {
        type: 'heading',
        attributes: {
            level: 2
        }
    };
    ve.ui.Heading2FormatTool.static.commandName = 'heading2';
    ve.ui.toolFactory.register(ve.ui.Heading2FormatTool);
    ve.ui.Heading3FormatTool = function VeUiHeading3FormatTool() {
        ve.ui.Heading3FormatTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.Heading3FormatTool, ve.ui.FormatTool);
    ve.ui.Heading3FormatTool.static.name = 'heading3';
    ve.ui.Heading3FormatTool.static.group = 'format';
    ve.ui.Heading3FormatTool.static.title = OO.ui.deferMsg('visualeditor-formatdropdown-format-heading3');
    ve.ui.Heading3FormatTool.static.format = {
        type: 'heading',
        attributes: {
            level: 3
        }
    };
    ve.ui.Heading3FormatTool.static.commandName = 'heading3';
    ve.ui.toolFactory.register(ve.ui.Heading3FormatTool);
    ve.ui.Heading4FormatTool = function VeUiHeading4FormatTool() {
        ve.ui.Heading4FormatTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.Heading4FormatTool, ve.ui.FormatTool);
    ve.ui.Heading4FormatTool.static.name = 'heading4';
    ve.ui.Heading4FormatTool.static.group = 'format';
    ve.ui.Heading4FormatTool.static.title = OO.ui.deferMsg('visualeditor-formatdropdown-format-heading4');
    ve.ui.Heading4FormatTool.static.format = {
        type: 'heading',
        attributes: {
            level: 4
        }
    };
    ve.ui.Heading4FormatTool.static.commandName = 'heading4';
    ve.ui.toolFactory.register(ve.ui.Heading4FormatTool);
    ve.ui.Heading5FormatTool = function VeUiHeading5FormatTool() {
        ve.ui.Heading5FormatTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.Heading5FormatTool, ve.ui.FormatTool);
    ve.ui.Heading5FormatTool.static.name = 'heading5';
    ve.ui.Heading5FormatTool.static.group = 'format';
    ve.ui.Heading5FormatTool.static.title = OO.ui.deferMsg('visualeditor-formatdropdown-format-heading5');
    ve.ui.Heading5FormatTool.static.format = {
        type: 'heading',
        attributes: {
            level: 5
        }
    };
    ve.ui.Heading5FormatTool.static.commandName = 'heading5';
    ve.ui.toolFactory.register(ve.ui.Heading5FormatTool);
    ve.ui.Heading6FormatTool = function VeUiHeading6FormatTool() {
        ve.ui.Heading6FormatTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.Heading6FormatTool, ve.ui.FormatTool);
    ve.ui.Heading6FormatTool.static.name = 'heading6';
    ve.ui.Heading6FormatTool.static.group = 'format';
    ve.ui.Heading6FormatTool.static.title = OO.ui.deferMsg('visualeditor-formatdropdown-format-heading6');
    ve.ui.Heading6FormatTool.static.format = {
        type: 'heading',
        attributes: {
            level: 6
        }
    };
    ve.ui.Heading6FormatTool.static.commandName = 'heading6';
    ve.ui.toolFactory.register(ve.ui.Heading6FormatTool);
    ve.ui.PreformattedFormatTool = function VeUiPreformattedFormatTool() {
        ve.ui.PreformattedFormatTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.PreformattedFormatTool, ve.ui.FormatTool);
    ve.ui.PreformattedFormatTool.static.name = 'preformatted';
    ve.ui.PreformattedFormatTool.static.group = 'format';
    ve.ui.PreformattedFormatTool.static.title = OO.ui.deferMsg('visualeditor-formatdropdown-format-preformatted');
    ve.ui.PreformattedFormatTool.static.format = {
        type: 'preformatted'
    };
    ve.ui.PreformattedFormatTool.static.commandName = 'preformatted';
    ve.ui.toolFactory.register(ve.ui.PreformattedFormatTool);
    ve.ui.BlockquoteFormatTool = function VeUiBlockquoteFormatTool() {
        ve.ui.BlockquoteFormatTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.BlockquoteFormatTool, ve.ui.FormatTool);
    ve.ui.BlockquoteFormatTool.static.name = 'blockquote';
    ve.ui.BlockquoteFormatTool.static.group = 'format';
    ve.ui.BlockquoteFormatTool.static.title = OO.ui.deferMsg('visualeditor-formatdropdown-format-blockquote');
    ve.ui.BlockquoteFormatTool.static.format = {
        type: 'blockquote'
    };
    ve.ui.BlockquoteFormatTool.static.commandName = 'blockquote';
    ve.ui.toolFactory.register(ve.ui.BlockquoteFormatTool);
    ve.ui.TableCellHeaderFormatTool = function VeUiTableCellHeaderFormatTool() {
        ve.ui.TableCellHeaderFormatTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.TableCellHeaderFormatTool, ve.ui.FormatTool);
    ve.ui.TableCellHeaderFormatTool.static.name = 'tableCellHeader';
    ve.ui.TableCellHeaderFormatTool.static.group = 'format';
    ve.ui.TableCellHeaderFormatTool.static.title = OO.ui.deferMsg('visualeditor-table-format-header');
    ve.ui.TableCellHeaderFormatTool.static.format = {
        type: 'tableCell',
        attributes: {
            style: 'header'
        }
    };
    ve.ui.TableCellHeaderFormatTool.static.commandName = 'tableCellHeader';
    ve.ui.toolFactory.register(ve.ui.TableCellHeaderFormatTool);
    ve.ui.TableCellDataFormatTool = function VeUiTableCellDataFormatTool() {
        ve.ui.TableCellDataFormatTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.TableCellDataFormatTool, ve.ui.FormatTool);
    ve.ui.TableCellDataFormatTool.static.name = 'tableCellData';
    ve.ui.TableCellDataFormatTool.static.group = 'format';
    ve.ui.TableCellDataFormatTool.static.title = OO.ui.deferMsg('visualeditor-table-format-data');
    ve.ui.TableCellDataFormatTool.static.format = {
        type: 'tableCell',
        attributes: {
            style: 'data'
        }
    };
    ve.ui.TableCellDataFormatTool.static.commandName = 'tableCellData';
    ve.ui.toolFactory.register(ve.ui.TableCellDataFormatTool);
    ve.ui.HistoryTool = function VeUiHistoryTool() {
        ve.ui.HistoryTool.super.apply(this, arguments);
        this.toolbar.connect(this, {
            surfaceChange: 'onSurfaceChange'
        });
    }
    ;
    OO.inheritClass(ve.ui.HistoryTool, ve.ui.Tool);
    ve.ui.HistoryTool.prototype.onSurfaceChange = function(oldSurface, newSurface) {
        if (oldSurface) {
            oldSurface.getModel().disconnect(this);
        }
        if (newSurface) {
            newSurface.getModel().connect(this, {
                history: 'onHistory'
            });
            this.onUpdateState(newSurface.getModel().getFragment());
        }
    }
    ;
    ve.ui.HistoryTool.prototype.onHistory = function() {
        this.onUpdateState(this.toolbar.getSurface().getModel().getFragment());
    }
    ;
    ve.ui.HistoryTool.prototype.destroy = function() {
        this.toolbar.getSurface().getModel().disconnect(this);
        ve.ui.HistoryTool.super.prototype.destroy.call(this);
    }
    ;
    ve.ui.UndoHistoryTool = function VeUiUndoHistoryTool() {
        ve.ui.UndoHistoryTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.UndoHistoryTool, ve.ui.HistoryTool);
    ve.ui.UndoHistoryTool.static.name = 'undo';
    ve.ui.UndoHistoryTool.static.group = 'history';
    ve.ui.UndoHistoryTool.static.icon = 'undo';
    ve.ui.UndoHistoryTool.static.title = OO.ui.deferMsg('visualeditor-historybutton-undo-tooltip');
    ve.ui.UndoHistoryTool.static.commandName = 'undo';
    ve.ui.toolFactory.register(ve.ui.UndoHistoryTool);
    ve.ui.RedoHistoryTool = function VeUiRedoHistoryTool() {
        ve.ui.RedoHistoryTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.RedoHistoryTool, ve.ui.HistoryTool);
    ve.ui.RedoHistoryTool.static.name = 'redo';
    ve.ui.RedoHistoryTool.static.group = 'history';
    ve.ui.RedoHistoryTool.static.icon = 'redo';
    ve.ui.RedoHistoryTool.static.title = OO.ui.deferMsg('visualeditor-historybutton-redo-tooltip');
    ve.ui.RedoHistoryTool.static.commandName = 'redo';
    ve.ui.toolFactory.register(ve.ui.RedoHistoryTool);
    ve.ui.IndentationTool = function VeUiIndentationTool() {
        ve.ui.IndentationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.IndentationTool, ve.ui.Tool);
    ve.ui.IncreaseIndentationTool = function VeUiIncreaseIndentationTool() {
        ve.ui.IncreaseIndentationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.IncreaseIndentationTool, ve.ui.IndentationTool);
    ve.ui.IncreaseIndentationTool.static.name = 'indent';
    ve.ui.IncreaseIndentationTool.static.group = 'structure';
    ve.ui.IncreaseIndentationTool.static.icon = 'indent';
    ve.ui.IncreaseIndentationTool.static.title = OO.ui.deferMsg('visualeditor-indentationbutton-indent-tooltip');
    ve.ui.IncreaseIndentationTool.static.commandName = 'indent';
    ve.ui.toolFactory.register(ve.ui.IncreaseIndentationTool);
    ve.ui.DecreaseIndentationTool = function VeUiDecreaseIndentationTool() {
        ve.ui.DecreaseIndentationTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.DecreaseIndentationTool, ve.ui.IndentationTool);
    ve.ui.DecreaseIndentationTool.static.name = 'outdent';
    ve.ui.DecreaseIndentationTool.static.group = 'structure';
    ve.ui.DecreaseIndentationTool.static.icon = 'outdent';
    ve.ui.DecreaseIndentationTool.static.title = OO.ui.deferMsg('visualeditor-indentationbutton-outdent-tooltip');
    ve.ui.DecreaseIndentationTool.static.commandName = 'outdent';
    ve.ui.toolFactory.register(ve.ui.DecreaseIndentationTool);
    ve.ui.ListTool = function VeUiListTool() {
        ve.ui.ListTool.super.apply(this, arguments);
        this.method = null;
    }
    ;
    OO.inheritClass(ve.ui.ListTool, ve.ui.Tool);
    ve.ui.ListTool.static.style = '';
    ve.ui.ListTool.static.deactivateOnSelect = !1;
    ve.ui.ListTool.prototype.onUpdateState = function(fragment) {
        var style, isMatching;
        ve.ui.ListTool.super.prototype.onUpdateState.apply(this, arguments);
        style = this.constructor.static.style;
        isMatching = fragment.hasMatchingAncestor('list', {
            style: style
        });
        this.setActive(isMatching);
    }
    ;
    ve.ui.BulletListTool = function VeUiBulletListTool() {
        ve.ui.BulletListTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.BulletListTool, ve.ui.ListTool);
    ve.ui.BulletListTool.static.name = 'bullet';
    ve.ui.BulletListTool.static.group = 'structure';
    ve.ui.BulletListTool.static.icon = 'listBullet';
    ve.ui.BulletListTool.static.title = OO.ui.deferMsg('visualeditor-listbutton-bullet-tooltip');
    ve.ui.BulletListTool.static.style = 'bullet';
    ve.ui.BulletListTool.static.commandName = 'bullet';
    ve.ui.toolFactory.register(ve.ui.BulletListTool);
    ve.ui.NumberListTool = function VeUiNumberListTool() {
        ve.ui.NumberListTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.NumberListTool, ve.ui.ListTool);
    ve.ui.NumberListTool.static.name = 'number';
    ve.ui.NumberListTool.static.group = 'structure';
    ve.ui.NumberListTool.static.icon = 'listNumbered';
    ve.ui.NumberListTool.static.title = OO.ui.deferMsg('visualeditor-listbutton-number-tooltip');
    ve.ui.NumberListTool.static.style = 'number';
    ve.ui.NumberListTool.static.commandName = 'number';
    ve.ui.toolFactory.register(ve.ui.NumberListTool);
    ve.ui.InsertTableTool = function VeUiInsertTableTool() {
        ve.ui.InsertTableTool.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.InsertTableTool, ve.ui.Tool);
    ve.ui.InsertTableTool.static.name = 'insertTable';
    ve.ui.InsertTableTool.static.group = 'insert';
    ve.ui.InsertTableTool.static.icon = 'table';
    ve.ui.InsertTableTool.static.title = OO.ui.deferMsg('visualeditor-table-insert-table');
    ve.ui.InsertTableTool.static.commandName = 'insertTable';
    ve.ui.toolFactory.register(ve.ui.InsertTableTool);
    ve.ui.FragmentInspector = function VeUiFragmentInspector(config) {
        config = config || {};
        ve.ui.FragmentInspector.super.call(this, config);
        ve.ui.FragmentWindow.call(this, config);
        this.initialFragment = null;
        this.previousSelection = null;
        this.padded = config.padded !== !1;
    }
    ;
    OO.inheritClass(ve.ui.FragmentInspector, OO.ui.ProcessDialog);
    OO.mixinClass(ve.ui.FragmentInspector, ve.ui.FragmentWindow);
    ve.ui.FragmentInspector.static.actions = [{
        label: OO.ui.deferMsg('visualeditor-dialog-action-cancel'),
        flags: ['safe', 'close'],
        modes: ['readonly', 'edit', 'insert']
    }, {
        action: 'done',
        label: OO.ui.deferMsg('visualeditor-dialog-action-done'),
        flags: ['progressive', 'primary'],
        modes: 'edit'
    }, {
        action: 'done',
        label: OO.ui.deferMsg('visualeditor-dialog-action-insert'),
        flags: ['progressive', 'primary'],
        modes: 'insert'
    }];
    ve.ui.FragmentInspector.static.size = 'large';
    ve.ui.FragmentInspector.prototype.onFormSubmit = function() {
        this.executeAction('done');
    }
    ;
    ve.ui.FragmentInspector.prototype.initialize = function() {
        ve.ui.FragmentInspector.super.prototype.initialize.call(this);
        this.container = new OO.ui.PanelLayout({
            classes: ['ve-ui-fragmentInspector-container'],
            scrollable: !0,
            expanded: !1,
            padded: this.padded
        });
        this.form = new OO.ui.FormLayout({
            classes: ['ve-ui-fragmentInspector-form']
        });
        this.form.connect(this, {
            submit: 'onFormSubmit'
        });
        this.$element.addClass('ve-ui-fragmentInspector');
        this.$content.addClass('ve-ui-fragmentInspector-content');
        this.container.$element.append(this.form.$element);
        this.$body.append(this.container.$element);
        this.tabIndexScope = new ve.ui.TabIndexScope({
            root: this.$content
        });
    }
    ;
    ve.ui.FragmentInspector.prototype.getActionProcess = function(action) {
        if (action === 'done') {
            return new OO.ui.Process(function() {
                this.close({
                    action: 'done'
                });
            }
            ,this);
        }
        return ve.ui.FragmentInspector.super.prototype.getActionProcess.call(this, action);
    }
    ;
    ve.ui.FragmentInspector.prototype.getActionWidgetConfig = function(config) {
        config = ve.ui.FragmentWindow.prototype.getActionWidgetConfig.call(this, config);
        return ve.ui.FragmentInspector.super.prototype.getActionWidgetConfig.call(this, config);
    }
    ;
    ve.ui.FragmentInspector.prototype.getSetupProcess = function(data) {
        var process = ve.ui.FragmentInspector.super.prototype.getSetupProcess.call(this, data);
        return ve.ui.FragmentWindow.prototype.getSetupProcess.call(this, data, process);
    }
    ;
    ve.ui.FragmentInspector.prototype.getTeardownProcess = function(data) {
        var process = ve.ui.FragmentInspector.super.prototype.getTeardownProcess.call(this, data);
        return ve.ui.FragmentWindow.prototype.getTeardownProcess.call(this, data, process);
    }
    ;
    ve.ui.FragmentInspector.prototype.getReadyProcess = function(data) {
        return ve.ui.FragmentInspector.super.prototype.getReadyProcess.call(this, data).first(0);
    }
    ;
    ve.ui.FragmentInspector.prototype.getBodyHeight = function() {
        return Math.ceil(this.container.$element[0].scrollHeight);
    }
    ;
    ve.ui.AnnotationInspector = function VeUiAnnotationInspector() {
        ve.ui.AnnotationInspector.super.apply(this, arguments);
        this.initialSelection = null;
        this.initialAnnotation = null;
        this.initialAnnotationIsCovering = !1;
    }
    ;
    OO.inheritClass(ve.ui.AnnotationInspector, ve.ui.FragmentInspector);
    ve.ui.AnnotationInspector.static.modelClasses = [];
    ve.ui.AnnotationInspector.prototype.shouldRemoveAnnotation = function() {
        return false;
    }
    ;
    ve.ui.AnnotationInspector.prototype.shouldInsertText = function() {
        return !this.isEditing();
    }
    ;
    ve.ui.AnnotationInspector.prototype.getInsertionData = function() {
        return this.getInsertionText().split('');
    }
    ;
    ve.ui.AnnotationInspector.prototype.getInsertionText = function() {
        if (this.sourceMode) {
            return OO.ui.resolveMsg(this.constructor.static.title);
        }
        return '';
    }
    ;
    ve.ui.AnnotationInspector.prototype.getAnnotation = null;
    ve.ui.AnnotationInspector.prototype.getAnnotationFromFragment = null;
    ve.ui.AnnotationInspector.prototype.getMatchingAnnotations = function(fragment, all) {
        var modelClasses = this.constructor.static.modelClasses;
        return fragment.getAnnotations(all).filter(function(annotation) {
            return ve.isInstanceOfAny(annotation, modelClasses);
        });
    }
    ;
    ve.ui.AnnotationInspector.prototype.isEditing = function() {
        return !this.initialSelection || !this.initialSelection.isCollapsed();
    }
    ;
    ve.ui.AnnotationInspector.prototype.getSetupProcess = function(data) {
        return ve.ui.AnnotationInspector.super.prototype.getSetupProcess.call(this, data).next(function() {
            var initialCoveringAnnotation, fragment = this.getFragment(), surfaceModel = fragment.getSurface(), annotation = this.getMatchingAnnotations(fragment, true).get(0);
            surfaceModel.pushStaging();
            if (!(this.initialFragment && this.initialFragment.getSelection()instanceof ve.dm.LinearSelection)) {
                return ve.createDeferred().reject().promise();
            }
            if (!annotation) {
                if (fragment.getSelection().isCollapsed() && fragment.getDocument().data.isContentOffset(fragment.getSelection().getRange().start)) {
                    if (!data.noExpand) {
                        fragment = fragment.expandLinearSelection('word');
                        if (!fragment.getSelection().isCollapsed()) {
                            annotation = this.getMatchingAnnotations(fragment, true).get(0);
                        }
                    }
                } else {
                    fragment = fragment.trimLinearSelection();
                }
                if (!fragment.getSelection().isCollapsed() && !annotation) {
                    this.isNew = !0;
                    annotation = this.getAnnotationFromFragment(fragment);
                    if (annotation) {
                        fragment.annotateContent('set', annotation);
                    }
                }
            }
            if (annotation && !data.noExpand) {
                fragment = fragment.expandLinearSelection('annotation', annotation);
            }
            fragment.select();
            this.initialSelection = fragment.getSelection();
            this.initialAnnotation = this.getMatchingAnnotations(fragment, true).get(0);
            initialCoveringAnnotation = this.getMatchingAnnotations(fragment).get(0);
            if (!this.initialAnnotation) {
                this.isNew = !0;
                this.initialAnnotation = this.getAnnotationFromFragment(fragment);
            } else if (initialCoveringAnnotation && initialCoveringAnnotation.compareTo(this.initialAnnotation)) {
                this.initialAnnotationIsCovering = !0;
            }
            this.fragment = fragment;
            this.actions.setMode(this.getMode());
            if (this.isNew && this.isReadOnly()) {
                return ve.createDeferred().reject().promise();
            }
        }, this);
    }
    ;
    ve.ui.AnnotationInspector.prototype.getTeardownProcess = function(data) {
        data = data || {};
        return ve.ui.AnnotationInspector.super.prototype.getTeardownProcess.call(this, data).first(function() {
            var i, len, annotations, insertion, selection, inspector = this, insertionAnnotation = !1, replace = !1, annotation = this.getAnnotation(), remove = data.action === 'done' && this.shouldRemoveAnnotation(), surfaceModel = this.fragment.getSurface(), surfaceView = this.manager.getSurface().getView(), fragment = surfaceModel.getFragment(this.initialSelection, false), isEditing = this.isEditing(), insertText = !remove && this.shouldInsertText();
            function clear() {
                annotations = inspector.getMatchingAnnotations(fragment, true).get();
                for (i = 0,
                len = annotations.length; i < len; i++) {
                    fragment.annotateContent('clear', annotations[i]);
                }
            }
            if (remove) {
                surfaceModel.popStaging();
                if (!isEditing) {
                    return;
                }
                clear();
            } else {
                if (data.action !== 'done') {
                    surfaceModel.popStaging();
                    if (this.initialFragment) {
                        this.initialFragment.select();
                    }
                    return;
                }
                if (annotation) {
                    if (!this.initialAnnotationIsCovering || !this.initialAnnotation || !this.initialAnnotation.compareTo(annotation)) {
                        replace = !0;
                    }
                }
                if (replace || insertText) {
                    surfaceModel.popStaging();
                    if (insertText) {
                        insertion = this.getInsertionData();
                        if (insertion.length) {
                            fragment.insertContent(insertion, true);
                            if (!isEditing) {
                                this.initialFragment = fragment.collapseToEnd();
                            } else {
                                this.initialFragment = fragment;
                            }
                        }
                    }
                    if (replace) {
                        clear();
                        if (fragment.getSelection().isCollapsed()) {
                            insertionAnnotation = !0;
                        } else {
                            fragment.annotateContent('set', annotation);
                        }
                    }
                } else {
                    surfaceModel.applyStaging();
                }
            }
            if (this.initialFragment && (!data.action || insertText)) {
                selection = this.initialFragment.getSelection();
            } else {
                selection = fragment.getSelection();
            }
            if (data.action) {
                if (!(insertion && insertion.length && ve.dm.LinearData.static.isElementData(insertion[0]))) {
                    surfaceModel.setSelection(selection);
                }
                surfaceView.updateActiveAnnotations(true);
                surfaceView.previousActiveAnnotations = surfaceView.activeAnnotations;
                if (OO.ui.isMobile()) {
                    surfaceView.deactivate(false, false, true);
                }
            }
            if (insertionAnnotation) {
                surfaceModel.addInsertionAnnotations(annotation);
            }
        }, this).next(function() {
            this.initialSelection = null;
            this.initialAnnotation = null;
            this.initialAnnotationIsCovering = !1;
            this.isNew = !1;
        }, this);
    }
    ;
    ve.ui.NodeInspector = function VeUiNodeInspector() {
        ve.ui.NodeInspector.super.apply(this, arguments);
        ve.ui.NodeWindow.call(this);
    }
    ;
    OO.inheritClass(ve.ui.NodeInspector, ve.ui.FragmentInspector);
    OO.mixinClass(ve.ui.NodeInspector, ve.ui.NodeWindow);
    ve.ui.NodeInspector.prototype.initialize = function(data) {
        ve.ui.NodeInspector.super.prototype.initialize.call(this, data);
        this.$content.addClass('ve-ui-nodeInspector');
    }
    ;
    ve.ui.NodeInspector.prototype.getSetupProcess = function(data) {
        var process = ve.ui.NodeInspector.super.prototype.getSetupProcess.call(this, data);
        return ve.ui.NodeWindow.prototype.getSetupProcess.call(this, data, process);
    }
    ;
    ve.ui.NodeInspector.prototype.getTeardownProcess = function(data) {
        var process = ve.ui.NodeInspector.super.prototype.getTeardownProcess.call(this, data);
        return ve.ui.NodeWindow.prototype.getTeardownProcess.call(this, data, process);
    }
    ;
    ve.ui.CommentInspector = function VeUiCommentInspector() {
        ve.ui.CommentInspector.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.CommentInspector, ve.ui.NodeInspector);
    ve.ui.CommentInspector.static.name = 'comment';
    ve.ui.CommentInspector.static.title = OO.ui.deferMsg('visualeditor-commentinspector-title');
    ve.ui.CommentInspector.static.modelClasses = [ve.dm.CommentNode];
    ve.ui.CommentInspector.static.size = 'large';
    ve.ui.CommentInspector.static.actions = [{
        action: 'remove',
        label: OO.ui.deferMsg('visualeditor-inspector-remove-tooltip'),
        flags: 'destructive',
        modes: 'edit'
    }].concat(ve.ui.CommentInspector.super.static.actions);
    ve.ui.CommentInspector.prototype.initialize = function() {
        ve.ui.CommentInspector.super.prototype.initialize.call(this);
        this.textWidget = new ve.ui.WhitespacePreservingTextInputWidget({
            autosize: !0
        });
        this.textWidget.connect(this, {
            resize: 'updateSize'
        });
        this.textWidget.$input.attr('aria-label', OO.ui.deferMsg('visualeditor-commentinspector-title'));
        this.$content.addClass('ve-ui-commentInspector-content');
        this.form.$element.append(this.textWidget.$element);
    }
    ;
    ve.ui.CommentInspector.prototype.getActionProcess = function(action) {
        if (action === 'remove' || action === 'insert') {
            return new OO.ui.Process(function() {
                this.close({
                    action: action
                });
            }
            ,this);
        }
        return ve.ui.CommentInspector.super.prototype.getActionProcess.call(this, action);
    }
    ;
    ve.ui.CommentInspector.prototype.getSetupProcess = function(data) {
        return ve.ui.CommentInspector.super.prototype.getSetupProcess.call(this, data).next(function() {
            this.getFragment().getSurface().pushStaging();
            this.commentNode = this.getSelectedNode();
            if (this.commentNode) {
                this.textWidget.setValueAndWhitespace(this.commentNode.getAttribute('text') || '');
            } else {
                this.textWidget.setWhitespace([' ', ' ']);
                this.getFragment().insertContent([{
                    type: 'comment',
                    attributes: {
                        text: ''
                    }
                }, {
                    type: '/comment'
                }]).select();
                this.commentNode = this.getSelectedNode();
            }
            this.textWidget.setReadOnly(this.isReadOnly());
        }, this);
    }
    ;
    ve.ui.CommentInspector.prototype.getReadyProcess = function(data) {
        return ve.ui.CommentInspector.super.prototype.getReadyProcess.call(this, data).next(function() {
            this.textWidget.focus();
        }, this);
    }
    ;
    ve.ui.CommentInspector.prototype.getTeardownProcess = function(data) {
        data = data || {};
        return ve.ui.CommentInspector.super.prototype.getTeardownProcess.call(this, data).first(function() {
            var surfaceModel = this.getFragment().getSurface();
            if (data.action === 'done' && this.textWidget.getValue() !== '') {
                this.getFragment().changeAttributes({
                    text: this.textWidget.getValueAndWhitespace()
                });
                surfaceModel.applyStaging();
            } else {
                surfaceModel.popStaging();
                if (data.action === 'remove' || data.action === 'done') {
                    this.getFragment().removeContent();
                }
            }
            this.textWidget.setValueAndWhitespace('');
        }, this);
    }
    ;
    ve.ui.windowFactory.register(ve.ui.CommentInspector);
    ve.ui.LinkAnnotationInspector = function VeUiLinkAnnotationInspector() {
        ve.ui.LinkAnnotationInspector.super.apply(this, arguments);
    }
    ;
    OO.inheritClass(ve.ui.LinkAnnotationInspector, ve.ui.AnnotationInspector);
    ve.ui.LinkAnnotationInspector.static.name = 'link';
    ve.ui.LinkAnnotationInspector.static.modelClasses = [ve.dm.LinkAnnotation];
    ve.ui.LinkAnnotationInspector.prototype.onAnnotationInputChange = function() {
        this.labelInput.$input.attr('placeholder', this.getInsertionText());
        this.updateActions();
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.updateActions = function() {
        var isValid = !1
          , inspector = this
          , annotation = this.annotationInput.getAnnotation();
        this.annotationInput.getTextInputWidget().getValidity().then(function() {
            isValid = !0;
        }).always(function() {
            isValid = isValid && !!annotation;
            inspector.actions.forEach({
                actions: ['done', 'insert']
            }, function(action) {
                action.setDisabled(!isValid);
            });
        });
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.shouldRemoveAnnotation = function() {
        return !this.annotationInput.getAnnotation();
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.getInsertionText = function() {
        return this.labelInput.getValue().trim() || this.annotationInput.getHref();
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.getAnnotation = function() {
        return this.annotationInput.getAnnotation();
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.getAnnotationFromFragment = function(fragment) {
        var text = fragment.getText();
        return text ? new ve.dm.LinkAnnotation({
            type: 'link',
            attributes: {
                href: text
            }
        }) : null;
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.initialize = function() {
        ve.ui.LinkAnnotationInspector.super.prototype.initialize.call(this);
        this.labelInput = this.createLabelInput();
        this.annotationInput = this.createAnnotationInput();
        this.labelField = new OO.ui.FieldLayout(this.labelInput,{
            align: 'top',
            label: ve.msg('visualeditor-linkcontext-label-label')
        });
        this.annotationField = new OO.ui.FieldLayout(this.annotationInput,{
            align: 'top',
            label: ve.msg('visualeditor-linkinspector-title')
        });
        this.annotationInput.connect(this, {
            change: 'onAnnotationInputChange'
        });
        this.annotationInput.getTextInputWidget().connect(this, {
            enter: 'onFormSubmit'
        });
        this.labelInput.connect(this, {
            enter: 'onFormSubmit'
        });
        this.labelInput.connect(this, {
            change: 'onAnnotationInputChange'
        });
        this.form.$element.append(this.labelField.$element, this.annotationField.$element);
        if (!OO.ui.isMobile()) {
            this.annotationField.setLabel(null);
            this.labelField.$element.detach();
        }
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.createLabelInput = function() {
        return new OO.ui.TextInputWidget();
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.createAnnotationInput = function() {
        return new ve.ui.LinkAnnotationWidget();
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.shouldInsertText = function() {
        if (ve.ui.LinkAnnotationInspector.super.prototype.shouldInsertText.call(this)) {
            return true;
        }
        if (OO.ui.isMobile()) {
            return !this.labelInput.isDisabled() && this.labelInput.getValue().trim() !== this.initialLabel.trim();
        }
        return false;
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.getSetupProcess = function(data) {
        return ve.ui.LinkAnnotationInspector.super.prototype.getSetupProcess.call(this, data).next(function() {
            var title = ve.msg(this.isReadOnly() ? 'visualeditor-linkinspector-title' : (this.isNew ? 'visualeditor-linkinspector-title-add' : 'visualeditor-linkinspector-title-edit'))
              , fragment = this.getFragment();
            this.title.setLabel(title).setTitle(title);
            this.initialLabel = fragment.getText();
            this.labelInput.setDisabled(!fragment.containsOnlyText());
            this.labelInput.setValue(this.initialLabel);
            this.annotationInput.setAnnotation(this.initialAnnotation);
            this.annotationInput.setReadOnly(this.isReadOnly());
            this.updateActions();
        }, this);
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.getReadyProcess = function(data) {
        return ve.ui.LinkAnnotationInspector.super.prototype.getReadyProcess.call(this, data).next(function() {
            if (!OO.ui.isMobile()) {
                this.annotationInput.getTextInputWidget().focus().select();
            }
            this.annotationInput.getTextInputWidget().setValidityFlag(true);
        }, this);
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.getHoldProcess = function(data) {
        return ve.ui.LinkAnnotationInspector.super.prototype.getHoldProcess.call(this, data).next(function() {
            this.annotationInput.getTextInputWidget().blur();
        }, this);
    }
    ;
    ve.ui.LinkAnnotationInspector.prototype.getTeardownProcess = function(data) {
        return ve.ui.LinkAnnotationInspector.super.prototype.getTeardownProcess.call(this, data).next(function() {
            this.annotationInput.setAnnotation(null);
            this.labelInput.$input.attr('placeholder', '');
            this.labelInput.setValue('');
        }, this);
    }
    ;
    ve.ui.windowFactory.register(ve.ui.LinkAnnotationInspector);
    ve.ui.SpecialCharacterPage = function VeUiSpecialCharacterPage(name, config) {
        var character, characterNode, characters, $characters, charactersNode, source = config.source;
        ve.ui.SpecialCharacterPage.super.apply(this, arguments);
        this.label = config.label;
        characters = config.characters;
        $characters = $('<div>').addClass('ve-ui-specialCharacterPage-characters');
        charactersNode = $characters[0];
        for (character in characters) {
            if (!source && characters[character].source) {
                continue;
            }
            if (character === 'attributes') {
                continue;
            }
            characterNode = document.createElement('div');
            characterNode.className = 've-ui-specialCharacterPage-character';
            if (characters[character].titleMsg) {
                characterNode.setAttribute('title', ve.msg(characters[character].titleMsg));
            }
            if (characters[character].source) {
                characterNode.classList.add('ve-ui-specialCharacterPage-character-source');
            }
            characterNode.textContent = character;
            $.data(characterNode, 'character', characters[character]);
            charactersNode.appendChild(characterNode);
        }
        if (characters.attributes) {
            $characters.attr('lang', characters.attributes.lang);
            $characters.attr('dir', characters.attributes.dir);
        }
        this.$element.addClass('ve-ui-specialCharacterPage').append($('<h3>').text(name), $characters);
    }
    ;
    OO.inheritClass(ve.ui.SpecialCharacterPage, OO.ui.PageLayout);
    ve.ui.SpecialCharacterPage.prototype.setupOutlineItem = function() {
        ve.ui.SpecialCharacterPage.super.prototype.setupOutlineItem.apply(this, arguments);
        this.outlineItem.setLabel(this.label);
    }
    ;
}, {
    "css": [".ve-ce-focusableNode{cursor:default} .ve-ce-focusableNode-highlight{background:#6da9f7;box-shadow:inset 0 0 0 1px #4c76ac;position:absolute; overflow:hidden}.ve-ce-focusableNode-highlight-error{background:#d33}.ve-ce-focusableNode-highlight-selectable{position:absolute;top:-1000px}.ve-ce-focusableNode-invisible{display:inline-block;vertical-align:middle; margin:-0.7em 0 -0.6em 0;width:auto}.ve-ce-focusableNode-invisibleIcon{opacity:0.5}.ve-ce-focusableNode-invisibleIcon \u003E .oo-ui-buttonElement-button{ cursor:default}.ve-ce-focusableNode-invisibleIcon.oo-ui-labelElement{width:auto}.ve-ce-focusableNode-invisibleIcon.oo-ui-labelElement .oo-ui-labelElement-label{max-width:15em;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:inline-block} .ve-ce-focusableNode-invisibleIcon.oo-ui-iconElement.oo-ui-buttonElement-frameless.oo-ui-iconElement:first-child{margin-left:0} .ve-ce-surface-highlights-focused .ve-ce-focusableNode-highlights{opacity:0.5}.ve-ce-surface-highlights-blurred .ve-ce-focusableNode-highlights{opacity:0.15}.ve-ce-surface-highlights-focused .ve-ce-focusableNode-highlights-deactivated{opacity:0.15}.ve-ce-focusableNode-highlights-deactivated .ve-ce-focusableNode-highlight{background:#000}  .ve-init-target-ie-or-edge .ve-ce-surface-highlights-focused .ve-ce-focusableNode-highlight{opacity:0.5}.ve-init-target-ie-or-edge .ve-ce-surface-highlights-blurred .ve-ce-focusableNode-highlight{opacity:0.15} .ve-ce-focusableNode .ve-ce-activeNode{cursor:text}.ve-ce-focusableNode .ve-ce-activeNode,.ve-ce-focusableNode .ve-ce-activeNode *{ -moz-user-select:-moz-text} .ve-ce-alienNode-highlights .ve-ce-focusableNode-highlight{background-color:#95d14f;background-image:-webkit-repeating-linear-gradient(-45deg,#fff 0,#fff 5px,#95d14f 5px,#95d14f 10px);background-image:-moz-repeating-linear-gradient(-45deg,#fff 0,#fff 5px,#95d14f 5px,#95d14f 10px);background-image:repeating-linear-gradient(-45deg,#fff 0,#fff 5px,#95d14f 5px,#95d14f 10px);background-size:14px 14px;cursor:not-allowed}.ve-ce-surface-highlights-focused .ve-ce-alienNode-highlights .ve-ce-focusableNode-highlight{background-image:-webkit-repeating-linear-gradient(-45deg,#6da9f7 0,#6da9f7 5px,#95d14f 5px,#95d14f 10px);background-image:-moz-repeating-linear-gradient(-45deg,#6da9f7 0,#6da9f7 5px,#95d14f 5px,#95d14f 10px);background-image:repeating-linear-gradient(-45deg,#6da9f7 0,#6da9f7 5px,#95d14f 5px,#95d14f 10px)}.ve-ce-surface-highlights-focused .ve-ce-alienNode-highlights.ve-ce-focusableNode-highlights-deactivated .ve-ce-focusableNode-highlight{background-image:-webkit-repeating-linear-gradient(-45deg,#000 0,#000 5px,#666 5px,#666 10px);background-image:-moz-repeating-linear-gradient(-45deg,#000 0,#000 5px,#666 5px,#666 10px);background-image:repeating-linear-gradient(-45deg,#000 0,#000 5px,#666 5px,#666 10px)}.ve-ce-surface-highlights-blurred .ve-ce-alienNode-highlights{opacity:0.5}  .ve-init-target-ie-or-edge .ve-ce-surface-highlights-blurred .ve-ce-alienNode-highlights .ve-ce-focusableNode-highlight{opacity:0.5}  .ve-ce-branchNode:focus{outline:0}.ve-ce-branchNode-blockSlug{opacity:0;cursor:pointer;-webkit-transition:opacity 200ms ease-out;-moz-transition:opacity 200ms ease-out;transition:opacity 200ms ease-out; overflow:hidden} .ve-ce-branchNode-blockSlug .oo-ui-labelElement-label::selection{background:transparent}  .ve-ce-branchNode-blockSlug .oo-ui-labelElement-label::-moz-selection{background:transparent}.ve-ce-branchNode-blockSlug,.ve-ce-branchNode-newSlug{margin:-0.3em 0 -0.1em 0;outline:1px dashed #c8ccd1; background-color:rgba(241,247,251,0.75)}.ve-ce-surface-readOnly .ve-ce-branchNode-blockSlug,.ve-ce-surface-dragging .ve-ce-branchNode-blockSlug{visibility:hidden}.ve-ce-branchNode-blockSlug:hover,.ve-ce-branchNode-blockSlug.ve-ce-branchNode-blockSlug-focused{opacity:1}.ve-ce-branchNode-newSlug-open{margin:1em 0;background-color:transparent;outline-color:transparent;outline-offset:1em;-webkit-transition:all 400ms ease-out;-moz-transition:all 400ms ease-out;transition:all 400ms ease-out}.ve-ce-branchNode-blockSlug \u003E .oo-ui-buttonWidget{opacity:0.5;display:block}.ve-ce-branchNode-blockSlug \u003E .oo-ui-buttonElement-frameless.oo-ui-iconElement:first-child{ margin-left:0}.ve-ce-branchNode-blockSlug \u003E .oo-ui-buttonWidget \u003E .oo-ui-buttonElement-button{display:block}.ve-ce-surface-dragging .ve-ce-branchNode-blockSlug \u003E .oo-ui-buttonElement \u003E .oo-ui-buttonElement-button{ -moz-user-select:text}.ve-ce-chimera{width:0;height:0}.ve-ce-chimera-webkit{  height:1em}.ve-ce-chimera-gecko{ border:1px solid transparent; margin-right:-2px}.ve-ce-chimera-debug{vertical-align:middle;width:auto;height:auto}.ve-ce-unicorn:not(.ve-ce-unicorn-debug){width:0;height:0} pre.ve-ce-branchNode{  word-wrap:normal}  li.ve-ce-branchNode p.ve-ce-branchNode:first-child{margin:0;padding:0}  .ve-ce-contentBranchNode{white-space:pre-wrap} .ve-ce-contentBranchNode:empty:before{content:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)} .ve-ce-focusableNode:not(pre){white-space:normal} .ve-ce-attachedRootNode{cursor:text; box-sizing:border-box} .ve-ce-surface-readOnly .ve-ce-attachedRootNode{caret-color:transparent} .ve-ce-attachedRootNode::selection,.ve-ce-attachedRootNode *::selection{background:rgba(109,169,247,0.5); } .ve-ce-attachedRootNode [contentEditable='false']{overflow-wrap:initial;-webkit-line-break:initial} .ve-ce-generatedContentNode-generating{opacity:0.5} .ve-ce-horizontalRuleNode{ overflow:auto} .ve-ce-commentNode \u003E .ve-ce-focusableNode-invisibleIcon.oo-ui-iconElement .oo-ui-labelElement-label{  font-family:monospace,monospace;font-size:0.8125em} .ve-ce-languageAnnotation{border-bottom:1px dashed #ccc;background-color:#ebf3f5}  .ve-init-target-ie .ve-ce-languageAnnotation{background:none} .ve-ce-linkAnnotation.ve-ce-annotation-active{box-shadow:0 0 0 1px #c6e0ff;border-radius:2px;padding:2px;margin:-2px;background-color:#e6f1ff}.ve-init-mobileTarget .ve-ce-surface:not(.ve-ce-surface-deactivated) .ve-ce-linkAnnotation.ve-ce-annotation-active{box-shadow:0 0 0 1px #36c;background-color:transparent}.ve-ce-nail:not(.ve-ce-nail-debug){width:0;height:0}.ve-ce-nail-debug{vertical-align:middle}.ve-init-target-ctrl-meta-down .ve-ce-linkAnnotation{cursor:pointer} .ve-ce-resizableNode-handles{position:absolute;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.ve-ce-resizableNode-handles-resizing{box-shadow:inset 0 0 0 1px rgba(0,0,0,0.2);background:rgba(0,0,0,0.1)}.ve-ce-resizableNode-handles div{position:absolute;width:11px;height:11px;background-repeat:no-repeat}.ve-ce-resizableNode-nwHandle{cursor:nw-resize;left:-6px;top:-6px}.ve-ce-resizableNode-neHandle{cursor:ne-resize;right:-6px;top:-6px}.ve-ce-resizableNode-swHandle{cursor:sw-resize;bottom:-6px;left:-6px}.ve-ce-resizableNode-seHandle{cursor:se-resize;bottom:-6px;right:-6px}.ve-ce-resizableNode-nwHandle,.ve-ce-resizableNode-seHandle{background-image:url(\"data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2211%22 height=%2211%22 viewBox=%220 0 11 11%22%3E %3Cpath id=%22shadow%22 fill=%22none%22 stroke=%22%23000%22 stroke-linejoin=%22round%22 stroke-width=%223.5%22 d=%22M2 2v4l1.5-1.5 3 3L5 9h4V5L7.5 6.5l-3-3L6 2z%22 opacity=%22.25%22/%3E %3Cpath id=%22outline%22 fill=%22%23fff%22 stroke=%22%23fff%22 stroke-linejoin=%22round%22 stroke-width=%222%22 d=%22M2 2v4l1.5-1.5 3 3L5 9h4V5L7.5 6.5l-3-3L6 2z%22/%3E %3Cpath id=%22fill%22 d=%22M2 2v4l1.5-1.5 3 3L5 9h4V5L7.5 6.5l-3-3L6 2z%22/%3E %3C/svg%3E\")}.ve-ce-resizableNode-neHandle,.ve-ce-resizableNode-swHandle{background-image:url(\"data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2211%22 height=%2211%22 viewBox=%220 0 11 11%22%3E %3Cpath id=%22shadow%22 fill=%22none%22 stroke=%22%23000%22 stroke-linejoin=%22round%22 stroke-width=%223.5%22 d=%22M9 2v4L7.5 4.5l-3 3L6 9H2V5l1.5 1.5 3-3L5 2z%22 opacity=%22.25%22/%3E %3Cpath id=%22outline%22 fill=%22%23fff%22 stroke=%22%23fff%22 stroke-linejoin=%22round%22 stroke-width=%222%22 d=%22M9 2v4L7.5 4.5l-3 3L6 9H2V5l1.5 1.5 3-3L5 2z%22/%3E %3Cpath id=%22fill%22 d=%22M9 2v4L7.5 4.5l-3 3L6 9H2V5l1.5 1.5 3-3L5 2z%22/%3E %3C/svg%3E\")}.ve-ce-resizableNode-hide-nw .ve-ce-resizableNode-nwHandle,.ve-ce-resizableNode-hide-ne .ve-ce-resizableNode-neHandle,.ve-ce-resizableNode-hide-sw .ve-ce-resizableNode-swHandle,.ve-ce-resizableNode-hide-se .ve-ce-resizableNode-seHandle{display:none}.ve-ce-resizableNode-sizeLabel{position:absolute;text-align:center;opacity:0;-webkit-transition:opacity 200ms;-moz-transition:opacity 200ms;transition:opacity 200ms}.ve-ce-resizableNode-sizeLabel-resizing{opacity:1}.ve-ce-resizableNode-sizeText{padding:0.25em 0.5em;border:1px solid #c8ccd1;background-color:#fff;border-radius:2px;white-space:nowrap}.ve-ce-resizableNode-sizeText span:not(:first-child){margin-left:0.4em;padding-left:0.4em;border-left:1px solid #c8ccd1}.ve-ce-resizableNode-sizeText-warning{background-color:#ecc;border-color:#caa}  .ve-ce-sectionNode:before,.ve-ce-sectionNode:after{content:'\\00a0';display:block;overflow:hidden;height:0}.ve-ce-sectionNode{opacity:1;-webkit-transition:opacity 250ms ease;-moz-transition:opacity 250ms ease;transition:opacity 250ms ease}.ve-ce-sectionNode:not(.ve-ce-activeNode-active){opacity:0.5} .ve-ce-tableCellableNode{border:1px dotted #c8ccd1;padding:0.25em 0.5em;min-width:1em} .ve-ce-tableNode-active \u003E * \u003E tr \u003E .ve-ce-tableCellableNode{border-style:solid}.ve-ce-tableCellNode-editing{cursor:text}.ve-ce-tableCellNode a{pointer-events:none}.ve-ce-tableCellNode-editing a{pointer-events:auto}.ve-ce-tableCellNode \u003E .ve-ce-branchNode-blockSlug{visibility:hidden}.ve-ce-tableCellNode-editing \u003E .ve-ce-branchNode-blockSlug{visibility:visible}.ve-ce-tableCellNode .ve-ce-paragraphNode{margin:0} .ve-ce-tableNode{border-spacing:0;border-collapse:collapse;cursor:default}.ve-ce-tableCaptionNode{cursor:text}.ve-ce-tableNode-active .ve-ce-tableCaptionNode,.ve-ce-tableCaptionNode.ve-ce-activeNode-active{border:1px dotted #c8ccd1;border-bottom:0;margin-top:-1px}.ve-ce-tableNodeOverlay{position:absolute;pointer-events:none}.ve-ce-tableNodeOverlay .ve-ui-tableLineContext{pointer-events:auto}.ve-ce-tableNodeOverlay-selection-box{position:absolute;background:rgba(109,169,247,0.3); -webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;opacity:0.6}.ve-ce-tableNodeOverlay-deactivated .ve-ce-tableNodeOverlay-selection-box{background:rgba(0,0,0,0.3);opacity:0.3}.ve-ce-tableNodeOverlay-selection-box-notEditable{background-image:-webkit-repeating-linear-gradient(-45deg,transparent 0 transparent 5px,#95d14f 5px,#95d14f 10px);background-image:-moz-repeating-linear-gradient(-45deg,transparent 0,transparent 5px,#95d14f 5px,#95d14f 10px);background-image:repeating-linear-gradient(-45deg,transparent 0,transparent 5px,#95d14f 5px,#95d14f 10px)}.ve-ce-tableNodeOverlay-selection-box-anchor{position:absolute;border:solid 1px #6da9f7;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.ve-ce-tableNodeOverlay-deactivated .ve-ce-tableNodeOverlay-selection-box-anchor{border:solid 1px rgba(0,0,0,0.3)}.ve-ce-tableNodeOverlay-editing .ve-ce-tableNodeOverlay-selection-box{background:transparent}.ve-ce-tableNode-missingCell{border:0 !important; padding:0 !important; }.ve-ce-tableNode-missingCell \u003E .oo-ui-buttonWidget \u003E .oo-ui-buttonElement-button{ padding-top:0;padding-left:0} .ve-ce-surface{ position:relative;z-index:0; } .ve-ce-surface-deactivatedSelection{position:absolute;top:0;left:0;opacity:0.5;pointer-events:none}.ve-ce-surface-deactivatedSelection-showAsDeactivated{opacity:0.15}.ve-ce-surface-deactivatedSelection \u003E div{position:absolute;background:#6da9f7;margin-top:-0.15em;padding:0.15em 0}.ve-ce-surface-deactivatedSelection-showAsDeactivated \u003E div{background:#000}.ve-ce-surface-deactivatedSelection-collapsed{opacity:1; }  .ve-init-target-ie-or-edge .ve-ce-surface-deactivatedSelection \u003E div{opacity:0.5}.ve-init-target-ie-or-edge .ve-ce-surface-deactivatedSelection-showAsDeactivated \u003E div{opacity:0.15}.ve-ce-surface-dropMarker{height:1px;background:#72777d;pointer-events:none;position:absolute}.ve-ce-surface-highlights-user-selections{opacity:0.5;pointer-events:none}.ve-ce-surface-highlights-user-cursors{pointer-events:none}.ve-ce-surface-highlights-user-selection{position:absolute;background:#faa;box-shadow:inset 0 0 0 1px #a66}.ve-ce-surface-highlights-user-cursor{position:absolute;background:#a66;width:2px}.ve-ce-surface-highlights-user-cursor-label{position:absolute;font-size:0.7em;background:#a66;color:#fff;text-shadow:0 0 1px rgba(0,0,0,0.5);padding:0.2em;top:-1.4em;height:1em;line-height:1;white-space:nowrap;max-width:10em;overflow:hidden;text-overflow:ellipsis}.ve-ce-surface-highlights-user-cursor-inactive,.ve-ce-surface-highlights-user-selection-inactive{opacity:0.5}.ve-ce-surface-paused{opacity:0.5}.ve-ce-surface-paste{position:fixed; top:3em;left:0; height:1px;opacity:0;overflow:hidden}.ve-ce-surface-paste *{height:1px !important; }  .ve-init-target-ie-or-edge .ve-ce-surface-paste a{color:#36c;text-decoration:underline !important; }.ve-ce-cursorHolder{position:absolute;width:0;height:0}.ve-ce-cursorHolder-img{width:0;height:0}.ve-ce-cursorHolder-debug{width:2px;height:1em;border:1px solid #d33} .ve-ui-toolbarDialog-padded .oo-ui-window-body{padding:0.375em; }.ve-ui-toolbarDialog-position-above{overflow-y:hidden;max-height:0;-webkit-transition:max-height 250ms;-moz-transition:max-height 250ms;transition:max-height 250ms}.oo-ui-toolbar-position-top .ve-ui-toolbarDialog-position-above{border-top:1px solid #c8ccd1}.oo-ui-toolbar-position-bottom .ve-ui-toolbarDialog-position-above{border-bottom:1px solid #c8ccd1}.ve-ui-toolbarDialog-position-above.oo-ui-window-ready{ max-height:150px}.ve-ui-toolbarDialog-position-side{position:absolute;right:0;background:#fff;border-left:1px solid #c8ccd1;overflow-x:hidden;width:0;margin-top:1px;-webkit-transition:width 250ms;-moz-transition:width 250ms;transition:width 250ms}.ve-ui-surface-toolbarDialog-side{-webkit-transition:margin 250ms,min-height 250ms;-moz-transition:margin 250ms,min-height 250ms;transition:margin 250ms,min-height 250ms;min-height:40em}.ve-ui-toolbarDialog-shield{display:none}.ve-ui-toolbarDialog-disabled{opacity:0.2}.ve-ui-toolbarDialog-disabled .ve-ui-toolbarDialog-shield{display:block;position:absolute;top:0;bottom:0;left:0;right:0} .ve-ui-toolbarDialog .oo-ui-window-head{height:0;outline:0}.ve-ui-toolbarDialog .oo-ui-window-body{top:0} .ve-ui-toolbarDialog .oo-ui-window-frame{position:relative} .ve-ui-commandHelpDialog-container{-moz-columns:3 19.5em;-webkit-columns:3 19.5em;columns:3 19.5em}.ve-ui-commandHelpDialog-section{ display:inline-block;width:100%}.ve-ui-commandHelpDialog-section h3{text-align:center;margin:0;padding:0}.ve-ui-commandHelpDialog-list{margin:0.5em 0 1.5em 0}.ve-ui-commandHelpDialog-list dd{display:inline-block;vertical-align:top;width:45%;margin:0}.ve-ui-commandHelpDialog-list dt{display:inline-block;vertical-align:top;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;width:55%;padding-right:1em;text-align:right}.ve-ui-commandHelpDialog-list dt kbd{  font-family:monospace,monospace;font-size:0.8125em;font-weight:bold;font-style:normal}.ve-ui-commandHelpDialog-list dt \u003E kbd{display:block;clear:right} .ve-ui-commandHelpDialog-list dt kbd ~ kbd{margin-top:0.5em}.ve-ui-commandHelpDialog-list dt kbd \u003E kbd{background-color:#f8f9fa;color:#222;font-size:1em; border:1px solid #c8ccd1;border-radius:2px;box-shadow:0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;display:inline-block;line-height:1.4;padding:0.1em 0.4em;margin:-0.1em 0.3em 0;text-shadow:0 1px 0 #fff;text-transform:uppercase;text-align:center}.ve-ui-commandHelpDialog-list dt kbd[data-label]:before{content:attr(data-label);font-weight:normal;font-style:italic;padding-right:3px}.ve-ui-commandHelpDialog-sequence kbd:not(.ve-ui-commandHelpDialog-specialKey){box-shadow:none;text-transform:none}.ve-ui-commandHelpDialog-sequence kbd:not(.ve-ui-commandHelpDialog-specialKey) + kbd:not(.ve-ui-commandHelpDialog-specialKey){margin-left:-0.5em;padding-left:0;border-left:0;border-top-left-radius:0;border-bottom-left-radius:0}.ve-ui-commandHelpDialog-list dd,.ve-ui-commandHelpDialog-list dt{line-height:1.4;margin-top:0.5em;margin-bottom:0.5em} .ve-ui-findAndReplaceDialog-row{display:table;min-width:30em;padding-bottom:0.3em}.ve-ui-findAndReplaceDialog-row:last-child{ padding-bottom:1px}.ve-ui-findAndReplaceDialog-cell{display:table-cell;vertical-align:middle;white-space:nowrap;padding-right:1em}.ve-ui-findAndReplaceDialog-cell:last-child{padding-right:0}.ve-ui-findAndReplaceDialog-cell-input{width:100%}.ve-ui-findAndReplaceDialog-cell-input .oo-ui-textInputWidget{max-width:none} .ve-ui-findAndReplaceDialog-findResults{position:absolute;top:0;left:0;pointer-events:none}.ve-ui-findAndReplaceDialog-findResult{opacity:0.2}.ve-ui-findAndReplaceDialog-findResult \u003E div{background:#28bb0b;position:absolute;margin-top:-0.15em;padding:0.15em 0;border-radius:2px}.ve-ui-findAndReplaceDialog-findResult-focused{opacity:0.4}.ve-ui-findAndReplaceDialog-findResult-focused \u003E div{background:#1f850b}  .ve-init-target-ie-or-edge .ve-ui-findAndReplaceDialog-findResult \u003E div{opacity:0.2}.ve-init-target-ie-or-edge .ve-ui-findAndReplaceDialog-findResult-focused \u003E div{opacity:0.4} .ve-ui-progressDialog-row{display:table;width:100%}.ve-ui-progressDialog-row:not(:last-child){margin-bottom:1em}.ve-ui-progressDialog-row .oo-ui-fieldLayout{display:table-cell;padding-bottom:0.45em}.ve-ui-progressDialog-row .oo-ui-buttonWidget{display:table-cell;vertical-align:bottom;width:1.9em;padding-left:1em} .ve-ui-specialCharacterDialog .oo-ui-outlineOptionWidget{padding:0.25em 0.5em}.ve-ui-specialCharacterDialog .oo-ui-bookletLayout{height:150px} .oo-ui-dialog .ve-ui-specialCharacterDialog .oo-ui-bookletLayout .oo-ui-menuLayout-menu{width:10em}.oo-ui-dialog .ve-ui-specialCharacterDialog .oo-ui-bookletLayout .oo-ui-menuLayout-content{left:10em}.oo-ui-bookletLayout-stackLayout \u003E .ve-ui-specialCharacterPage{padding:0.5em}.ve-ui-specialCharacterPage h3{color:#54595d;margin:0 0 0.5em 0;font-weight:normal;font-size:1em}.ve-ui-specialCharacterPage-characters{white-space:normal}.ve-ui-specialCharacterPage-character{cursor:pointer;font-size:1.5em;line-height:1.8em;min-width:1.8em;height:1.8em;text-align:center;display:inline-block;vertical-align:top;margin:0 3px 3px 0;border:1px solid #eaecf0;-webkit-transition:border-color 200ms;-moz-transition:border-color 200ms;transition:border-color 200ms}.ve-ui-specialCharacterPage-character:hover{border-color:#c8ccd1}.ve-ui-specialCharacterPage-character-source{ font-family:monospace,'Courier';font-size:1em;line-height:2.7em;height:2.7em;padding:0 0.2em} .ve-ui-tableDialog-panel{max-width:20em;margin:0 auto}.ve-ui-tableDialog .oo-ui-fieldLayout.oo-ui-fieldLayout-align-left.oo-ui-labelElement \u003E .oo-ui-fieldLayout-body \u003E .oo-ui-fieldLayout-header{width:75%;margin-right:0}.ve-ui-tableDialog .oo-ui-fieldLayout.oo-ui-fieldLayout-align-left \u003E .oo-ui-fieldLayout-body \u003E .oo-ui-fieldLayout-field{width:25%;text-align:right} .ve-ui-previewElement .ve-ce-branchNode-slug,.ve-ui-previewElement .ve-ce-nail{display:none} .oo-ui-menuToolGroup-tools .oo-ui-tool-name-paragraph .oo-ui-tool-title{font-weight:normal}.oo-ui-menuToolGroup-tools .oo-ui-tool-name-heading1 .oo-ui-tool-title{font-size:190%;font-weight:normal}.oo-ui-menuToolGroup-tools .oo-ui-tool-name-heading2 .oo-ui-tool-title{font-size:150%;font-weight:normal}.oo-ui-menuToolGroup-tools .oo-ui-tool-name-heading3 .oo-ui-tool-title{font-size:130%;font-weight:bold}.oo-ui-menuToolGroup-tools .oo-ui-tool-name-heading4 .oo-ui-tool-title{font-size:115%;font-weight:bold}.oo-ui-menuToolGroup-tools .oo-ui-tool-name-heading5 .oo-ui-tool-title{font-size:100%;font-weight:bold}.oo-ui-menuToolGroup-tools .oo-ui-tool-name-heading6 .oo-ui-tool-title{font-size:80%;font-weight:bold}.oo-ui-menuToolGroup-tools .oo-ui-tool-name-preformatted .oo-ui-tool-title{  font-family:monospace,monospace}.oo-ui-menuToolGroup-tools .oo-ui-tool-name-blockquote .oo-ui-tool-title{ text-indent:1.5em}.oo-ui-menuToolGroup-tools .oo-ui-tool-name-tableCellHeader .oo-ui-tool-title{font-weight:bold} .ve-ui-completionWidget{position:absolute;margin-top:0.5em} .ve-ui-contextOptionWidget{padding:0.5em 1em 0.5em 3em}.ve-ui-contextOptionWidget .oo-ui-labelElement-label{color:#54595d; max-width:19.4em;text-overflow:ellipsis;overflow:hidden}.ve-ui-contextOptionWidget .oo-ui-iconElement-icon{opacity:0.8}.ve-ui-contextOptionWidget.oo-ui-optionWidget-highlighted,.ve-ui-contextOptionWidget.oo-ui-optionWidget-selected,.ve-ui-contextOptionWidget.oo-ui-optionWidget-pressed{background-color:transparent}.ve-ui-contextOptionWidget.oo-ui-optionWidget-highlighted .oo-ui-iconElement-icon{opacity:1} .ve-ui-contextSelectWidget{padding:0} .ve-ui-dimensionsWidget,.ve-ui-dimensionsWidget \u003E .oo-ui-textInputWidget{display:inline-block}.ve-ui-dimensionsWidget .oo-ui-textInputWidget{width:3.5em}.ve-ui-dimensionsWidget .oo-ui-labelWidget{padding-right:0.5em;line-height:2.35em;vertical-align:middle}.ve-ui-dimensionsWidget .oo-ui-labelWidget:last-child{padding-right:0} .ve-ui-mediaSizeWidget .oo-ui-fieldLayout \u003E .oo-ui-fieldLayout-body \u003E .oo-ui-labelElement-label{width:6em}.ve-ui-mediaSizeWidget-section-scale .oo-ui-fieldLayout-field \u003E .oo-ui-textInputWidget input{width:5em;margin-right:0.5em} .ve-ui-commentInspector-content .oo-ui-textInputWidget{width:100%} .ve-ui-fragmentInspector-container.oo-ui-panelLayout-padded,.ve-ui-fragmentInspector-container .oo-ui-indexLayout-stackLayout \u003E .oo-ui-panelLayout-padded{padding:0.75em}.ve-ui-fragmentInspector-content .oo-ui-processDialog-actions-other .oo-ui-buttonElement-framed{margin-left:0;margin-bottom:0} .oo-ui-window-content-setup:not(.oo-ui-window-content-ready) .ve-ui-fragmentInspector-container{overflow:hidden} .ve-ui-targetWidget .ve-ui-surface .ve-ce-attachedRootNode,.ve-ui-targetWidget .ve-ui-surface .ve-ui-surface-placeholder{ padding:0.625em 1.25em}.ve-ui-targetWidget .ve-ui-debugBar{padding:1em} .ve-ui-context-hidden{display:none} .ve-ui-contextItem{ cursor:default}.ve-ui-contextItem + .ve-ui-contextItem{border-top:1px solid #eaecf0} .ve-ui-linearContextItem-head{min-height:32px;padding:0.5em;display:flex;align-items:center}.ve-ui-linearContextItem-title{padding:0 0.5em;white-space:nowrap;flex:1}.ve-ui-mobileContext .ve-ui-linearContextItem-title{font-weight:bold}.ve-ui-linearContextItem-title \u003E .oo-ui-labelWidget{margin-left:0.3em;word-wrap:break-word;white-space:pre-line;vertical-align:middle}.ve-ui-linearContextItem-body{max-height:15em;overflow:auto}.ve-ui-mobileContext .ve-ui-linearContextItem-head \u003E .oo-ui-buttonWidget{margin:0 0.5em}.ve-ui-mobileContext .ve-ui-linearContextItem-empty .ve-ui-linearContextItem-head \u003E .oo-ui-buttonWidget{margin:0.5em}.ve-ui-linearContextItem + .ve-ui-linearContextItem .ve-ui-linearContextItem-close{ display:none}.ve-ui-mobileContext .ve-ui-linearContextItem-body-action-wrapper{  border-top:1px solid #eaecf0;display:flex;align-items:center;flex-wrap:wrap;min-height:4.5em}.ve-ui-mobileContext .ve-ui-linearContextItem-body-action{display:flex;width:100%}.ve-ui-mobileContext .ve-ui-linearContextItem-empty .ve-ui-linearContextItem-body-action-wrapper{display:none}.ve-ui-mobileContext .ve-ui-linearContextItem-body{padding:0.5em 1em;flex:1}.ve-ui-mobileContext .ve-ui-linearContextItem-actions{width:auto;padding:0.25em 0.5em}.ve-ui-desktopContext .ve-ui-linearContextItem-body:not(:empty){padding:0 1em 1em 1em}.ve-ui-linearContextItem-foot:not(:empty){border-top:1px solid #eaecf0;padding:0.25em 1em;text-align:right} .ve-ui-tableLineContextItem-actionButton{display:block;margin-left:0 !important; }.ve-ui-tableLineContextItem-actionButton.oo-ui-labelElement.oo-ui-iconElement \u003E .oo-ui-buttonElement-button{display:block;border:0.2em solid transparent} .ve-ui-alignableContextItem .ve-ui-linearContextItem-body{text-align:center} .ve-ui-commentContextItem .ve-ui-linearContextItem-body{overflow:auto;max-height:10em;  font-family:monospace,monospace;white-space:pre-wrap;line-height:1.25em}.ve-ui-desktopContext .ve-ui-commentContextItem .ve-ui-linearContextItem-body{padding:0.5em 0.5em 0 0.5em;margin:0 0.5em 1em 0.5em} .ve-ui-languageContextItem .ve-ui-linearContextItem-body{color:#54595d;overflow:hidden;text-overflow:ellipsis;white-space:nowrap} .ve-ui-desktopContext .ve-ui-linkContextItem .ve-ui-linearContextItem-body{padding-bottom:0.8em}.ve-ui-linkContextItem .ve-ui-linkContextItem-link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:block}.ve-ui-mobileContext .ve-ui-linkContextItem .ve-ui-linearContextItem-body{overflow:hidden; word-wrap:break-word}.ve-ui-mobileContext .ve-ui-linkContextItem .ve-ui-linkContextItem-label{display:flex;width:100%;margin-bottom:0.5em}.ve-ui-mobileContext .ve-ui-linkContextItem .ve-ui-linkContextItem-label-label,.ve-ui-mobileContext .ve-ui-linkContextItem .ve-ui-linkContextItem-link-label{display:block;font-size:0.8125em}.ve-ui-mobileContext .ve-ui-linkContextItem .ve-ui-linkContextItem-label-preview{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:bold}.ve-ui-mobileContext .ve-ui-linkContextItem .ve-ui-linkContextItem-label-body{min-width:0}.ve-ui-mobileContext .ve-ui-linkContextItem .ve-ui-linkContextItem-label-action{padding:0.25em 0.5em}.ve-ui-desktopContext .ve-ui-linkContextItem .ve-ui-linkContextItem-label{margin:0.7em -1em 0;padding:0.7em 1em 0;border-top:1px solid #eaecf0;display:flex;width:100%}.ve-ui-desktopContext .ve-ui-linkContextItem .ve-ui-linkContextItem-label \u003E div{white-space:nowrap}.ve-ui-desktopContext .ve-ui-linkContextItem .ve-ui-linkContextItem-label .oo-ui-labelElement-label{display:inline-block;vertical-align:middle}.ve-ui-desktopContext .ve-ui-linkContextItem .ve-ui-linkContextItem-label .ve-ui-linkContextItem-label-preview{flex:1;min-width:0;color:#72777d;padding-left:0.6em}.ve-ui-desktopContext .ve-ui-linkContextItem .ve-ui-linkContextItem-label .ve-ui-linkContextItem-label-preview .oo-ui-labelElement-label{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%}.ve-ui-desktopContext .ve-ui-linkContextItem .ve-ui-linkContextItem-label .ve-ui-linkContextItem-label-label .oo-ui-labelElement-label{padding-left:0.3em}.ve-ui-desktopContext .ve-ui-linkContextItem .ve-ui-linkContextItem-label .ve-ui-linkContextItem-label-action .oo-ui-buttonWidget{margin:-7px -7px -7px 0} .ve-ui-toolContextItem .ve-ui-linearContextItem-body{overflow:hidden;text-overflow:ellipsis;white-space:nowrap} .ve-ui-overlay{font-family:sans-serif;position:absolute;top:0;right:0;left:0;z-index:1}.ve-ui-overlay \u003E *{z-index:1}.ve-ui-overlay-global{ z-index:2} .ve-ui-overlay-global-mobile \u003E .oo-ui-windowManager-modal \u003E .oo-ui-dialog{-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0); -webkit-transition:-webkit-transform 0.3s,opacity 0.3s;transition:transform 0.3s,opacity 0.3s}.ve-ui-overlay-global-mobile \u003E .oo-ui-windowManager-modal \u003E .oo-ui-dialog.oo-ui-window-ready{-webkit-transform:none;transform:none} .ve-ui-surface{position:relative}.ve-ui-surface:after{content:'.';display:block;clear:both;visibility:hidden;line-height:0;height:0}.ve-ui-surface-placeholder{opacity:0.33;position:absolute;left:0;right:0}.ve-ui-surface-placeholder,.ve-ui-surface .ve-ce-attachedRootNode{ padding:0.05px 0}.ve-ui-surface-source .ve-ui-surface-placeholder,.ve-ui-surface-source .ve-ce-attachedRootNode{  font-family:monospace,monospace;-moz-tab-size:4;tab-size:4}.ve-ui-surface-source .ve-ce-paragraphNode{margin:0;word-wrap:break-word;white-space:pre-wrap} .ve-ui-toolbar{ position:relative}.ve-ui-toolbar \u003E .oo-ui-toolbar-bar{ z-index:2} .ve-ui-toolbar-floating \u003E .oo-ui-toolbar-bar{position:fixed;top:0;border-top:0}.ve-ui-toolbar.oo-ui-toolbar-position-bottom \u003E .oo-ui-toolbar-bar{ z-index:auto}.ve-ui-toolbar \u003E .oo-ui-toolbar-bar .oo-ui-toolbar-bar{ z-index:auto} .ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools{display:flex}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools .oo-ui-barToolGroup .oo-ui-tool-link{min-height:3em}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-toolGroup{flex:1}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .ve-ui-toolbar-group-back{border-right:1px solid #eaecf0}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-toolGroup-empty{display:none}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-indicatorElement \u003E .oo-ui-popupToolGroup-handle{ padding:3em 0 0 0 !important}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-popupToolGroup \u003E .oo-ui-popupToolGroup-handle \u003E .oo-ui-iconElement-icon,.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-popupToolGroup \u003E .oo-ui-popupToolGroup-handle \u003E .oo-ui-indicatorElement-indicator{left:50%}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-popupToolGroup \u003E .oo-ui-popupToolGroup-handle \u003E .oo-ui-iconElement-icon{ margin-left:-0.714285em}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-popupToolGroup.oo-ui-indicatorElement{ flex:1.2}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-popupToolGroup.oo-ui-indicatorElement \u003E .oo-ui-popupToolGroup-handle \u003E .oo-ui-iconElement-icon{margin-left:-1em}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-popupToolGroup \u003E .oo-ui-popupToolGroup-handle \u003E .oo-ui-indicatorElement-indicator{margin-left:0.375em;width:0.5625em;min-width:0.5625em}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-barToolGroup{text-align:center}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-barToolGroup \u003E .oo-ui-toolGroup-tools \u003E .oo-ui-tool{width:100%}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-barToolGroup \u003E .oo-ui-toolGroup-tools \u003E .oo-ui-tool \u003E .oo-ui-tool-link{padding:0.875em 0}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-barToolGroup \u003E .oo-ui-toolGroup-tools \u003E .oo-ui-tool \u003E .oo-ui-tool-link \u003E .oo-ui-iconElement-icon:not(.oo-ui-tool-checkIcon){position:static;display:inline-block;vertical-align:middle}.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-barToolGroup \u003E .oo-ui-toolGroup-tools \u003E .oo-ui-tool \u003E .oo-ui-tool-link \u003E .oo-ui-tool-title{vertical-align:middle;margin-left:0.3em}@media screen and (max-width:767px){.ve-ui-targetToolbar-mobile .oo-ui-toolbar-tools \u003E .oo-ui-barToolGroup \u003E .oo-ui-toolGroup-tools \u003E .oo-ui-tool \u003E .oo-ui-tool-link \u003E .oo-ui-tool-title{ display:none !important}} .ve-ui-tableLineContext{ z-index:3}.ve-ui-tableLineContext \u003E .oo-ui-iconWidget.oo-ui-iconElement.oo-ui-iconElement-icon{position:absolute;display:block;background-color:#d3e5fd;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;cursor:pointer;margin:0}.ve-ui-tableLineContext-col \u003E .oo-ui-iconWidget.oo-ui-iconElement.oo-ui-iconElement-icon{width:100%;height:1em;min-height:auto; top:-1.2em;border-bottom:0}.ve-ui-tableLineContext-row \u003E .oo-ui-iconWidget.oo-ui-iconElement.oo-ui-iconElement-icon{width:1em;min-width:auto; left:-1.2em;border-right:0}.ve-ui-tableLineContext-table \u003E .oo-ui-iconWidget.oo-ui-iconElement.oo-ui-iconElement-icon{height:1em;width:1em;min-width:auto;min-height:auto; top:-1.2em;left:-1.2em;border-bottom:0;border-right:0}.ve-ce-tableNodeOverlay-deactivated .ve-ui-tableLineContext \u003E .oo-ui-iconWidget.oo-ui-iconElement.oo-ui-iconElement-icon{background-color:#ddd}.ve-ui-tableLineContext-menu{z-index:2} .ve-ui-debugBar{clear:both}.ve-ui-debugBar-commands{margin-bottom:-0.5em}.ve-ui-debugBar-commands \u003E .oo-ui-widget,.ve-ui-debugBar-commands-divider{display:inline-block;vertical-align:middle;margin-right:1em;margin-bottom:0.5em}.ve-ui-debugBar-commands \u003E .oo-ui-widget:last-child{margin-right:0}.ve-ui-debugBar-selectionLabel{min-width:20em;  font-family:monospace,monospace}.ve-ui-debugBar-commands-divider{border-right:1px solid #c8ccd1;width:0}.ve-ui-debugBar-dump{margin-top:2em}.ve-ui-debugBar-dump \u003E table{background-color:#f8f9fa;font-size:0.85em;width:100%;border:1px solid #c8ccd1;border-radius:0;border-top-right-radius:0.25em;border-top-left-radius:0.25em}.ve-ui-debugBar-dump \u003E .oo-ui-toggleWidget{margin-bottom:0.25em}.ve-ui-debugBar-dump td{background-color:#fff;padding:0.25em 1em;vertical-align:top}.ve-ui-debugBar-dump-linmod-data{width:50%}.ve-ui-debugBar-dump th{color:#54595d;padding:0.5em 1em;text-shadow:0 1px 1px #fff}.ve-ui-debugBar-dump ol{color:#72777d;padding-left:1.5em}.ve-ui-debugBar-dump li .ve-ui-debugBar-dump-element,.ve-ui-debugBar-dump li .ve-ui-debugBar-dump-char,.ve-ui-debugBar-dump li .ve-ui-debugBar-dump-achar{background-color:#f8f9fa;color:#000;display:inline-block;border-radius:2px;margin:0.25em 0.25em 0.25em 0;padding:0.125em 0.5em;text-shadow:0 1px 1px #fff}.ve-ui-debugBar-dump li .ve-ui-debugBar-dump-element{background-color:#def}.ve-ui-debugBar-dump li .ve-ui-debugBar-dump-char{background-color:#dfe}.ve-ui-debugBar-dump li .ve-ui-debugBar-dump-achar{background-color:#fed}.ve-ui-debugBar-dump li .ve-ui-debugBar-dump-note{color:#a2a9b1}.ve-ui-debugBar-filibuster{background-color:#f8f9fa;font-size:0.875em;margin-top:2em;width:100%;border:1px solid #c8ccd1;border-radius:0;border-top-right-radius:0.25em;border-top-left-radius:0.25em}.ve-ui-debugBar-transactions \u003E ol \u003E li{border-left:2em solid #f8f9fa}.ve-ui-debugBar-transactions ol ol{margin:1em 0;padding-left:0}.ve-ui-debugBar-transactions ol ol li{padding-left:1ex}  .ve-ui-targetWidget{border:1px solid #a2a9b1;border-radius:2px;transition:border-color 250ms,box-shadow 250ms}.ve-ui-targetWidget \u003E :last-child{border-bottom:0}.ve-ui-targetWidget-focused{border-color:#36c;box-shadow:inset 0 0 0 1px #36c}.ve-ui-targetWidget-readOnly:not(.oo-ui-pendingElement-pending){background:#f8f9fa}.ve-ui-targetWidget .ve-ui-targetToolbar{margin:1px}.ve-ui-targetWidget:not(.ve-ui-targetWidget-focused) .ve-ui-targetToolbar \u003E .oo-ui-toolbar-bar{ margin:0 -1px;padding:0 1px} .ve-ui-linearContextItem-body{min-height:0.2em}"]
}, {
    "visualeditor": "VisualEditor",
    "visualeditor-aliencontextitem-title": "Item",
    "visualeditor-aliennode-tooltip": "Sorry, this element can only be edited in source mode for now.",
    "visualeditor-align-desc-center": "center",
    "visualeditor-align-desc-default": "default",
    "visualeditor-align-desc-left": "left",
    "visualeditor-align-desc-none": "none",
    "visualeditor-align-desc-right": "right",
    "visualeditor-align-widget-center": "Center",
    "visualeditor-align-widget-default": "Default",
    "visualeditor-align-widget-left": "Left",
    "visualeditor-align-widget-right": "Right",
    "visualeditor-alignablecontextitem-title": "Alignment",
    "visualeditor-annotationbutton-big-tooltip": "Big",
    "visualeditor-annotationbutton-bold-tooltip": "Bold",
    "visualeditor-annotationbutton-code-tooltip": "Computer code",
    "visualeditor-annotationbutton-italic-tooltip": "Italic",
    "visualeditor-annotationbutton-link-tooltip": "Link",
    "visualeditor-annotationbutton-small-tooltip": "Small",
    "visualeditor-annotationbutton-strikethrough-tooltip": "Strikethrough",
    "visualeditor-annotationbutton-subscript-tooltip": "Subscript",
    "visualeditor-annotationbutton-superscript-tooltip": "Superscript",
    "visualeditor-annotationbutton-underline-tooltip": "Underline",
    "visualeditor-changedir": "Change directionality",
    "visualeditor-changedir-tool-ltr": "View as left-to-right",
    "visualeditor-changedir-tool-rtl": "View as right-to-left",
    "visualeditor-clearbutton-tooltip": "Remove",
    "visualeditor-clipboard-copy": "Copy",
    "visualeditor-clipboard-cut": "Cut",
    "visualeditor-clipboard-paste": "Paste",
    "visualeditor-clipboard-paste-special": "Paste as plain text",
    "visualeditor-command-dialog-cancel": "Close / cancel change",
    "visualeditor-command-dialog-confirm": "Confirm change",
    "visualeditor-command-dialog-focus-context": "Move focus to contextual popup",
    "visualeditor-commentinspector-edit": "Edit comment",
    "visualeditor-commentinspector-title": "Comment",
    "visualeditor-commentinspector-tooltip": "Comment",
    "visualeditor-content-select-all": "Select all",
    "visualeditor-contextitemwidget-label-close": "Close",
    "visualeditor-contextitemwidget-label-remove": "Delete",
    "visualeditor-contextitemwidget-label-secondary": "Edit",
    "visualeditor-contextitemwidget-label-view": "View",
    "visualeditor-debugbar-close": "Close",
    "visualeditor-debugbar-inputdebug": "Input debugging",
    "visualeditor-debugbar-logrange": "Log selected",
    "visualeditor-debugbar-showmodel": "Show model",
    "visualeditor-debugbar-showtransactions": "Show transactions",
    "visualeditor-debugbar-startfilibuster": "Filibuster",
    "visualeditor-debugbar-stopfilibuster": "Stop Filibuster",
    "visualeditor-debugbar-testsquasher": "Test squasher",
    "visualeditor-debugbar-updatemodel": "Update on changes",
    "visualeditor-dialog-action-apply": "Apply changes",
    "visualeditor-dialog-action-cancel": "Cancel",
    "visualeditor-dialog-action-done": "Done",
    "visualeditor-dialog-action-goback": "Go back",
    "visualeditor-dialog-action-insert": "Insert",
    "visualeditor-dialog-command-help-title": "Keyboard shortcuts",
    "visualeditor-dialog-error": "Something went wrong",
    "visualeditor-dialog-error-dismiss": "Go back",
    "visualeditor-dialog-table-caption": "Caption",
    "visualeditor-dialog-table-title": "Table properties",
    "visualeditor-dimensionswidget-px": "px",
    "visualeditor-dimensionswidget-times": "",
    "visualeditor-find-and-replace-diacritic": "Diacritic insensitive",
    "visualeditor-find-and-replace-diacritic-unavailable": "Diacritic insensitive search not available in this browser",
    "visualeditor-find-and-replace-done": "Done",
    "visualeditor-find-and-replace-find-text": "Find",
    "visualeditor-find-and-replace-invalid-regex": "Invalid regular expression",
    "visualeditor-find-and-replace-match-case": "Match case",
    "visualeditor-find-and-replace-next-button": "Find next",
    "visualeditor-find-and-replace-previous-button": "Find previous",
    "visualeditor-find-and-replace-regular-expression": "Regular expression",
    "visualeditor-find-and-replace-replace-all-button": "Replace all",
    "visualeditor-find-and-replace-replace-button": "Replace",
    "visualeditor-find-and-replace-replace-text": "Replace",
    "visualeditor-find-and-replace-results": "$1 of $2",
    "visualeditor-find-and-replace-title": "Find and replace",
    "visualeditor-find-and-replace-word": "Whole word",
    "visualeditor-formatdropdown-format-blockquote": "Block quote",
    "visualeditor-formatdropdown-format-heading-label": "Heading (1-6)",
    "visualeditor-formatdropdown-format-heading1": "Heading 1",
    "visualeditor-formatdropdown-format-heading2": "Heading 2",
    "visualeditor-formatdropdown-format-heading3": "Heading 3",
    "visualeditor-formatdropdown-format-heading4": "Heading 4",
    "visualeditor-formatdropdown-format-heading5": "Heading 5",
    "visualeditor-formatdropdown-format-heading6": "Heading 6",
    "visualeditor-formatdropdown-format-paragraph": "Paragraph",
    "visualeditor-formatdropdown-format-preformatted": "Preformatted",
    "visualeditor-formatdropdown-title": "Change format",
    "visualeditor-help-tool": "Help",
    "visualeditor-historybutton-redo-tooltip": "Redo",
    "visualeditor-historybutton-undo-tooltip": "Undo",
    "visualeditor-horizontalrule-tooltip": "Horizontal rule",
    "visualeditor-indentationbutton-indent-tooltip": "Increase indentation",
    "visualeditor-indentationbutton-outdent-tooltip": "Decrease indentation",
    "visualeditor-inspector-close-tooltip": "Close",
    "visualeditor-inspector-remove-tooltip": "Remove",
    "visualeditor-key-alt": "Alt",
    "visualeditor-key-backspace": "Backspace",
    "visualeditor-key-ctrl": "Ctrl",
    "visualeditor-key-delete": "Delete",
    "visualeditor-key-down": "Down",
    "visualeditor-key-end": "End",
    "visualeditor-key-enter": "Enter",
    "visualeditor-key-escape": "Escape",
    "visualeditor-key-home": "Home",
    "visualeditor-key-insert": "Insert",
    "visualeditor-key-left": "Left",
    "visualeditor-key-meta": "Meta",
    "visualeditor-key-page-down": "Page Down",
    "visualeditor-key-page-up": "Page Up",
    "visualeditor-key-right": "Right",
    "visualeditor-key-shift": "Shift",
    "visualeditor-key-space": "Space",
    "visualeditor-key-tab": "Tab",
    "visualeditor-key-up": "Up",
    "visualeditor-languagecontext-remove": "Remove language",
    "visualeditor-linkcontext-label-change": "Change text",
    "visualeditor-linkcontext-label-fallback": "No preview",
    "visualeditor-linkcontext-label-label": "Text",
    "visualeditor-linkcontext-remove": "Remove link",
    "visualeditor-linkinspector-title": "Link",
    "visualeditor-linkinspector-title-add": "Add a link",
    "visualeditor-linkinspector-title-edit": "Edit link",
    "visualeditor-listbutton-bullet-tooltip": "Bullet list",
    "visualeditor-listbutton-number-tooltip": "Numbered list",
    "visualeditor-mediasizewidget-label-defaulterror": "Size values are invalid.",
    "visualeditor-mediasizewidget-label-scale": "Scale",
    "visualeditor-mediasizewidget-label-scale-percent": "% of thumbnail size",
    "visualeditor-mediasizewidget-sizeoptions-custom": "Custom",
    "visualeditor-mediasizewidget-sizeoptions-default": "Default",
    "visualeditor-mediasizewidget-sizeoptions-scale": "Scale",
    "visualeditor-shortcuts-clipboard": "Clipboard",
    "visualeditor-shortcuts-dialog": "Window controls",
    "visualeditor-shortcuts-formatting": "Paragraph formatting",
    "visualeditor-shortcuts-history": "History",
    "visualeditor-shortcuts-insert": "Insert",
    "visualeditor-shortcuts-other": "Other",
    "visualeditor-shortcuts-sequence-notice": "Type",
    "visualeditor-shortcuts-text-style": "Text styling",
    "visualeditor-slug-insert": "Insert paragraph",
    "visualeditor-specialcharacter-button-tooltip": "Special character",
    "visualeditor-specialcharacterinspector-title": "Special character",
    "visualeditor-table-caption": "Caption",
    "visualeditor-table-context-col": "Column",
    "visualeditor-table-context-row": "Row",
    "visualeditor-table-contextitem-properties": "Properties",
    "visualeditor-table-contextitem-selectionmode-cells": "Select cells",
    "visualeditor-table-contextitem-selectionmode-contents": "Select contents",
    "visualeditor-table-delete-col": "Delete {{PLURAL:$1|column|columns}}",
    "visualeditor-table-delete-row": "Delete {{PLURAL:$1|row|rows}}",
    "visualeditor-table-format-data": "Content cell",
    "visualeditor-table-format-header": "Header cell",
    "visualeditor-table-insert-col-after": "Insert after",
    "visualeditor-table-insert-col-before": "Insert before",
    "visualeditor-table-insert-row-after": "Insert below",
    "visualeditor-table-insert-row-before": "Insert above",
    "visualeditor-table-insert-table": "Table",
    "visualeditor-table-merge-cells": "Merge cells",
    "visualeditor-table-merge-cells-merge": "Merge",
    "visualeditor-table-merge-cells-unmerge": "Unmerge",
    "visualeditor-table-move-col-after": "Move after",
    "visualeditor-table-move-col-before": "Move before",
    "visualeditor-table-move-row-after": "Move below",
    "visualeditor-table-move-row-before": "Move above",
    "visualeditor-table-sum": "Sum: $1, Average: $2",
    "visualeditor-tablecell-tooltip": "Double click to edit cell",
    "visualeditor-toolbar-format-tooltip": "Format paragraph",
    "visualeditor-toolbar-history": "History",
    "visualeditor-toolbar-insert": "Insert",
    "visualeditor-toolbar-paragraph-format": "Formatting",
    "visualeditor-toolbar-structure": "Structure",
    "visualeditor-toolbar-style-tooltip": "Style text",
    "visualeditor-toolbar-table": "Table",
    "visualeditor-toolbar-text-style": "Styling"
});
